*vimtips.txt* This file comes from the Vim Online tip database.  These tips
were downloaded on Tue, 24 Sep 2002 15:27:26 -0700 More tips can be found at <A
HREF="http://vim.sf.net/tip_index.php">http://vim.sf.net/tip_index.php</A><BR>
A new tip file can be downloaded from <A
HREF="http://vim.sf.net/tip_download.php">http://vim.sf.net/tip_download.php</A><BR>

Thanks for using vim online.

<Tip category="KVim"> <html><center>the super star</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=1">http://vim.sf.net/tip_view.php?tip_id=1</A><BR>

When a discussion started about learning vim on the vim list Juergen Salk
mentioned the "*" key as something that he wished he had know earlier. When
I read the mail I had to go help on what the heck the "*" did. I also wish
I had known earlier...

Using the "*" key while in normal mode searches for the word under the cursor.

If that doesn't save you a lot of typing, I don't know what will.

</pre></tip> </html> <Tip category="KVim"> <html><center>easy
edit of files in the same directory</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=2">http://vim.sf.net/tip_view.php?tip_id=2</A><BR>

It was often frustrating when I would open a file deep in the code tree and
then realize I wanted to open another file in that same directory. Douglas
Potts taught me a nice way to do this. Add the following snipit to your vimrc:

"   Edit another file in the same directory as the current file "   uses
expression to extract path from current file's path "  (thanks Douglas Potts)
if has("unix")
    map ,e :e &lt;C-R&gt;=expand("%:p:h") . "/" &lt;CR&gt;
else
    map ,e :e &lt;C-R&gt;=expand("%:p:h") . "\" &lt;CR&gt;
endif

Then when you type ,e in normal mode you can use tab to complete to the
file. You can also expand this to allow for spitting, etc. Very very nice.

</pre></tip> </html> <Tip category="KVim"> <html><center>use
vim to quickly compile java files</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=3">http://vim.sf.net/tip_view.php?tip_id=3</A><BR>

For a number of years I used vim on an SGI box. When I left my job at SGI
I went to a company that developed on PCs. For 2 years I used IDEs. I was
unhappy. I was frustrated. I couldn't figure out why. (Beyond my machine
crashing twice a day.) Finally I upgraded to windows 2000 (kind of stable!) and
started using vim as an IDE. All was good. Here is how you use vim to compile
your java:

1. While I'm sure this works with javac, javac is slow slow slow. So download
the Jikes complier first. (Jikes is from ibm, search on google for jikes
and you will find it..available on most platforms.)

2. Add the following to your vimrc:

set makeprg=jikes -nowarn -Xstdout +E % set
errorformat=%f:%l:%c:%*\d:%*\d:%*\s%m

3. When you are editing a java file type :make and it will compile the
current file and jump you to the first error in the file (if any). Read
":help quickfix" for how to move between errors.

To setup your classpath environment either launch gvim from a shell that
has your classpath/path setup or use the "let" command to configure it in
your vimrc.

</pre></tip> </html> <Tip category="KVim">
<html><center>Any word completion</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=4">http://vim.sf.net/tip_view.php?tip_id=4</A><BR>

Either when programming or writing, I tend to have some identifiers or words
that I use all the time. By sheer accident, I noticed the 'ctrl-n' command,
that will attempt to complete the word under the cursor. Hit it once, and it
will try to complete it with the first match in the current file. If there is
no match, it will (at least in the case of C code) search through all files
included from the current one. Repeated invocations will cycle through all
found matches.

</pre></tip> </html> <Tip category="KVim">
<html><center>Quickly searching for a word</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=5">http://vim.sf.net/tip_view.php?tip_id=5</A><BR>

To search for a word under the cursor in the current file you can use either
the "*" or "#" keys.

The "*" key will search for the word from the current cursor position to
the end of the file. The "#" key will search for the word from the current
cursor position to the top of the file.

Note that the above two keys will search for the whole word and not the
partial word.  This is equivalent to using the &lt;word&gt; pattern in the
search commands (/ and ?).

To search for partial matches, you can use the "g*" and "g#" key sequence.

You can also use the mouse to search for a word.  This will only work in
the GUI version of VIM (gvim) or a console version of VIM in an xterm which
accepts a mouse. Also, the 'mousemodel' should be set to 'extend'.  Add the
following line to your .vimrc:

set mousemodel=extend

To search for a word under the cursor from the current cursor position to
the end of the file, press the shift key and click on the word using the
left mouse button.  To search in the opposite direction, press the shift
key and click on the word using the the right mouse button.

To get more help on these, use

:help * :help # :help g* :help g# :help &lt;S-LeftMouse&gt; :help
&lt;S-RightMouse&gt;

</pre></tip> </html> <Tip category="KVim">
<html><center>Using the % key</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=6">http://vim.sf.net/tip_view.php?tip_id=6</A><BR>

The % key can be used

1. To jump to a matching opening or closing parenthesis, square
   bracket or a curly brace i.e. ([{}])
2. To jump to start or end of a C-style comment /* */.  3. To jump to a
matching #if, #ifdef, #else, #elif, #endif C
   preprocessor conditionals.

To get more information about this, do

             :help %

The % key can be extended to support other matching pairs by modifying the
"matchpairs" option.  Read the help on

             :help matchpairs

</pre></tip> </html> <Tip category="KVim"> <html><center>Jumping
to the start and end of a code block</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=7">http://vim.sf.net/tip_view.php?tip_id=7</A><BR>

To jump to the beginning of a C code block (while, switch, if etc), use the
[{ command.

To jump to the end of a C code block (while, switch, if etc), use the ]}
command.

The above two commands will work from anywhere inside the code block.

To jump to the beginning of a parenthesis use the [( command.

To jump to the end of a parenthesis use the ]) command.

To get more help on these commands, do

:help [{ :help ]} :help [( :help ])

</pre></tip> </html> <Tip category="KVim"> <html><center>Jumping
to the declaration of a local/global variable</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=8">http://vim.sf.net/tip_view.php?tip_id=8</A><BR>

'gd' command: To jump to the declaration of a local variable in a C program,
position the cursor on the name of the variable and use the gd command.

'gD' command: To jump to the declaration of a global variable in a C program,
position the cursor on the name of the variable and use the gD command.

</pre></tip> </html> <Tip category="KVim"> <html><center>Displaying
a variable/macro definition</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=9">http://vim.sf.net/tip_view.php?tip_id=9</A><BR>

To display the definition of a variable, place the cursor on the variable
and use the [i command.  To display a macro definition, place the cursor on
the macro name and use the [d command.  Note that these commands will work
most of the time (not all the time).  To get more help on these commands, use

:help [i :help [d

</pre></tip> </html> <Tip category="KVim"> <html><center>Jumping
to previosuly visited locations in a file</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=10">http://vim.sf.net/tip_view.php?tip_id=10</A><BR>

Vim remembers all the locations visited by you in a file in a session.
You can jump to the older locations by pressing the Ctrl-O key.  You can
jump to the newer locations by pressing the Ctrl-I or the &lt;Tab&gt; key.

To get more help on these keys, use

:help CTRL-O :help CTRL-I :help jump-motions

</pre></tip> </html> <Tip category="KVim"> <html><center>Completing
words quicky in insert mode</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=11">http://vim.sf.net/tip_view.php?tip_id=11</A><BR>

In Insert mode, press the Ctrl-p or Ctrl-n key to complete part of a word
that has been typed.

This is useful while typing C programs to complete long variable and
function names.  This also helps in avoiding typing mistakes.

Note that using the 'complete' option, you can complete keywords defined in
one of the include files, tag file, etc.

To get more help on this, use

:help i_Ctrl-N :help i_Ctrl-P :help ins-completion :help complete

</pre></tip> </html> <Tip category="KVim">
<html><center>Converting tabs to spaces</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=12">http://vim.sf.net/tip_view.php?tip_id=12</A><BR>

To insert space characters whenever the tab key is pressed, set the
'expandtab' option:

        set expandtab

With this option set, if you want to enter a real tab character use
Ctrl-V&lt;Tab&gt; key sequence.

To control the number of space characters that will be inserted when the tab
key is pressed, set the 'tabstop' option.  For example, to insert 4 spaces
for a tab, use:

        set tabstop=4

After the 'expandtab' option is set, all the new tab characters entered will
be changed to spaces.  This will not affect the existing tab characters.
To change all the existing tab characters to match the current tab settings,
use

        :retab

To change the number of space characters inserted for indentation, use the
'shiftwidth' option:

        set shiftwidth=4

For example, to get the following coding style,
        - No tabs in the source file - All tab characters are 4 space
        characters

use the following set of options:

        set tabstop=4 set shiftwidth=4 set expandtab

Add the above settings to your .vimrc file.

To get more help on these options, use :help tabstop :help shiftwidth :help
expandtab

</pre></tip> </html> <Tip category="KVim">
<html><center>Incremental search</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=13">http://vim.sf.net/tip_view.php?tip_id=13</A><BR>

To move the cursor to the matched string, while typing the search string,
set the following option in the .vimrc file:

        set incsearch

You can complete the search by pressing the Enter key.  To cancel the search,
press the escape key.

</pre></tip> </html> <Tip category="KVim"> <html><center>Highlighting
all the search pattern matches</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=14">http://vim.sf.net/tip_view.php?tip_id=14</A><BR>

To highlight all the search pattern matches in a file set the following option:

        :set hlsearch

After this option is set, if you search for a pattern, all the matches in
the file will be highlighted in yellow.

To disable the highlighting temporarily, use the command

        :nohlsearch

This command will remove the highlighting for the current search.
The highlighting will come back for the next search.

To disable the highlighting completely, set the following option:

        :set nohlsearch

By default, the hlsearch option is turned off.

To get more help on this option, use

:help 'hlsearch' :help :nohlsearch

</pre></tip> </html> <Tip category="KVim">
<html><center>Displaying status line always</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=15">http://vim.sf.net/tip_view.php?tip_id=15</A><BR>

To display the status line always, set the following option in your .vimrc
file:

        set laststatus=2

The advantage of having the status line displayed always is, you can see
the current mode, file name, file status, ruler, etc.

To get more help on this, use

:help laststatus

</pre></tip> </html> <Tip category="KVim"> <html><center>Avoiding
the "Hit ENTER to continue" prompts</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=16">http://vim.sf.net/tip_view.php?tip_id=16</A><BR>

To avoid the "Hit ENTER to continue" prompt, use the 'shortmess' option.
Add the following line to your .vimrc file:

    set shortmess=a

Also, you can increase the height of the command line to 2

    set cmdheight=2

The default command height is 1.

To get more help on these options, use

:help hit-enter :help shortmess :help cmdheight

</pre></tip> </html> <Tip category="KVim"> <html><center>Erasing
previosuly entered characters in insert mode</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=17">http://vim.sf.net/tip_view.php?tip_id=17</A><BR>

In insert mode, to erase previously entered characters, set the following
option:

        set backspace=2

By default, this option is empty.  If this option is empty, in insert mode,
you can not erase characters entered before this insert mode started.
This is the standard Vi behavior.

To get more help on this, use

:help 'backspace'

</pre></tip> </html> <Tip category="KVim">
<html><center>Cleanup your HTML</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=18">http://vim.sf.net/tip_view.php?tip_id=18</A><BR>

From Johannes Zellner on the vim list:

You can use vim's makeprg and equalprg to clean up HTML. First download
html tidy from <A HREF="http://www.w3.org/People/Raggett/tidy/. Then use
the following commands.">http://www.w3.org/People/Raggett/tidy/. Then use
the following commands.</A><BR>

vim6?  exe 'setlocal equalprg=tidy -quiet -f '.&errorfile setlocal makeprg=tidy
-quiet -e %

vim5?  exe 'set equalprg=tidy -quiet -f '.&errorfile set makeprg=tidy -quiet
-e %

At this point you can use make to clean up the full file or you can use =
to clean up sections.

:help = :help equalprg :help makeprg

</pre></tip> </html> <Tip category="KVim">
<html><center>line numbers...</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=19">http://vim.sf.net/tip_view.php?tip_id=19</A><BR>

I have started doing all my code reviews on a laptop because of the number
command.

:set number will put line numbers along the left side of a window

:help number

</pre></tip> </html> <Tip category="KVim"> <html><center>Are *.swp
and *~ files littering your working directory?</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=20">http://vim.sf.net/tip_view.php?tip_id=20</A><BR>

Have you ever been frustrated at swap files and backups cluttering up your
working directory?

Untidy:
  ons.txt ons.txt~ README README~ tester.py tester.py~

Here are a couple of options that can help:

  set   backupdir=./.backup,.,/tmp set   directory=.,./.backup,/tmp

This way, if you want your backups to be neatly grouped, just create
a directory called '.backup' in your working directory.  Vim will stash
backups there. The 'directory' option controls where swap files go. If your
working directory is not writable, Vim will put the swap file in one of the
specified places.

</pre></tip> </html> <Tip category="KVim">
<html><center>easy pasting to windows apps</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=21">http://vim.sf.net/tip_view.php?tip_id=21</A><BR>

In Vim, the unnamed register is the " register, and the Windows Clipboard is
the * register. This means that if you yank something, you have to yank it to
the * register if you want to paste it into a Windows app. If this is too much
trouble, set the 'clipboard' option to 'unnamed'. Then you always yank to *.

So pasting to windows apps doesn't require prefixing "* :

  set   clipboard=unnamed

</pre></tip> </html> <Tip category="KVim"> <html><center>handle
common typos for :commands</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=22">http://vim.sf.net/tip_view.php?tip_id=22</A><BR>

I frequently hold the shift key for too long when typing, for instance :wq,
and end up with :Wq.  Vim then whines "Not an editor command: Wq"

In my .vimrc, I have taught vim my common typos: command! Q  quit command! W
write command! Wq wq " this one won't work, because :X is already a built-in
command command! X  xit

</pre></tip> </html> <Tip category="KVim">
<html><center>Vim xterm title</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=23">http://vim.sf.net/tip_view.php?tip_id=23</A><BR>

Check out your .vimrc. If 'set notitle' is an entry, comment it out with
a quotation mark ("). Now your xterm should inherit the title from Vim.
e.g. 'Vim - ~/.vimrc'. This can be quite nice when programming and editing
lots of files at the same time.  by [jonasbn@wanadoo.dk]

</pre></tip> </html> <Tip category="KVim"> <html><center>changing
the default syntax highlighting</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=24">http://vim.sf.net/tip_view.php?tip_id=24</A><BR>

     Here are some pointers to the vim documentation.  Notice that the
     mechanism is different in vim 6.0 and vim 5.x.

1. I want *.foo files to be highlighted like HTML files.

:help new-filetype  <A
HREF="http://www.vim.org/html/autocmd.html#new-filetype">http://www.vim.org/html/autocmd.html#new-filetype</A><BR>

2. I want to define a syntax file for *.bar files.  Read the above and also

:help mysyntaxfile  <A
HREF="http://www.vim.org/html/syntax.html#mysyntaxfile">http://www.vim.org/html/syntax.html#mysyntaxfile</A><BR>

3. I want to make a few changes to the existing syntax highlighting.
Depending on the x in 5.x, either read the above and page down a few screens,
or you may be able to skip right to

:help mysyntaxfile-add  <A
HREF="http://www.vim.org/html/syntax.html#mysyntaxfile-add">http://www.vim.org/html/syntax.html#mysyntaxfile-add</A><BR>

4. I want to change some of the colors from their defaults.  Again, read

:help mysyntaxfile  <A
HREF="http://www.vim.org/html/syntax.html#mysyntaxfile">http://www.vim.org/html/syntax.html#mysyntaxfile</A><BR>

</pre></tip> </html> <Tip category="KVim"> <html><center>color
highlighting on telnet (esp w/ SecureCRT)</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=25">http://vim.sf.net/tip_view.php?tip_id=25</A><BR>

The following settings in .vimrc will enable color highlighting when using
SecureCRT and may work on other telnet packages. The terminal type should
be selected as ANSI and color enabled.

if !has("gui_running") set t_Co=8 set t_Sf=^[[3%p1%dm set t_Sb=^[[4%p1%dm endif

The ^[ is entered as "&lt;ctrl-v&gt;&lt;esc&gt;"

</pre></tip> </html> <Tip category="KVim"> <html><center>Getting
rid of ^M - mixing dos and unix</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=26">http://vim.sf.net/tip_view.php?tip_id=26</A><BR>

If you work in a mixed environment you will often open files that have ^M's
in them. An example would be this:

------------------------------------------------------------------
import java.util.Hashtable; ^M import java.util.Properties; ^Mimport
java.io.IOException; import org.xml.sax.AttributeList; ^M import
org.xml.sax.HandlerBase; ^Mimport org.xml.sax.SAXException;

/**^M
  * XMLHandler: This class parses the elements contained^M * within a XML
  message and builds a Hashtable^M

[snip] ------------------------------------------------------------------

Notice that some programs are not consistent in the way they insert the line
breaks so you end up with some lines that have both a carrage return and a
^M and some lines that have a ^M and no carrage return (and so blend into
one). There are two steps to clean this up.

1. replace all extraneous ^M:

:%s/^M$//g

BE SURE YOU MAKE the ^M USING "CTRL-V CTRL-M" NOT BY TYPING "CARROT M"! This
expression will replace all the ^M's that have carriage returns after them
with nothing. (The dollar ties the search to the end of a line)

2. replace all ^M's that need to have carriage returns:

:%s/^M//g

Once again: BE SURE YOU MAKE the ^M USING "CTRL-V CTRL-M" NOT BY TYPING
"CARROT M"! This expression will replace all the ^M's that didn't have
carriage returns after them with a carriage return.

Voila! Clean file. Map this to something if you do it frequently.

:help ffs - for more info on file formats

thanks to jonathan merz, douglas potts, and benji fisher

</pre></tip> </html> <Tip category="KVim">
<html><center>Convert hex to dec</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=27">http://vim.sf.net/tip_view.php?tip_id=27</A><BR>

when you check the output of objdump, you'll confused by the $0xFFFFFFc
operand, this function translate the hexcamal to decimal.  function! Hex2Dec()
    let lstr = getline(".")  let hexstr = matchstr(lstr, '0x[a-f0-9]+')
    while hexstr != ""
        let hexstr = hexstr + 0 exe 's#0x[a-f0-9]+#'.hexstr."#" let lstr =
        substitute(lstr, '0x[a-f0-9]+', hexstr, "") let hexstr = matchstr(lstr,
        '0x[a-f0-9]+')
    endwhile
endfunction usage: 5,8call Hex2Dec()

</pre></tip> </html> <Tip category="KVim"> <html><center>add a line-number
to every line without cat or awk alike utilities.</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=28">http://vim.sf.net/tip_view.php?tip_id=28</A><BR>

With Unix-like environment, you can use cat or awk to generate a line number
easily, because vim has a friendly interface with shell, so everything work
in vim as well as it does in shell.  :%!call -n or :%!awk '{print NR,$0}'

But, if you use vim in MS-DOS, of win9x, win2000, you loss these tookit.
here is a very simple way to archive this only by vim: fu! LineIt()
  exe ":s/^/".line(".")."/"
endf

Well, a sequence composed with alphabet is as easy as above:
  exe "s/^/".nr2char(line("."))."/"

</pre></tip> </html> <Tip category="KVim"> <html><center>reverse
all the line with only 7 keystroke in vim</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=29">http://vim.sf.net/tip_view.php?tip_id=29</A><BR>

:g/^/m0 well, 1. : bring you to command-line mode(also known as ex-mode)
from normal-mode(also known as command mode).  2. g means you'll take an
action through the whole file, generally perform a search, `v' also perform
a search but it match the line not match the canonical expression.  3. /
begins the regular express 4. ^ is a special character respect the start
of a line.  5. the second / ends the regular express and indicate that the
remains is action to do.  6. m means move, `t` and `co' for copy, `d' for
delete 7. 0 is the destination line.

you can use :g/regexp/t$ to filter all lines and pick the match line together
and copy them to the end of the buffer or :g/regexp/y A to put them into a
register(not eax, ebx...)

</pre></tip> </html> <Tip category="KVim">
<html><center>Increasing or decreasing numbers</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=30">http://vim.sf.net/tip_view.php?tip_id=30</A><BR>

To increase a number under or nearest to the right of the cursor, go to
Normal mode and type:
    Ctrl-A

To decrease, type:
    Ctrl-X

Using this in a macro simplifies generating number sequences a lot.

</pre></tip> </html> <Tip category="KVim">
<html><center>Find and Replace</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=31">http://vim.sf.net/tip_view.php?tip_id=31</A><BR>

To find and replace one or more occurences of a given text pattern with a
new text string, use the s[ubstitute] command.

There are a variety of options, but these are what you most probably want:

:%s/foo/bar/g           find each occurance of 'foo' and replace it with
'bar' without asking for confirmation

:%s/foo/bar/gc          find each occurance of 'foo' and replace it with
'bar' asking for confirmation first

:%s/&lt;foo&gt;/bar/gc      find (match exact word only) and replace each
occurance of 'foo' with 'bar'

:%s/foo/bar/gci         find (case insensitive) and replace each occurance of
'foo' with 'bar'

:%s/foo/bar/gcI         find (case sensitive) and replace each occurance of
'foo' with 'bar'

NB: Without the 'g' flag, replacement occurs only for the first occurrence
in each line.

For a full description and some more interesting examples of the substitute
command refer to

:help substitute

See also:

:help cmdline-ranges :help pattern :help gdefault

</pre></tip> </html> <Tip category="KVim"> <html><center>Write
your own vim function(scripts)</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=32">http://vim.sf.net/tip_view.php?tip_id=32</A><BR>

compare to C and shell(bash), herein is some vim specifics about vim-script:
1. A function name must be capitalized.
   hex2dec is invalid Hex2dec is valid while in c and shell(bash), both
   lowercase and uppercase is allowed.
2. how to reference the parameters
   fu! Hex2dec(var1, var2)
    let str=a:var1 let str2=a:var2
   you must prefix the parameter name with "a:", and a:var1 itself is read-only
   in c, you reference the parameter directly and the parameter is writable.
3. how to implement variable parameter
   fu! Hex2dec(fixpara, ...)
     a:0 is the real number of the variable parameter when you invoke the
     function, with :Hex2dec("asdf", 4,5,6), a:0=3, and a:1=4 a:2=5 a:3=6
   you can combine "a:" and the number to get the value while i&lt;a:0
     exe "let num=a:".i let i=i+1
   endwhile in c, the function get the real number by checking the additional
   parameter such as printf family, or by checking the special value such
   as NULL
4. where is the vim-library
  yes, vim has its own function-library, just like *.a in c :help functions
5. can I use += or ++ operator?
  Nop, += and ++ (and -=, -- and so on)operator gone away in vim.
6. How can I assign a value to a variables and fetch its value?
   let var_Name=value let var1=var2 like it does in c, except you must use
   let keyword
7. Can I use any ex-mode command in a function?
  As I know, yes, just use it directly, as if every line you type appears
  in the familar :
8. Can I call a function recurse?
  Yes, but use it carefully to avoid infinte call.
9. Can I call another function in a function?
  Course, like C does.
10. Must I compile the function?
   No, you needn't and you can't, just :so script_name, after this you can
   call the function freely.
11. Is it has integer and char or float data type?
   No, like perl, vim script justify the variable type depend upon the context
   :let a=1 :let a=a."asdf" :echo a you'll get `1asdf' :let a=1 :let a=a+2
   :echo a you'll get 3 But it differs from perl.
12. Must I append a `;' in every statement?
   No, never do that.  ; is required in C, and optional in shell for each
   statement in a alone line.  But is forbidden in vim.  if you want combine
   servals statement in one single line, use `|'.  Take your mind that every
   statement appears in function should be valid in ex-mode(except for some
   special statement).

</pre></tip> </html> <Tip category="KVim"> <html><center>toggle
off the line-number when enter on-line help</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=33">http://vim.sf.net/tip_view.php?tip_id=33</A><BR>

I like the line-number for myself editing. But I hate it in on-line help
page because it force the screen wrapped.  :au filetype help :se nonu

</pre></tip> </html> <Tip category="KVim"> <html><center>control
the position of the new window</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=34">http://vim.sf.net/tip_view.php?tip_id=34</A><BR>

:se splitbelow make the new window appears below the current window.
:se splitright make the new window appears in right.(only 6.0 version can
do a vsplit)

</pre></tip> </html> <Tip category="KVim"> <html><center>translate
// style comment to /*  */and vice vesa</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=35">http://vim.sf.net/tip_view.php?tip_id=35</A><BR>

the `|' concatenate servals ex-command in one line.  It's the key to translate
// style comments to /* */ style :g#^s{-}//#s##/*# | s#$#*/#

the `|' keep the current line matchs ^s{-}// to perform s#$#*/

/* ... */ ---&gt; //style :g#/*(.{-})*/#//1#

/* ....
   ....  .....
*/ =====&gt; //......  //......  //......  style: ? Anyone implement it?

</pre></tip> </html> <Tip category="KVim">
<html><center>Using Gnu-info help in vim</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=36">http://vim.sf.net/tip_view.php?tip_id=36</A><BR>

K in normal bring you the man page about the keyword under current cursor.
:nnoremap &lt;F1&gt; :exe ":!info ".expand("&lt;cword&gt;") Now press F1
while the cursor is hold by a keyword such as printf will bring you to
Gnu-info help page :h &lt;F1&gt; :h nnoremap

</pre></tip> </html> <Tip category="KVim"> <html><center>The
basic operation about vim-boolean optionals</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=37">http://vim.sf.net/tip_view.php?tip_id=37</A><BR>

:set number switch the number on :set nonumber switch it off :set invnumber
or :set number!  switch it inverse against the current setting :set number&
get the default value vim assums.

replace number with any legal vim-boolean optionals, they all works well.
for vim-non-boolean optionals :set optional& also works properly.

</pre></tip> </html> <Tip category="KVim"> <html><center>Cursor
one line at a time when :set wrap</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=38">http://vim.sf.net/tip_view.php?tip_id=38</A><BR>

If your tierd of the cursor jumping past 5 lines when :set wrap then add
these mappings to you vimrc file.

nnoremap j gj nnoremap k gk vnoremap j gj vnoremap k gk nnoremap &lt;Down&gt;
gj nnoremap &lt;Up&gt; gk vnoremap &lt;Down&gt; gj vnoremap &lt;Up&gt;
gk inoremap &lt;Down&gt; &lt;C-o&gt;gj inoremap &lt;Up&gt; &lt;C-o&gt;gk

What they do is remap the cursor keys to use there `g' equvilant. See :help gj

</pre></tip> </html> <Tip category="KVim">
<html><center>Undo and Redo</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=39">http://vim.sf.net/tip_view.php?tip_id=39</A><BR>

To undo recent changes, use the u[ndo] command:

u              undo last change (can be repeated to undo preceding commands)
U              return the line to its original state (undo all changes in
current line) CTRL-R         Redo changes which were undone (undo the undo's).

For a full description of the undo/redo commands refer to

:help undo

</pre></tip> </html> <Tip category="KVim">
<html><center>Insert a file</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=40">http://vim.sf.net/tip_view.php?tip_id=40</A><BR>

To insert the contents of a file (or the output of a system command) into
the current buffer, use the r[ead] command:

Examples:

:r foo.txt        inserts the file foo.txt below the cursor

:0r foo.txt       inserts the file foo.txt above the first line

:r !ls            inserts a listing of your directory below the cursor

:$r !pwd          inserts the current working directory below the last line

For more information about the r[ead] command refer to:

:help read

See also:

:help cmdline-ranges :help !cmd

</pre></tip> </html> <Tip category="KVim"> <html><center>Command-history
facilities for Oracle/sqlplus user</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=41">http://vim.sf.net/tip_view.php?tip_id=41</A><BR>

	First of all, thanks Benji fisher,  Stefan Roemer...
and others in vim@vim.org which spend much time to answer questions,
sometimes foolish question asked by someone like me. Without their I can't
get the final solution for my sqlplus work descripted follows.
	As Oracle user known, sqlplus has a very bad
command-line edition environment. It has no command-history, don't support
most of getline facilities. which MySQL and shell does it well.  Even Microsoft
recogonize this point. In Windows2000, doskey is installed by default.
	Below is my vim-solution to sqlplus, which
record the command-history when you use edit(sqlplus builtin command) to
open the editor specified by EDITOR environment variable. It saves the SQL
statement into a standalone file such as .sqlplus.history
	Every time you open the file
afiedt.buf(sqlplus's default command-buffer file), you get two splited windows,
the buffer above is afiedt.buf, the buffer below is .sqlplus.history, you
can see every SQL statement in the windows.  If you want to use SQL statement
in line 5 to replace
 the current command-buffer, just press 5K, then
	:xa to back to you sqlplus. and use / to repeat the command
 saved in command-buffer file called afiedt.buf by default.
	It can't process multi-line SQL statement convinencely.
 Todo this, just use you favorite vim trick to do that:
	fu! VimSQL()
    nnoremap &lt;C-K&gt; :&lt;C-U&gt;
	exe "let linenum=".v:count&lt;CR&gt;:1,$-1d&lt;CR&gt;&lt;C-W&gt;j:exe
	lin enum."y"&lt;CR&gt;&lt;C-W&gt;kP
    let linenum=line("$") 1,$-1w! &gt;&gt; ~/.sqlplus.history e
    ~/.sqlplus.history execute ":$-".(linenum-1).",$m0" %!uniq if
    line("$")&gt;100
      101,$d
    endif b# set splitbelow sp ~/.sqlplus.history au! BufEnter afiedt.buf
endf au BufEnter afiedt.buf call VimSQL()

</pre></tip> </html> <Tip category="KVim">
<html><center>Using marks</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=42">http://vim.sf.net/tip_view.php?tip_id=42</A><BR>

To mark one or more positions in a file, use the m[ark] command.

Examples:

ma	 -    set current cursor location as mark a

'a	 -    jump to beginning of line of mark a

`a	 -    jump to postition of mark a

d'a	 -    delete from current line to line of mark a

d`a	 -    delete from current cursor position to mark a

c'a	 -    change text from current line to line of mark a

y`a	 -    yank text to unnamed buffer from cursor to mark a

:marks	 -    list all the current marks

NB: Lowercase marks (a-z) are valid within one file. Uppercase marks (A-Z),
also called file marks, are valid between files.

For a detailed description of the m[ark] command refer to

:help mark

See also:

:help various-motions

</pre></tip> </html> <Tip category="KVim">
<html><center>Using abbreviations</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=43">http://vim.sf.net/tip_view.php?tip_id=43</A><BR>

To define abbreviations, use the ab[breviate] command.

Examples:

:ab rtfm read the fine manual  -  Whenever you type 'rtfm' followed by a
&lt;space&gt; (or &lt;esc&gt; or &lt;cr&gt;) vim
				  will expand this to 'read the fine manual'.

:ab			       -  list all defined abbreviations

:una[bbreviate] rtfm	       -  remove 'rtfm' from the list of abbreviations

:abc[lear]		       -  remove all abbreviations

NB: To avoid expansion in insert mode, type CTRL-V after the last character
of the abbreviation.

For a detailed description of the ab[breviate] command and some more examples
refer to

:help abbreviations

</pre></tip> </html> <Tip category="KVim">
<html><center>Repeat last changes</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=44">http://vim.sf.net/tip_view.php?tip_id=44</A><BR>

Simple text changes in normal mode (e.g. "dw" or "J") can be repeated with
the "." command.  The last command-line change (those invoked with ":",
e.g. ":s/foo/bar") can be repeated with the "@:" command.

For more informations about repeating single changes refer to:

:help single-repeat

</pre></tip> </html> <Tip category="KVim">
<html><center>Using command-line history</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=45">http://vim.sf.net/tip_view.php?tip_id=45</A><BR>

You can recall previous command lines from a history table by hitting the
&lt;Up&gt; and &lt;Down&gt; cursor keys in command-line mode.  For example,
this can be used to find the previous substitute command: Type ":s" and
then &lt;Up&gt;.

There are separate history tables for the ':' commands and for previous '/'
or '?' search strings.

To display the history of last entered commands or search strings, use the
:his[tory] command:

:his	   -	  Display command-line history.

:his s	   -	  Display search string history.


For a detailed description of the command-line history refer to:

:help cmdline-history

See also:

:help Cmdline-mode

</pre></tip> </html> <Tip category="KVim"> <html><center>Win32
binaries with perl, python, and tcl</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=46">http://vim.sf.net/tip_view.php?tip_id=46</A><BR>

&gt; Does anyone know if windows binaries of vim 5.7 are available with perl
and &gt; python support turned on?

<A
HREF="ftp://vim.sourceforge.net/pub/vim/upload_binaries/">ftp://vim.sourceforge.net/pub/vim/upload_binaries/</A><BR>

<A
HREF="http://vim.sourceforge.net/bin_download/">http://vim.sourceforge.net/bin_download/</A><BR>

</pre></tip> </html> <Tip category="KVim"> <html><center>Swapping
characters, words and lines</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=47">http://vim.sf.net/tip_view.php?tip_id=47</A><BR>

To swap two characters or lines, use the following commands:

xp	 -     delete the character under the cursor and put it afterwards.
	       (In other words, it swaps the characters.)

ddp	 -     delete the current line and put it afterwards.
	       (In other words, it swaps the lines.)

Unfortunately there is no universal solution to swap two words.  You may
try the following ones, but don't expect too much of them:

dawwP	 -     delete the word under the cursor, move forward one word
	       and put it back after the cursor.  (In other words, it swaps
	       the current and following word.)

dawbP	 -     delete the word under the cursor, move backward on word
	       and put it back after the cursor.  (In other words, it swaps
	       the current and preceeding word.)

</pre></tip> </html> <Tip category="KVim">
<html><center>Moving around</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=48">http://vim.sf.net/tip_view.php?tip_id=48</A><BR>

You can save a lot of time when navigating through the text by using
appropriate movements commands. In most cases the cursor keys, &lt;PageUp&gt;
or &lt;PageDown&gt; are NOT the best choice.

Here is a selection of some basic movement commands that hopefully helps
you to acquire a taste for more:

e   - move to the end of a word w   - move forward to the beginning of a
word 3w  - move forward three words b	- move backward to the beginning of
a word 3b  - move backward three words

$	- move to the end of the line &lt;End&gt;   - same as $ 0	-
move to the beginning of the line &lt;Home&gt;	- same as 0

)   - jump forward one sentence (   - jump backward one sentence

}   - jump forward one paragraph {   - jump backward one paragraph

H   - jump to the top of the display M	 - jump to the middle of the display
L   - jump to the bottom of the display

'm  - jump to the beginning of the line of mark m `m  - jump to the location
of mark m

G   - jump to end of file 1G  - jump to beginning of file 50G - jump to line 50

'' - return to the line where the cursor was before the latest jump `` -
return to the cursor position before the latest jump (undo the jump).

%  - jump to corresponding item, e.g. from an open brace to its
     matching closing brace

For some more interesting movement commands (especially those for programmers)
refer to:

:help motion.txt

:help search-commands

</pre></tip> </html> <Tip category="KVim">
<html><center>Switching case of characters</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=49">http://vim.sf.net/tip_view.php?tip_id=49</A><BR>

To switch the case of one or more characters use the "~", "gU" or "gu"
commands.

Examples:

~     -     switch case of character under cursor
	    (in visual-mode: switch case of highlighted text)

3~    -     switch case of next three characters

g~~   -     switch case of current line

U     -     in visual-mode: make highlighted text uppercase

gUU   -     make current line uppercase

u     -     in visual-mode: make highlighted text lowercase

guu   -     make current line lowercase

gUaw  -     make current word uppercase

guaw  -     make current word lowercase

For some more examples refer to

:help ~

See also:

:help simple-change

</pre></tip> </html> <Tip category="KVim">
<html><center>Recovering files</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=50">http://vim.sf.net/tip_view.php?tip_id=50</A><BR>

If your computer has crashed while editing a file, you should be able to
recover the file by typing

      vi -r &lt;filename&gt;

where &lt;filename&gt; is the name of the file you were editing at the time
of the crash.  If you were editing without a file name, give an empty string
as argument:

      vim -r ""

To get a list of recoverable files start vim without arguments:

      vim -r

For more information about file recovery refer to:

:help recovery

</pre></tip> </html> <Tip category="KVim">
<html><center>Entering german umlauts</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=51">http://vim.sf.net/tip_view.php?tip_id=51</A><BR>

To enter german umlauts (or any other of those weired characters) not
available on your keyboard use 'digraphs':

In insert-mode type for example:

     CTRL-K "a

     CTRL-K ^e

which gives an 'ä' and 'e' with a hat.

You can also set the digraph option:

    :set digraph (or :set dg)

With digraph option set you can enter

    " &lt;BS&gt; a

    ^ &lt;BS&gt; e

which gives the same result.

To get a list of currently defined digraphs type

   :dig[graphs]

For more information about defining and using digraphs refer to:

:help digraph.txt

</pre></tip> </html> <Tip category="KVim">
<html><center>Scrolling synchronously</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=52">http://vim.sf.net/tip_view.php?tip_id=52</A><BR>

If you want to bind two or more windows such that when one window is scrolled,
the other windows are scrolled simultaneously, set the 'scrollbind' option
for these windows:

:set scrollbind

When a window that has 'scrollbind' set is scrolled, all other 'scrollbind'
windows are scrolled the same amount, if possible.

For more information about the 'scrollbind' option refer to

:help scoll-binding

</pre></tip> </html> <Tip category="KVim"> <html><center>Better
colors for syntax highlighting</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=53">http://vim.sf.net/tip_view.php?tip_id=53</A><BR>

For syntax highlighting there are two sets of default color maps: One for a
light and another one for a dark background.  If you have a black background,
use the following command to get a better color map for syntax highlighting:

:set background=dark

You have to switch off and on again syntax highlighting to activate the new
color map:

:syntax off :syntax on

For a detailled description of syntax highlighting refer to

:help syntax.txt

See also the Vim syntax support file: $VIMRUNTIME/syntax/synload.vim

</pre></tip> </html> <Tip category="KVim"> <html><center>View
a Java Class File Decompiled thru Vim</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=54">http://vim.sf.net/tip_view.php?tip_id=54</A><BR>

Hi All, Wish u could view a Java Class File using Vim, Well ur query
ends here.  First of all u will need a Java Decompiler to decompile the
Class File.  I would suggest the JAD decompiler by Pavel Kouznetsov <A
HREF="http://www.geocities.com/SiliconValley/Bridge/8617/jad.html">http://www.geocities.com/SiliconValley/Bridge/8617/jad.html</A><BR>

Its a command line decompiler and absolutely free.  U can use any command
line decompiler of ur choice.

Next create a vimscript file called jad.vim as #########################
FILE START ################ augr class au!  au bufreadpost,filereadpost
*.class %!d:jad.exe -noctor -ff -i -p % au bufreadpost,filereadpost
*.class set readonly au bufreadpost,filereadpost *.class set ft=java au
bufreadpost,filereadpost *.class normal gg=G au bufreadpost,filereadpost
*.class set nomodified augr END ######################## FILE END
#####################

Note:- Keep the Jad.exe in a directory with out white spaces.  The -p options
directs JAD to send the output to standard output instead of a .jad file. Other
options are described on the JAD site.

Next add the following line in the .vimrc file.  so jad.vim

Next time u do vim abc.class. Viola u have the source code for abc.class.

NOTE:- I have written the script so as to open the class file read only,
So that u dont accidently modify it.  U can also exted this script to unjar
a jar file and then view each file in the JAR file.  thanks bhaskar Any
suggestions are welcome

</pre></tip> </html> <Tip category="KVim">
<html><center>previous buffer</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=55">http://vim.sf.net/tip_view.php?tip_id=55</A><BR>

One of the keys to vim is buffer management. If I have to use another IDE
that makes me click on a tab every time I want to look at another file I'm
going to go postal.

So of course you know about :ls which lists all the current open buffers. This
gets a little unweildly once you have a full project open so you can also use
:b &lt;any snipit of text&gt; &lt;tab&gt; to complete to an open buffer. This
is really nice because you can type any fragment of a file name and it will
complete to the matching file. (i.e. RequestManager.java can be completed
using "tma"&lt;tab&gt; or "req"&lt;tab&gt; or "r.java"&lt;tab&gt;).

Now for awhile I was also using :bn and :bp which jumps you to the next
and previous buffer respectively. I found I was often frustrated because I
wanted :bp to be the previous buffer I was in, not the previous buffer in
the list. So (drum roll) the reason I wrote this tip was because of:

:b#

jump to the previous buffer you were in. Very very handy. The only thing
nicer are tag, but that's a tip for another time.

:help buffers :help bn :help bp

If anybody knows where to get help on # in this context please add notes.

</pre></tip> </html> <Tip category="KVim"> <html><center>how
to avoid obliterating window layout</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=58">http://vim.sf.net/tip_view.php?tip_id=58</A><BR>

If you take the time to lay out several windows with vim (especially vertically
in version 6), you may be bummed when you hit an errant key and find that
all but what one window disappears.

What happens: while navigating between windows, you hit &lt;C-W&gt;j,
&lt;C-W&gt;k, etc.  At some point you accidently hit &lt;C-W&gt; but then
don't follow with a window command.  Now hitting 'o' to start insert mode
issues a command equivalent to :only, and closes all windows execept for
the one you are in (unless some windows have unsaved changes in them).

How to avoid this: petition the vim-dev mailing list about how :only is
sufficient for the infrequenty use this might get (j/k).

Really: use mapping to disable the &lt;C-W&gt;o functionality; put this in
your .vimrc:

nnoremap &lt;C-W&gt;O :echo "sucker"&lt;CR&gt; nnoremap &lt;C-W&gt;o :echo
"sucker"&lt;CR&gt; nnoremap &lt;C-W&gt;&lt;C-O&gt; :echo "sucker"&lt;CR&gt;

references:

:help :only :help CTRL-W_o

That is all.  Scott

</pre></tip> </html> <Tip category="KVim"> <html><center>Applying
substitutes to a visual block</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=62">http://vim.sf.net/tip_view.php?tip_id=62</A><BR>

If you'd like to apply a substitute, or even any ex command, to a visual-block
selected text region (ctrl-v and move), then you'll want Stefan Roemer's <A
HREF="http://www.erols.com/astronaut/vim/vimscript/vis.vim .  Just source
it in,">http://www.erols.com/astronaut/vim/vimscript/vis.vim .	Just source
it in,</A><BR> and then press ":B".  On the command line you'll see

:'&lt;,'&gt;BCtrl-V

Just continue with the substitute or whatever...

:'&lt;,'&gt;B s/abc/ABC/g

and the substitute will be applied to just that block of text!

Example: Ctrl-V Select..........|......Type ..................just
the central....|......:B s/abc/ABC/g ..................four
"abc"s..............| ..................----------------....|...-------------
..................abcabcabcabc............|......abcabcabcabc
..................abcabcabcabc............|......abcABCABCabc
..................abcabcabcabc............|......abcABCABCabc
..................abcabcabcabc............|......abcabcabcabc
 (dots inserted to retain tabular format)

</pre></tip> </html> <Tip category="KVim"> <html><center>Applying
substitutes to a visual block</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=63">http://vim.sf.net/tip_view.php?tip_id=63</A><BR>

If you'd like to apply a substitute, or even any ex command, to a visual-block
selected text region (ctrl-v and move), then you'll want Stefan Roemer's <A
HREF="http://www.erols.com/astronaut/vim/vimscript/vis.vim .  Just source
it in,">http://www.erols.com/astronaut/vim/vimscript/vis.vim .	Just source
it in,</A><BR> and then press ":B".  On the command line you'll see

:'&lt;,'&gt;BCtrl-V

Just continue with the substitute or whatever...

:'&lt;,'&gt;B s/abc/ABC/g

and the substitute will be applied to just that block of text!

Example: Ctrl-V Select..........|......Type
..................just the central.......|......:B
s/abc/ABC/g ..................four "abc"s.................|
..................---------............|...-------------
..................abcabcabcabc............|......abcabcabcabc
..................abcabcabcabc............|......abcABCABCabc
..................abcabcabcabc............|......abcABCABCabc
..................abcabcabcabc............|......abcabcabcabc
 (dots inserted to retain tabular format)

</pre></tip> </html> <Tip category="KVim"> <html><center>Always set
your working directory to the file you're editing</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=64">http://vim.sf.net/tip_view.php?tip_id=64</A><BR>

Sometimes I think it's helpful if your working directory is always the same
as the buffer you are editing.	You need to put this in your .vimrc:

function! CHANGE_CURR_DIR()
	let _dir = expand("%:p:h") exec "cd " . _dir unlet _dir
endfunction

autocmd BufEnter * call CHANGE_CURR_DIR()

Doing this will make a "cd" command to your the current buffer each time
you switch to it.  This is actually similar to vimtip#2 but more automatic.

You should see for more details: :help autocmd :help expand :help function

Note: This tip was contributed by somebody on the list a while ago (sorry
for no reference) and it has been extremely helpful to me. Thanks!

</pre></tip> </html> <Tip category="KVim"> <html><center>Insert
line number into the actuall text of the file.</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=65">http://vim.sf.net/tip_view.php?tip_id=65</A><BR>

Although :set number will add nice line number for you At time you may wish
to actually place the line numbers into the file. For example on GNU Unix
you can acomplish a simular task using cat -n file &gt; new_file

In VIM you can use the global command to do this

:g/^/exec "s/^/".strpart(line(".")."	", 0, 4)

What this does is run the exec comand on every line that matches /^/ (All)
The exec command taks a string and executes it as if it were typed in.

line(".")."    " -&gt; returns the number of the current line plus four spaces.
strpart("123	", 0, 4) -&gt; returns only the first four characters ("123 ").
"s/^/123 " -&gt; substituts the begining of the line with "123 ".

</pre></tip> </html> <Tip category="KVim"> <html><center>Transfer
text between two Vim 'sessions',</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=66">http://vim.sf.net/tip_view.php?tip_id=66</A><BR>

This one is a one of my favorites from Dr. Chip, and I haven't seen it come
across vim tips yet...

Can use either visual, or marking to denote the text.

" transfer/read and write one block of text between vim sessions " Usage: "
`from' session: "     ma "     move to end-of-block "	  xw " " `to' session:
"     move to where I want block inserted "	xr " if has("unix")
  nmap xr   :r $HOME/.vimxfer&lt;CR&gt; nmap xw
  :'a,.w! $HOME/.vimxfer&lt;CR&gt; vmap xr   c&lt;esc&gt;:r
  $HOME/.vimxfer&lt;CR&gt; vmap xw   :w! $HOME/.vimxfer&lt;CR&gt;
else
  nmap xr   :r c:/.vimxfer&lt;CR&gt; nmap xw   :'a,.w! c:/.vimxfer&lt;CR&gt;
  vmap xr   c&lt;esc&gt;:r c:/.vimxfer&lt;cr&gt; vmap xw
  :w! c:/.vimxfer&lt;CR&gt;
endif

</pre></tip> </html> <Tip category="KVim">
<html><center>Ascii Value</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=67">http://vim.sf.net/tip_view.php?tip_id=67</A><BR>

Sometimes we, the programmers, need the value of a character, don't we?
You can learn the ascii value of a character by pressing g and a keys.(ga)!
It displays the value in dec, hex and octal...

</pre></tip> </html> <Tip category="KVim">
<html><center>Delete key</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=68">http://vim.sf.net/tip_view.php?tip_id=68</A><BR>

Don't worry if your delete key does not work properly.	Just press
&lt;CTRL&gt;-Backspace.  It works under both mode(insert or normal).

</pre></tip> </html> <Tip category="KVim">
<html><center>dot makes life easier</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=69">http://vim.sf.net/tip_view.php?tip_id=69</A><BR>

You can copy and paste the last changes you made in the last insert mode
without using y and p by pressing . (just dot).  Vim memorizes the keys you
pressed and echos them if you hit the dot key.	You must be in command mode
as usual.  It can be helpful...

</pre></tip> </html> <Tip category="KVim">
<html><center>running a command on all buffers</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=70">http://vim.sf.net/tip_view.php?tip_id=70</A><BR>

From Peter Bismuti on the vim list:

How to global search and replace in all buffers with one command?  You need
the AllBuffers command:

:call AllBuffers("%s/string1/string2/g")

"put this in a file and source it function AllBuffers(cmnd)
  let cmnd = a:cmnd let i = 1 while (i &lt;= bufnr("$"))
    if bufexists(i)
      execute "buffer" i execute cmnd
    endif let i = i+1
  endwhile
endfun

":call AllBuffers("%s/foo/bar/ge|update")

Thanks Peter!

</pre></tip> </html> <Tip category="KVim"> <html><center>Transfer
text between two gvim sessions using clipboard</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=71">http://vim.sf.net/tip_view.php?tip_id=71</A><BR>

If you use gvim, you can transfer text from one instance of gvim into another
one using clipboard.  It is convenient to use * (star) register, like this:

In one instance yank two lines into clipboard:
    "*2yy
Paste it in another instance in normal mode:
    "*p
or in insert mode:
    &lt;Ctrl-R&gt;*

</pre></tip> </html> <Tip category="KVim">
<html><center>Remove unwanted empty lines</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=72">http://vim.sf.net/tip_view.php?tip_id=72</A><BR>

Sometimes to improve the readability of the document I insert empty lines,
which will be later removed.  To get rid off them try: :%g/^$/d This will
remove a l l  empty line in the document.  Some other tipps you can find
under www.linuxclass.de/vim.phtml

</pre></tip> </html> <Tip category="KVim">
<html><center>Using vim as calculator</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=73">http://vim.sf.net/tip_view.php?tip_id=73</A><BR>

Basic calculations can done within vim easily by typing (insert-mode): STRG
(=CTRL) + R followed by = then for example 2+2 and hit RETURN the result 4
will be printed in the document.

Some other tipps you can find under www.linuxclass.de/vim.phtml

</pre></tip> </html> <Tip category="KVim"> <html><center>Using
Vim as an outline processor</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=74">http://vim.sf.net/tip_view.php?tip_id=74</A><BR>

With the addition of folding, Vim6 can function as a high performance outline
processor. Simply :set ai and in insert mode use backspace to promote and
tab to demote headlines.

In command mode, &lt;&lt; promotes (n&lt;&lt; to promote multiple lines),
and &gt;&gt; demotes. Also, highlight several headlines and &lt; or &gt;
to promote or demote.

:set foldmethod=indent, and then your z commands can expand or collapse
headline trees, filewide or by the tree.

The VimOutliner GPL distro contains the scripts and configs to easily
configure Vim6 as an outliner, including scripts to create tag files enabling
interoutline hyperlinking.

The VimOutliner project is at <A
HREF="http://www.troubleshooters.com/projects/vimoutliner/index.htm.">http://www.troubleshooters.com/projects/vimoutliner/index.htm.</A><BR>

Steve (Litt) slitt@troubleshooters.com

</pre></tip> </html> <Tip category="KVim"> <html><center>Remap
CAPSLOCK key in Windows 2000 Professional and NT4.0</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=75">http://vim.sf.net/tip_view.php?tip_id=75</A><BR>

If you're Windows 2000 Professional user and got tired to move your hands off
basic row when hitting &lt;ESC&gt; key here the solution (not for Windows 9x.):
remap CapsLock key as &lt;ESC&gt; key. It's located in useful position.  Put
this lines into &lt;EscLock.reg&gt; file and start it in explorer.Reboot.Enjoy.

REGEDIT4 [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layout]
"Scancode Map"=hex:00,00,00,00,00,00,00,00,02,00,00,00,01,00,3a,00,00,00,00,00

To restore you capslock back just delete this entry from Registry and reboot.
And below is remapping &lt;capslock&gt; as &lt;Left Control&gt;:

REGEDIT4 [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layout]
"Scancode Map"=hex:00,00,00,00,00,00,00,00,02,00,00,00,1d,00,3a,00,00,00,00,00

</pre></tip> </html> <Tip category="KVim">
<html><center>Folding for Quickfix</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=76">http://vim.sf.net/tip_view.php?tip_id=76</A><BR>

The Quickfix mode aims to "speed up the edit-compile-edit cycle" according to
':help quickfix'. After executing ':make' or ':grep' it is possible to skim
through the list of errors/matches and the appropriate source code locations
with, for instance, the ':cnext' command.  Another way to get a quick overview
is to use VIMs folding mode, to fold away all the error-free/match-free
regions.  The script at the end of this message can be used for this
purpose. It is at the moment not elaborate enough to put it up as a 'script';
but it might give someone inspiration to do so.  Big restrictions / bugs are
as follows: 1. Vim Perl interface is required, i.e. the output of ':version'
must contain '+perl' (People with Vim scripting knowledge might fix this)
2. Works only for one file, i.e. the current buffer.  3. It's a quick hack.
Sample usage: (a) edit a file, (b) do ':grep regexp %' to get a quickfix
error list and (c) ':source foldqf.vim' will fold as described Increasing
the value of $CONTEXT gives you more context around the error regions.

Here comes it, it should be 7 lines: ---foldqf.vim cwindow perl $CONTEXT = 0;
perl @A = map { m/\|(\d+)\|/; $1 +0 } $curbuf-&gt;Get(1..$curbuf-&gt;Count());
close normal zD perl sub fold { VIM::DoCommand( $_[0] . ',' . ($_[1]) . "fold"
) if( $_[0] &lt; $_[1] ); } perl $last = 0; for (@A) { fold( $last+1+$CONTEXT,
$_-1-$CONTEXT ); $last = $_; }; VIM::DoCommand(($A[-1]+1+$CONTEXT )
. ',$fold' );

</pre></tip> </html> <Tip category="KVim"> <html><center>Displaying
search results using folds</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=77">http://vim.sf.net/tip_view.php?tip_id=77</A><BR>

A guy I work with told me about a function that an old IBM text editor had
that he said was useful, and that is to create folds in the file after a
search such that every line that is visible contains the search pattern(except
possibly the first). All lines that do not contain the search pattern are
folded up to the last occurence of the pattern or the top of the file.

One use for such a function is to be able to make a quick and dirty api of
a source file.	For example, if working in Java, you could run the function
using the pattern "public|protected|private" and ithe results would be that
only the method headers would be visible (well, close enough).

function! Foldsearch(search)
	normal zE	   "erase all folds to begin with normal G$
	"move to the end of the file let folded = 0	"flag to set when
	a fold is found let flags = "w"    "allow wrapping in the search let
	line1 =  0     "set marker for beginning of fold while search(a:search,
	flags) &gt; 0
		let  line2 = line(".")	"echo "pattern found at line #
		" line2 if (line2 -1 &gt; line1)
			"echo line1 . ":" . (line2-1) "echo "A fold goes here."
			execute ":" . line1 . "," . (line2-1) . "fold"
						let folded = 1	     "at
						least one fold has been found
		endif let line1 = line2     "update marker let flags = "W"
		"turn off wrapping
	endwhile
		" Now create the last fold which goes to the end of the file.
	normal $G let  line2 = line(".")
		"echo "end of file found at line # " line2
	if (line2  &gt; line1 && folded == 1)
		"echo line1 . ":" . line2 "echo "A fold goes here."
		execute ":". line1 . "," . line2 . "fold"
	endif
endfunction

" Command is executed as ':Fs pattern'" command! -nargs=+ -complete=command
Fs call Foldsearch(&lt;q-args&gt;) " View the methods and variables in a
java source file."  command! Japi Fs public\|protected\|private

</pre></tip> </html> <Tip category="KVim">
<html><center>rotating mail signatures</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=78">http://vim.sf.net/tip_view.php?tip_id=78</A><BR>

For people using mutt and vim for mail, the following script will allow
you to insert a new signature (and again and again if you don\'t like the
current one) at the bottom of your mail. This is usefull eg when you don\'t
want to send a potentially offensive quote to someone you don\'t know very
well (or a mailing list), but are too lazy to delete the quote, open your
quotes file, and cut and paste another one in. (I put it here in \'tips\'
and not in \'scripts\' because it is imo too short to be a \'real\' script)

" rotate_sig.vim " Maintainer:	Roel Vanhout &lt;roel@2e-systems.com&gt;
" Version:     0.1 " Last Change: Tuesday, June 12, 2001 " Mapping I use:
" nmap ,r :call RotateSig()&lt;CR&gt; " Usage: " -Make sure you delimit
your sig with '-- ', or adjust the script " -Adjust the last execute to a
command that prints a sig to stdout " Known problems: "   - You'll get an
error message when you're below the last "     '^-- $' in your mail (nothing
bad though - just an not- "	found marker)

function! RotateSig()
    normal mQG execute '?^-- $' execute ':nohl' normal o&lt;ESC&gt; normal
    dG normal &lt;CR&gt; execute 'r !~/bin/autosig ~/.quotes \%' normal `Q
endfunction

</pre></tip> </html> <Tip category="KVim"> <html><center>How to use
:grep to get a clickable list of function names</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=79">http://vim.sf.net/tip_view.php?tip_id=79</A><BR>

The following function will make a :cwindow window with a line per function
in the current C source file. NOTE: It writes the file as a side effect.

Invoke with ':call ShowFunc()' You may want to do :nmap &lt;somekey&gt;
:call ShowFunc()&lt;CR&gt;

function! ShowFunc()

    let gf_s = &grepformat let gp_s = &grepprg

    let &grepformat = '%*\k%*\sfunction%*\s%l%*\s%f %*\s%m' let &grepprg =
    'ctags -x --c-types=f --sort=no -o -'

    write silent! grep % cwindow

    let &grepformat = gf_s let &grepprg = gp_s

endfunc

</pre></tip> </html> <Tip category="KVim"> <html><center>Restore
cursor to file position in previous editing session</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=80">http://vim.sf.net/tip_view.php?tip_id=80</A><BR>

Here's something for your &lt;.vimrc&gt; which will allow you to restore
your cursor position in a file over several editing sessions.  This technique
uses the viminfo option:

Ex. set viminfo='10,\"100,:20,%,n~/.viminfo
    au BufReadPost * if line("'\"") &gt; 0|if line("'\"") &lt;=
    line("$")|exe("norm '\"")|else|exe "norm $"|endif|endif

If you're on Unix, the viminfo is probably fine as is (but check up on Vim's
help for viminfo to see if you like the settings above).  For Windows you'll
need to change the "n" suboption to something like

Ex. set viminfo='10,\"100,:20,%,nc:\\some\\place\\under\\Windoz\\_viminfo

This tip is a somewhat improved version of the example given for :he line()
in the Vim on-line documentation.

</pre></tip> </html> <Tip category="KVim">
<html><center>Substitution of characters and lines in VIM is
made far easier with the s and S commands</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=81">http://vim.sf.net/tip_view.php?tip_id=81</A><BR>

Substitute  Characters ----------------------------------- I was just editing
a file that contained the same leading string on many lines.

example:

foo_bar_baz1=a foo_bar_baz1=abc674 foo_bar_baz1=qrs foo_bar_baz1=m1
foo_bar_baz1=bz90 foo_bar_baz1=bc ...

Needing to only substitute a portion of the string, I referred to a VIM
reference card and discovered a command answering my need exactly. The s
command is used to subsitute a certain number of characters. In my example
file above, if I only needed to subsititute the characters foo_bar, I set
the cursor on the first character where I'd like the subsitution to begin
and type 7s. VIM drops the characters foo_bar and goes to insert mode,
waiting for the substitution text.

Substitute Lines ----------------------- After years of using vi and VIM and
always deleting multiple lines in order to replace them, I just discovered
the S command. If you need to subsitute three lines of text, simply type
3S. VIM drops the three lines and goes into insert mode, waiting for the
subsitution text.

</pre></tip> </html> <Tip category="KVim"> <html><center>letting
variable values be overwritten in a script</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=82">http://vim.sf.net/tip_view.php?tip_id=82</A><BR>

this is a simple function i wrote to get the value of a variable from three
different places (in that order):  the current buffer, the global setting
or from the script itself.

this allows me to set a default value for a configuration variable inside my
script and the user to change it on a global level by setting the same variable
with a g: prepended.  then, they can further set it on a per-buffer level by
the the b: mechanism.  one of the examples for this might be my comments script
(not uploaded).  i have a variable in there that determines whether comment
characters (// for java, for example) are placed the beginning of the line or
just before the first-non-blanks in the text.  i set up a default in my script:

let s:comments_hug_start_of_line=0   " comments should hug the text

that's fine as a default, but if i want to overwrite it for vim scripts,
i just put the following in my ftplugin/vim.vim:

let b:comments_hug_start_of_line=1   " vim comments should hug the first
column, always

" tries  to return  the buffer-specific  value of  a variable;	if not
" found,  tries to  return the	global value  -- if  that's not  found "
either, returns the value set in the script itself function! GetVar(varName)
  if (exists ("b:" . a:varName))
    exe "let retVal=b:" . a:varName
  elseif (exists ("g:" . a:varName))
    exe "let retVal=g:" . a:varName
  elseif (exists ("s:" . a:varName))
    exe "let retVal=s:" . a:varName
  else
    retVal=-1
  endif return retVal
endfunction

personally, i never let it get to the -1 state by always having an s: set
with SOME default value.

</pre></tip> </html> <Tip category="KVim"> <html><center>how
to indent (useful for source code)</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=83">http://vim.sf.net/tip_view.php?tip_id=83</A><BR>

Here is the most useful vim command that I know of and I'm surprised that
it's not yet in the tips list.

I use the indent features of vim all the time. Basically, it lets you indent
your source code.

SETUP: To make indentation work nicely I have the following in my .vimrc file:
set et set sw=4 set smarttab

these make vim behave nicely when indenting, giving 4 spaces (not tabs)
for each "tabstop".

HOW TO USE: in command mode, == will indent the current line selecting a range
of lines (with shift-v) then == will indent your selection typing a number
then == will indent that many lines, starting from your cursor (you get the
idea, there are many other things you can do to select a range of lines)

Tell me that isn't great?

</pre></tip> </html> <Tip category="KVim"> <html><center>Changing
the behaviour of . to include visual mode</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=84">http://vim.sf.net/tip_view.php?tip_id=84</A><BR>

one of the things i do a lot in vim is to make a change to the beginning or
end of	the line (such as adding  the text '// remove' at  the end of java
debug code).  a quick way of doing  this is to use a  to append the text to
the end of the first line  and then move down one, hit . (repeat last edit),
move down, hit .  etc. etc. the following mapping allows one to  simply
highlight the  region  in  question and  hit  .  -- it	will automatically
execute the . once on each line:

  " allow the . to execute once for each line of a visual selection vnoremap
  . :normal .&lt;CR&gt;

another thing i do a lot is to	record a quick macro in the "a" register
and then play it back a number of  times. while @@ can be used to repeat the
last register used, my recorded macros sometimes use other registers so @@
doesn't necessarily  give me the same results as  @a. also, i have mapped '
to `  because i like to go to the precise  location of my marks -- always --
and never to the  beginning of the line. this  leaves my ` key unused. so:

  " make ` execute the contents of the a register nnoremap ` @a

then, in keeping with the visual . above, i did the same for the ` -- is
thexecutes @a once on each highlighed line.

  vnoremap ` :normal @a&lt;CR&gt;

as an example, say i have the following lines of java code:

      public String m_asdf; public String m_lkhj; public int m_hjkhjkh;

and, for some reason, i need to get the following:

      "asdf" "lkhj" "hjkhjkh"

i record the following into a:

  ^cf_"&lt;ESC&gt;$r"

the ^  is because my  java code is  indented and i  don't want to  go to
column 0 and the &lt;esc&gt; is an actual escape i hit to exit insert mode.

then, i  simply select (visually) the  other lines (only two  in case --
admittedly not an overly useful example) and just hit `.

</pre></tip> </html> <Tip category="KVim"> <html><center>How to mimic
the vim 6.0 plugin feature with older versions</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=85">http://vim.sf.net/tip_view.php?tip_id=85</A><BR>

If you do not have vim 6.0, but would like to mimic the plugins directory
feature then copy and paste this into your vimrc:

exec "source " . substitute(glob($VIM."/plugins/*.vim"), "\n", "\nsource ",
"g")

It will automatically source every vim script file located in the vim/plugins
directory.  Now, to add a new plugin, just drop the script in this directory
and vim will automatically find it.

</pre></tip> </html> <Tip category="KVim"> <html><center>Helps
undo 1 line when entered many</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=86">http://vim.sf.net/tip_view.php?tip_id=86</A><BR>

When U entered text, U cannot undo only 1 line, for example, when U press
"u", all entered in last "insert" text removed.

If U add this line to .vimrc: inoremap &lt;Return&gt; &lt;Return&gt;^O^[
where "^O" or "^[" is 1 char "u" will undo (remove) only 1 line.

</pre></tip> </html> <Tip category="KVim"> <html><center>Get
vim 5.x window in vim 6.x</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=87">http://vim.sf.net/tip_view.php?tip_id=87</A><BR>

The format of the window title in vim 5.x (well, at least for 5.7,.8, for
Win32) used to be VIM - &lt;full filename with path&gt;.  It's not in the
win32 binary of 6.0an that I found.  I want my old way back.

Turns out, all that it takes to get it back is :set title titlestring=VIM\
-\ %F "make sure that the window caption setting is turned on and set caption
to vim 5.x style

Oh, however, one thing I did like about the 6.0 style is that it puts the
word "help" in the title when the current buffer is a help file; so, I just
tacked %h to my titlestring giving:

:set title titlestring=VIM\ -\ %F\ %h "make sure that the window caption
setting is turned on and set caption to vim 5.x style

see also: :he 'titlestring' :he 'statusline'	"for the format for titlestring

</pre></tip> </html> <Tip category="KVim"> <html><center>How
to maximize vim on entry (win32)</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=88">http://vim.sf.net/tip_view.php?tip_id=88</A><BR>

Maybe it's just because I have far too small of a monitor, because I can
get distracted while coding if I have other stuff on the screen, or because I
starting using vim on a console, but I definitely like my vim window maximized.
Anyway, sticking the following in your vimrc will always maximize your vim
window on startup.

au GUIEnter * simalt ~x

:he win16-maximized

</pre></tip> </html> <Tip category="KVim"> <html><center>Get more
screen real estate by hidding toolbar and/or menus</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=89">http://vim.sf.net/tip_view.php?tip_id=89</A><BR>

I use gvim over console vim because gvim is much more readable (under Windows).
However, that doesn't mean I want to dedicate screen space to things I'll
never use (i.e. the toolbar and the menus).

Anyway, you can give the following a try if you'd like.

set guioptions-=T "get rid of toolbar set guioptions-=m "get rid of menu

Oh, yeah.  If you decide that you don't really like being without your the
toolbar or menus, issue the following:

set guioptions+=T "bring back toolbar set guioptions+=m "bring back menu

see also: :he 'guioptions

</pre></tip> </html> <Tip category="KVim">
<html><center>Encryption</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=90">http://vim.sf.net/tip_view.php?tip_id=90</A><BR>

You can encrypt your texts by using vim.  :X  prompts for an encryption key.
After writing your key, if you save your document it will be encrypted
and no one else (but you and vim) can read your documents.  If you reopen
the file, VIM will ask for the key.  If you want to disable encryption,
just type :set key= if you forget your key you will lose your document.
So please DO NOT forget your key,


</pre></tip> </html> <Tip category="KVim">
<html><center>Dictionary completions</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=91">http://vim.sf.net/tip_view.php?tip_id=91</A><BR>

This tip will will explain how to use the dictionary completion facilities
provided by vim.  This can be useful if you use vim to type your email,
edit code, etc.

Dictionary completion is one of many search facilites provided by Insert mode
completion.  It allows the user to get a list of keywords, based off of the
current word at the cursor.  This is useful if you are typing a long word
(e.g. acknowledgeable) and don't want to finish typing or don't remember
the spelling.

To start, we must first tell vim where our dictionary is located.  This is done
via the 'dictionary'  option.  Below is an example.  Your location may vary.
See :help 'dictionary'	for hints as to where you should look.

	:set dictionary-=/usr/share/dict/words
	dictionary+=/usr/share/dict/words

Now, to use this list we have to enter insert mode completion.	This is done
by hitting CTRL-X while in insert mode.  Next, you have to specify what you
want to complete.  For dictionaries use CTRL-K.  Once in this mode the keys
CTRL-N and CTRL-P will cycle through the matches.  So, to complete the word
"acknowledgeable" I would do the following in insert mode:

	acknow&lt;CTRL-X&gt;&lt;CTRL-K&gt;&lt;CTRL-N&gt;

It can be cumbersome to type CTRL-X CTRL-K for many different completions.
So, vim gives us a shortcut.  While in insert mode CTRL-N and CTRL-P
will cycle through a predetermined set of completion sources.  By default,
dictionary completion is not a part of this set.  This set is defined by the
'complete' option.  Therefore, we must add dictionary to this as shown below:

	:set complete-=k complete+=k

Now, while in insert mode we can type the following to complete our example:

	acknow&lt;CTRL-N&gt;&lt;CTRL-N&gt;

This shortcut may not save a whole lot of typing.  However, I find that it
requires less hand movement to only worry myself with two key combinations,
rather than 4.

I find that the completion facilites provided by vim save me a *HUGE* amount
of typing.  These savings can be realized in only a short amount of time if
you are editing some code with functions and variables that have long names
with underscores in them.

For more help:
	help ins-completion help compl-dictionary help 'complete' help
	'dictionary' help :set+=

</pre></tip> </html> <Tip category="KVim">
<html><center>Reducing 'doc' directory size</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=92">http://vim.sf.net/tip_view.php?tip_id=92</A><BR>

As everyone knows, the $VIMRUNTIME/doc is increasing rapidly in size. The
directory contained so many plain-text documents that I often compress
them to save my diskspace. With the support of VIM's GZIP plugin,
VIM will automatically uncompress the files when we need to read them.
Here is my procedure: 1.  If you have the source, go to 'runtime/doc'
and edit 'doctags.c', change	   printf("%s\t%s\t/*", p1, argv[0]);  to
printf("%s\t%s.gz\t/*", p1, argv[0]);
     then make. This is to modify the tag, or you'll have to change the
     'tags' file by hand if you don't have doctags.c.
2. Edit the new generated 'tags' file to rename 'help.txt.gz' back to
'help.txt' because it's hard-written in VIM executable binary.
     :% s/help\.txt\.gz/help\.txt/g
3. Copy the new 'tags' to $VIMRNUTIME/doc and run 'gzip *.txt; gunzip help.txt'

On VIM 6.0an, we can reduce the original size (3302k) to 1326k.  I don't
know if this helps, but if someone likes to compress documents... this can
be reffered :)


</pre></tip> </html> <Tip category="KVim"> <html><center>if you use
'highlight search' feature, map a key to :noh</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=93">http://vim.sf.net/tip_view.php?tip_id=93</A><BR>

It is very convenient to use 'hlsearch' option.  However it can be annoying
to have the highlight stick longer than you want it.  In order to run it
off you have to type at least 4 keystrokes, ":noh".  So, it's a good idea
to map this to a key.  I like to map it to control-n.  This is the line I
use in my .vimrc file to do it:

nmap &lt;silent&gt; &lt;C-N&gt; :silent noh&lt;CR&gt;

</pre></tip> </html> <Tip category="KVim"> <html><center>Questions
& Answers about using tags with Vim</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=94">http://vim.sf.net/tip_view.php?tip_id=94</A><BR>

Using tags file with Vim ------------------------ This document gives you
a idea about the various facilities available in Vim for using a tags file
to browse through program source files.  You can read the Vim online help,
which explains in detail the tags support, using :help tagsearch.txt.  You can
also use the help keywords mentioned in this document to read more about a
particular command or option.  To read more about a particular command or
option use, :help &lt;helpkeyword&gt; in Vim.

1. How do I create a tags file?

   You can create a tags file either using the ctags utility or using a
   custom script or utility.

   Help keyword(s): tag

2. Where can I download the tools to generate the tags file?

   There are several utilities available to generate the tags file.
   Depending on the programming language, you can use any one of them.

   1. Exuberant ctags generates tags for the following programming
      language files:

      Assembler, AWK, ASP, BETA, Bourne/Korn/Zsh Shell, C, C++, COBOL,
      Eiffel, Fortran, Java, Lisp, Make, Pascal, Perl, PHP, Python, REXX,
      Ruby, S-Lang, Scheme, Tcl, and Vim.

      You can download exuberant ctags from <A
      HREF="http://ctags.sourceforge.net/">http://ctags.sourceforge.net/</A><BR>

   2. On Unix, you can use the /usr/bin/ctags utility.	This utility
      is present in most of the Unix installations.

   3. You can use jtags for generating tags file for java programs.
      You can download jtags from: <A
      HREF="http://www.fleiner.com/jtags/">http://www.fleiner.com/jtags/</A><BR>

   4. You can use ptags for generating tags file for perl programs.
      You can download ptags from: <A
      HREF="http://www.eleves.ens.fr:8080/home/nthiery/Tags/">http://www.eleves.ens.fr:8080/home/nthiery/Tags/</A><BR>

   5. You can download scripts from the following links for
      generating tags file for verilog files:

	    <A
	    HREF="http://www.probo.com/vtags.htm">http://www.probo.com/vtags.htm</A><BR>
	    <A
	    HREF="http://www.cs.albany.edu/~mosh/Perl/veri-tags">http://www.cs.albany.edu/~mosh/Perl/veri-tags</A><BR>
	    <A
	    HREF="http://www.verilog.net/vrtags.txt">http://www.verilog.net/vrtags.txt</A><BR>

   6. You can download Hdrtag from the following linke:

	    <A
	    HREF="http://www.erols.com/astronaut/vim/index.html#Tags">http://www.erols.com/astronaut/vim/index.html#Tags</A><BR>

      This utility generates tags file for the following programming languages:
      assembly, c/c++, header files, lex, yacc,LaTeX, vim, and Maple V.

   7. You can also use the following scripts which are part of the Vim
      runtime files:

	  pltags.pl - Create tags file for perl code tcltags - Create tags
	  file for TCL code shtags.pl - Create tags file for shell script

   Help keyword(s): ctags

3. How do I generate a tags file using ctags?

   You can generate a tags file for all the C files in the current directory
   using the following command:

	$ ctags *.c

   You can generate tags file for all the files in the current directory
   and all the sub-directories using (this applies only to exuberant ctags):

	$ ctags -R .

   You can generate tags file for all the files listed in a text file named
   flist using (this applies only to exuberant ctags)

       $ ctags -L flist

4. How do I configure Vim to locate a tags file?

   You can set the 'tags' option in Vim to specify a particular tags file.

	set tags=/my/dir/tags

   Help keyword(s): 'tags', tags-option

5. How do I configure Vim to use multiple tags files?

   The 'tags' option can specify more than one tags file.  The tag filenames
   are separated using either comma or spaces.

	set tags=/my/dir1/tags, /my/dir2/tags

6. How do I configure Vim to locate a tags file in a directory tree?

   Note that the following will work only in Vim 6.0 and above.  You can set
   the 'tags' option to make Vim search for the tags file in a directory tree.
   For example, if the 'tags' option is set like this:

	set tags=tags;/

   Vim will search for the file named 'tags', starting with the current
   directory and then going to the parent directory and then recursively to
   the directory one level above, till it either locates the 'tags' file or
   reaches the root '/' directory.

   Help keyword(s): file-searching

7. How do I jump to a tag?

   There are several ways to jump to a tag location.
	1. You can use the 'tag' ex command.  For example,

	       :tag &lt;tagname&gt;

	   will jump to the tag named &lt;tagname&gt;.
	2. You can position the cursor over a tag name and then press
	   Ctrl-].
	3. You can visually select a text and then press Ctrl-] to
	   jump to the tag matching the selected text.
	4. You can click on the tag name using the left mouse button,
	   while pressing the &lt;Ctrl&gt; key.
	5. You can press the g key and then click on the tag name
	   using the left mouse button.
	6. You can use the 'stag' ex command, to open the tag in a new
	   window.  For example,

		:stag func1

	   will open the func1 definition in a new window.
	7. You can position the cursor over a tag name and then press
	   Ctrl-W ].  This will open the tag location in a new window.

   Help keyword(s): :tag, Ctrl-], v_CTRL_], &lt;C-LeftMouse&gt;,
		    g&lt;LeftMouse&gt;, :stag, Ctrl-W_]

8. How do I come back from a tag jump?

   There are several ways to come back to the old location from a tag jump.
	1. You can use the 'pop' ex command.  2. You can press Ctrl-t.
	3. You can click the right mouse button, while pressing the
	   &lt;Ctrl&gt; key.
	4. You can press the g key and then click the right mouse
	   button.

   Help keyword(s): :pop, Ctrl-T, &lt;C-RightMouse&gt;, g&lt;RightMouse&gt;

9. How do I jump again to a previously jumped tag location?

   You can use the 'tag' ex command to jump to a previously jumped tag
   location, which is stored in the tag stack.

   Help keyword(s): tag

10. How do I list the contents of the tag stack?

   Vim remembers the location from which you jumped to a tag in the tag stack.
   You can list the current tag stack using the 'tags' ex command.

   Help keyword(s): :tags, tagstack

11. How do I jump to a particular tag match, if there are multiple
    matching tags?

    In some situations, there can be more than one match for a tag.
    For example, a C function or definition may be present in more than one
    file in a source tree.  There are several ways to jump to a specific
    tag from a list of matching tags.

	1. You can use the 'tselect' ex command to list all the tag
	   matches.  For example,

		:tselect func1

	  will list all the locations where func1 is defined.  You can then
	  enter the number of a tag match to jump to that location.
	2. You can position the cursor over the tag name and press g]
	   to get a list of matching tags.
	3. You can visually select a text and press g] to get a list
	   of matching tags.
	4. You can use the 'stselect' ex command.  This will open the
	   selected tag from the tag list in a new window.
	5. You can position the cursor over the tag name and press
	   Ctrl-W g] to do a :stselect.

    Help keyword(s): tag-matchlist, :tselect, g], v_g], :stselect,
		     Ctrl-W_g]

12. I want to jump to a tag, if there is only one matching tag,
    otherwise a list of matching tags should be displayed.  How do I do this?

    There are several ways to make Vim to jump to a tag directly, if there
    is only one tag match, otherwise present a list of tag matches.

	1. You can use the 'tjump' ex command.	For example,

		:tjump func1

	   will jump to the definition func1, if it is defined only once.
	   If func1 is defined multiple times, a list of matching tags will
	   be presented.
	2. You can position the cursor over the tag and press g
	   Ctrl-].
	3. You can visually select a text and press g Ctrl-] to jump
	   or list the matching tags.
	4. You can use the 'stjump' ex command.  This will open the
	   matching or selected tag from the tag list in a new window.
	5. You can press Ctrl-W g Ctrl-] to do a :stjump.

    Help keyword(s): :tjump, g_Ctrl-], v_g_CTRL-], :stjump,
		     Ctrl-W_g_Ctrl-]

13. How do browse through a list of multiple tag matches?

    If there are multiple tag matches, you can browse through all of them
    using several of the Vim ex commands.

    1. To go to the first tag in the list, use the 'tfirst' or
       'trewind' ex command.
    2. To go to the last tag in the list, use the 'tlast' ex command.
    3. To go to the next matching tag in the list, use the 'tnext' ex
       command.
    4. To go to the previous matching tag in the list, use the
       'tprevious' or 'tNext' ex command.

    Help keyword(s): :tfirst, :trewind, :tlast, :tnext, :tprevious,
		     :tNext

14. How do I preview a tag?

    You can use the preview window to preview a tag, without leaving the
    original window.  There are several ways to preview a tag:

	1. You can use the 'ptag' ex command to open a tag in the
	   preview window.
	2. You can position the cursor on a tag name and press Ctrl-W
	   } to open the tag in the preview window.
	3. You can use the 'ptselect' ex command to do the equivalent
	   of the 'tselect' ex command in the preview window.
	4. You can use the 'ptjump' ex command to do the equivalent of
	   the 'tjump' ex command in the preview window.
	5. You can position the cursor on the tag and press Ctrl-W g}
	   to do a :ptjump on the tag.

    Help keyword(s): :preview-window, :ptag, Ctrl-W_}, :ptselect,
		     :ptjump, Ctrl-W_g}

15. How do I browse through the tag list in a preview window?

    If there are multiple tag matches, you can browse through all of them
    in the preview window using several of the Vim ex commands.

    1. To go to the first tag in the list, use the 'ptfirst' or
       'ptrewind' ex command.
    2. To go to the last tag in the list, use the 'ptlast' ex command.
    3. To go to the next matching tag in the list, use the 'ptnext' ex
       command.
    4. To go to the previous matching tag in the list, use the
       'ptprevious' or 'ptNext' ex command.

    Help keyword(s): :ptfirst, :ptrewind, :ptlast, :ptnext,
		     :ptprevious, :ptNext

16. How do I start Vim to start editing a file at a given tag match?

    While starting Vim, you can use the command line option '-t' to supply
    a tag name.  Vim will directly jump to the supplied tag location.

    Help keyword(s): -t

17. How do I list all the tags matching a search pattern?

    There are several ways to go through a list of all tags matching a pattern.

	1. You can list all the tags matching a particular regular
	   expression pattern by prepending the tag name with the '/'
	   search character.  For example,

		:tag /&lt;pattern&gt; :stag /&lt;pattern&gt; :ptag
		/&lt;pattern&gt; :tselect /&lt;pattern&gt; :tjump
		/&lt;pattern&gt; :ptselect /&lt;pattern&gt; :ptjump
		/&lt;pattern&gt;

	 2. If you have the 'wildmenu' option set, then you can press
	    the &lt;Tab&gt; key to display a list of all the matching tags
	    in the status bar.	You can use the arrow keys to move between
	    the tags and then use the &lt;Enter&gt; key to select a tag.

	 3. If you don't have the 'wildmenu' option set, you can still
	    use the &lt;Tab&gt; key to browse through the list of matching
	    tags.

    Help keyword(s): tag-regexp, wildmenu

18. What options are available to control how Vim handles the tags
    file?

    You can use the following options to control the handling of tags file
    by Vim:

    1. 'tagrelative' - Controls how the file names in the tags file
		       are treated.  When on, the filenames are relative to
		       the directory where the tags file is present.

    2. 'taglength' -  Controls the number of significant characters
		      used for recognizing a tag.

    3. 'tagbsearch' - Controls the method used to search the tags file
		      for a tag.  If this option is on, binary search is
		      used to search the tags file.  Otherwise, linear search
		      is used.

    4. 'tagstack' - Controls how the tag stack is used.

    Help keyword(s): 'tagrelative', 'taglength', 'tagbsearch',
		     'tagstack'

19. Is it possible to highlight all the tags in the current file?

    Yes.  Read the Vim online help on "tag-highlight".

20. Is it possible to create a menu with all the tags in the current
    file?

    Yes.  It is possible to create a menu with all the tags in the current
    file using a Vim script.  Download the TagsMenu.vim script from the
    following link:

    <A
    HREF="http://members.home.net/jayglanville/tagsmenu/TagsMenu.html">http://members.home.net/jayglanville/tagsmenu/TagsMenu.html</A><BR>

21. Is there a workaround to make the Ctrl-] key not to be treated as
    the telnet escape character?

    The default escape characters for telnet in Unix systems is Ctrl-].
    While using Vim in a telnet session, if you use Ctrl-] to jump to a tag,
    you will get the telnet prompt.  There are two ways to avoid this problem:

    1. Map the telnet escape character to some other character using
       the "-e &lt;escape character&gt;" telnet command line option

    2. Disable the telnet escape character using the "-E" telnet
       command line option.

    Help keyword(s): telnet-CTRL-]

</pre></tip> </html> <Tip category="KVim"> <html><center>How do I pipe
the output from ex commands into the text buffer?</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=95">http://vim.sf.net/tip_view.php?tip_id=95</A><BR>

This is a *request* for a tip.	I need to be able to pipe the output of a
:blah ex command into the vim text buffer for editing.	I wanted to do this
many times for different reasons and could never find a way!

I would just love to be able to do :hi --&gt; textBuffer and examine the output
at my own leasure scrolling up and down and using vim search commands on it.
Same thing for :set all, and other things.  Considering that cut and paste
is horrible in windows, I can't for example do :set guioptions? then cut
and paste!  So I have to retype it, or cut and paste from the help manual.
I really want to be able to pipe the output of ex commands into the text
buffer.  Can someone help me?

</pre></tip> </html> <Tip category="KVim"> <html><center>Cooperation
of Gvim and AutoCad [MTEXT]</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=96">http://vim.sf.net/tip_view.php?tip_id=96</A><BR>

You can - like me :o)  - use gvim, like replacement of internal AutoCad
MTEXT editor. You need switch variable MTEXTED to "gvim" (or maybe fullpath,
something like "c:\vim\vim60aq\gvim" ), and to your _vimrc you can put line:

autocmd BufRead,BufNewFile *.tmp source c:\vim\aacad.vim

And when you edit MTEXT in acad, menu AutoCad will be for your use in gvim
(only in INSERT and VISUAL mode)

[NOTE: Only I can't start gvim like gvim -y (for any other person, not so
accustomed vith gvim) or start gvim from gvim.lnk or gvim.bat (I'am using
windows95) and automatic skip to INSERT mode -latest word star, on end of
script- is without functionality(?) Maybe someone advise me?? ]

Well, script aacad.vim is listed here:

"VIM menu for AutoCad's MTEXT editation "brz;
mailto:brz@centrum.cz;	8. 8. 2001 " Version Mk.I
"--------------------------------------------------------------------------

imenu &AutoCad.Insert.Space \~ vmenu &AutoCad.Insert.Space
&lt;Esc&gt;`&lt;i\~&lt;Esc&gt;% imenu &AutoCad.Insert.Backslash \\
vmenu &AutoCad.Insert.Backslash &lt;Esc&gt;`&lt;i\\&lt;Esc&gt;% imenu
&AutoCad.Insert.Brackets \{\}&lt;Esc&gt;F\i vmenu &AutoCad.Insert.Brackets
&lt;Esc&gt;`&gt;a\}&lt;Esc&gt;`&lt;i\{&lt;Esc&gt;% imenu
&AutoCad.Insert.Paragraph \P vmenu &AutoCad.Insert.Paragraph
&lt;Esc&gt;`&gt;a\P&lt;Esc&gt;%

imenu &AutoCad.-SEP1- :

imenu &AutoCad.Colour.Red \C1; vmenu &AutoCad.Colour.Red
&lt;Esc&gt;`&gt;a\C7;&lt;Esc&gt;`&lt;i\C1;&lt;Esc&gt;% imenu
&AutoCad.Colour.Yellow \C2; vmenu &AutoCad.Colour.Yellow
&lt;Esc&gt;`&gt;a\C7;&lt;Esc&gt;`&lt;i\C2;&lt;Esc&gt;% imenu
&AutoCad.Colour.Green \C3; vmenu &AutoCad.Colour.Green
&lt;Esc&gt;`&gt;a\C7;&lt;Esc&gt;`&lt;i\C3;&lt;Esc&gt;%
imenu &AutoCad.Colour.Cyan \C4; vmenu &AutoCad.Colour.Cyan
&lt;Esc&gt;`&gt;a\C7;&lt;Esc&gt;`&lt;i\C4;&lt;Esc&gt;%
imenu &AutoCad.Colour.Blue \C5; vmenu &AutoCad.Colour.Blue
&lt;Esc&gt;`&gt;a\C7;&lt;Esc&gt;`&lt;i\C5;&lt;Esc&gt;% imenu
&AutoCad.Colour.Violet \C6; vmenu &AutoCad.Colour.Violet
&lt;Esc&gt;`&gt;a\C7;&lt;Esc&gt;`&lt;i\C6;&lt;Esc&gt;%
imenu &AutoCad.Colour.Black \C7; vmenu &AutoCad.Colour.Black
&lt;Esc&gt;`&gt;a\C7;&lt;Esc&gt;`&lt;i\C7;&lt;Esc&gt;% imenu
&AutoCad.Colour.D_Grey \C8; vmenu &AutoCad.Colour.D_Grey
&lt;Esc&gt;`&gt;a\C7;&lt;Esc&gt;`&lt;i\C8;&lt;Esc&gt;% imenu
&AutoCad.Colour.L_Grey \C9; vmenu &AutoCad.Colour.L_Grey
&lt;Esc&gt;`&gt;a\C7;&lt;Esc&gt;`&lt;i\C9;&lt;Esc&gt;%

imenu &AutoCad.Font.Arial \fArial; vmenu &AutoCad.Font.Arial
&lt;Esc&gt;`&lt;i\fArial;&lt;Esc&gt;% imenu &AutoCad.Font.Symbol \Fsymbol;
vmenu &AutoCad.Font.Symbol &lt;Esc&gt;`&lt;i\Fsymbol;&lt;Esc&gt;%
imenu &AutoCad.Font.RomanC \Fromanc; imenu &AutoCad.Font.RomanC
&lt;Esc&gt;`&lt;i\Fromanc;&lt;Esc&gt;% imenu &AutoCad.Font.RomanS \Fromans;
vmenu &AutoCad.Font.RomanS &lt;Esc&gt;`&lt;i\Fromans;&lt;Esc&gt;%
imenu &AutoCad.Font.RomanD \Fromand; vmenu &AutoCad.Font.RomanD
&lt;Esc&gt;`&lt;i\Fromand;&lt;Esc&gt;% imenu &AutoCad.Font.RomanT \Fromant;
vmenu &AutoCad.Font.RomanT &lt;Esc&gt;`&lt;i\Fromant;&lt;Esc&gt;%

imenu &AutoCad.Size.0_5x \H0.5x; vmenu &AutoCad.Size.0_5x
&lt;Esc&gt;`&lt;i\H0.5x;&lt;Esc&gt;% imenu &AutoCad.Size.1_5x \H1.5x; vmenu
&AutoCad.Size.1_5x &lt;Esc&gt;`&lt;i\H1.5x;&lt;Esc&gt;% imenu &AutoCad.Size.2x
\H2x; vmenu &AutoCad.Size.2x &lt;Esc&gt;`&lt;i\H2x;&lt;Esc&gt;%
imenu &AutoCad.Size.3x \H3x; vmenu &AutoCad.Size.3x
&lt;Esc&gt;`&lt;i\H3x;&lt;Esc&gt;%

imenu &AutoCad.Effects.Set_Out_1_5 \T1.5; vmenu &AutoCad.Effects.Set_Out_1_5
&lt;Esc&gt;`&gt;a\T1;&lt;Esc&gt;`&lt;i\T1.5;&lt;Esc&gt;% imenu
&AutoCad.Effects.Set_Out_2 \T2; vmenu &AutoCad.Effects.Set_Out_2
&lt;Esc&gt;`&gt;a\T1;&lt;Esc&gt;`&lt;i\T2;&lt;Esc&gt;%

imenu &AutoCad.Effects.-SEP3- : imenu
&AutoCad.Effects.Tilt_15deg \Q15; vmenu &AutoCad.Effects.Tilt_15deg
&lt;Esc&gt;`&gt;a\Q0;&lt;Esc&gt;`&lt;i\Q10;&lt;Esc&gt;% imenu
&AutoCad.Effects.Tilt_20deg \Q20; vmenu &AutoCad.Effects.Tilt_20deg
&lt;Esc&gt;`&gt;a\Q0;&lt;Esc&gt;`&lt;i\Q20;&lt;Esc&gt;% imenu
&AutoCad.Effects.Tilt_30deg \Q30; vmenu &AutoCad.Effects.Tilt_30deg
&lt;Esc&gt;`&gt;a\Q0;&lt;Esc&gt;`&lt;i\Q30;&lt;Esc&gt;%

imenu &AutoCad.Effects.-SEP4- : imenu &AutoCad.Effects.Change_Width_0_5x
\W0.5; vmenu &AutoCad.Effects.Change_Width_0_5x
&lt;Esc&gt;`&gt;a\W1;&lt;Esc&gt;`&lt;i\W0.5;&lt;Esc&gt;% imenu
&AutoCad.Effects.Change_Width_2x \W2; vmenu &AutoCad.Effects.Change_Width_2x
&lt;Esc&gt;`&gt;a\W1;&lt;Esc&gt;`&lt;i\W2;&lt;Esc&gt;%

imenu &AutoCad.Effects.-SEP5- : imenu &AutoCad.Effects.Justify_Down \A0;
vmenu &AutoCad.Effects.Justify_Down &lt;Esc&gt;`&lt;i\A0;&lt;Esc&gt;%
imenu &AutoCad.Effects.Justify_Middle \A1; vmenu
&AutoCad.Effects.Justify_Middle &lt;Esc&gt;`&lt;i\A1;&lt;Esc&gt;%
imenu &AutoCad.Effects.Justify_Up \A2; vmenu &AutoCad.Effects.Justify_Up
&lt;Esc&gt;`&lt;i\A2;&lt;Esc&gt;% imenu &AutoCad.Effects.Overlined_Characters
\O\o&lt;Esc&gt;F\i vmenu &AutoCad.Effects.Overlined_Characters
&lt;Esc&gt;`&gt;a\O&lt;Esc&gt;`&lt;i\o&lt;Esc&gt;% imenu
&AutoCad.Effects.Underlined_Characters \L\l&lt;Esc&gt;F\i
vmenu &AutoCad.Effects.Underlined_Characters
&lt;Esc&gt;`&gt;a\l&lt;Esc&gt;`&lt;i\L&lt;Esc&gt;% imenu
&AutoCad.Effects.Index_Top \S^;

imenu &AutoCad.-SEP6- : imenu &AutoCad.Help &lt;CR&gt;&lt;CR&gt;***Quit
Editor: press Alt-F4 and 'No' ***&lt;CR&gt;&lt;CR&gt;

star

</pre></tip> </html> <Tip category="KVim"> <html><center>How
do I add a current time string inside Vim?</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=97">http://vim.sf.net/tip_view.php?tip_id=97</A><BR>

This is a *request* for a tip.	Sometimes (eg. editing HTML pages) I need
to add a timestamp string to my editing buffer.  On UNIX systems, I can use
  :r!date
to get a localized date time string; but on Windows ('date' on Windows will
query the user to input new date) or other platforms which does not have
'date' command, how do I get a timestamp easily?

</pre></tip> </html> <Tip category="KVim"> <html><center>Getting
vim help from mailing lists and newsgroups.</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=98">http://vim.sf.net/tip_view.php?tip_id=98</A><BR>

There have been a few "requests for tips" entered into the tips database
lately.  If you have specific questions that aren't answered by the existing
tips, there are a couple of resources that may be more appropriate:

The mailing list vim@vim.org is for vim users.	If you send an email
to vim-help@vim.org, you'll get a message back telling you how
to subscribe, as well as how to request old messages and contact
the list maintainer.  This mailing list is also archived at <A
HREF="http://groups.yahoo.com/group/vim.">http://groups.yahoo.com/group/vim.</A><BR>

The newsgroup comp.editors discusses many different editors, but most of
the traffic is about vim.  When posting, it is appreciated if you include
"vim" in the subject line.  The comp.editors newsgroup is archived at <A
HREF="http://groups.google.com/groups?hl=en&safe=off&group=comp.editors.">http://groups.google.com/groups?hl=en&safe=off&group=comp.editors.</A><BR>

Using the tips database for asking questions is not likely to work well.
For example, if you ask a question titled "Searching for strings in a file"
and I read this site and see that tip, I'm not going to read it if I already
know how to search for strings in a file.  In comp.editors and vim@vim.org,
people expect to find questions from others and are therefore more likely
to see your questions.

After finding the answer to your question, please consider whether it would
make an appropriate tip, and if so, add it to the tips database.

</pre></tip> </html> <Tip category="KVim"> <html><center>How to
tell what syntax highlighting group *that* is!</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=99">http://vim.sf.net/tip_view.php?tip_id=99</A><BR>

Here's a (what should be a one-line) map to help you tell just what syntax
highlighting groups the item under the cursor actually is:

map  &lt;F10&gt;  :echo "hi&lt;"
. synIDattr(synID(line("."),col("."),1),"name") . '&gt; trans&lt;'
. synIDattr(synID(line("."),col("."),0),"name") . "&gt; lo&lt;"
. synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . "&gt;"&lt;CR&gt;

Once known you can override the current highlighting with whatever you want.
If you're debugging a syntax highlighting file (a rare occupation), sometimes
you'll wish to know the entire chain of syntax highlighting.  For that,
check out

<A
HREF="http://www.erols.com/astronaut/vim/vimscript/hilinks.vim">http://www.erols.com/astronaut/vim/vimscript/hilinks.vim</A><BR>

</pre></tip> </html> <Tip category="KVim"> <html><center>Jump to
tag (e.g. help topic) with German keyboard (PC)</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=100">http://vim.sf.net/tip_view.php?tip_id=100</A><BR>

You're a newbie in vim and need some ":help"? Well, help.txt reads:

"Jump to a subject:  Position the cursor on a tag between |bars| and hit
CTRL-]."

Unfortunately there is no "]" key on German keyboards. On Win32 try CTRL-+
(Strg-+), on Linux console I use CTRL-AltGr-9 (Strg-AltGr-9).

Kind regards

</pre></tip> </html> <Tip category="KVim"> <html><center>Change automatically
to the directory the file in the current buffer is in</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=101">http://vim.sf.net/tip_view.php?tip_id=101</A><BR>

To change automatically to the directory the file in the current buffer is
in add a line (below)  to the file .vimrc .  The file .vimrc should have
the following if-statement to control the autocmd feature:

  if has("autocmd")

    &lt; ... lot of autocmd stuff ... &gt;

    " Change to the directory the file in your current buffer is in autocmd
    BufEnter * :cd %:p:h

  endif " has("autocmd")

Add the line above the endif and restart vim/gvim.

</pre></tip> </html> <Tip category="KVim"> <html><center>smart
mapping for tab completion</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=102">http://vim.sf.net/tip_view.php?tip_id=102</A><BR>

I'm used to complete words with &lt;tab&gt;, however when editing source
I can't just map that to vim keyword completion because I sometime need to
insert real tabs, since it mostly happen when at the beginning of the line or
after a ; and before a one line comma (java, c++ or perl anyone...) I've come
to find the following really usefull This is how you can map the &lt;tab&gt;
key in insert mode while still being able to use it when at the start of
a line or when the preceding char is not a keyword character.  in a script
file in a plugin directory or in your .vimrc file: first define a function
which returns a &lt;tab&gt; or a &lt;C-N&gt; depending on the context:

function InsertTabWrapper()
      let col = col('.') - 1 if !col || getline('.')[col - 1] !~ '\k'
	  return "\&lt;tab&gt;"
      else
	  return "\&lt;c-p&gt;"
      endif
endfunction

then define the appropriate mapping: inoremap &lt;tab&gt;
&lt;c-r&gt;=InsertTabWrapper()&lt;cr&gt;

the trick here is the use of the &lt;c-r&gt;= in insert mode to be able to
call your function without leaving insert mode.  :help i_CTRL-R Benoit

</pre></tip> </html> <Tip category="KVim"> <html><center>Move
to next/previous line with same indentation</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=103">http://vim.sf.net/tip_view.php?tip_id=103</A><BR>

When working with Python and other languages which don't use braces, it's
useful to be able to jump to and from lines which have the same indentation
as the line you are currently on.

nn &lt;M-,&gt; k:call search ("^". matchstr (getline (line (".")+ 1),
'\(\s*\)') ."\\S", 'b')&lt;CR&gt;^ nn &lt;M-.&gt; :call search ("^". matchstr
(getline (line (".")), '\(\s*\)') ."\\S")&lt;CR&gt;^

will map Alt-&lt; and Alt-&gt; in Normal mode to upward and downward searching
for lines with the same indent as the current line.

</pre></tip> </html> <Tip category="KVim"> <html><center>using
vim to complement Perl's DBI::Shell</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=104">http://vim.sf.net/tip_view.php?tip_id=104</A><BR>

DBI::Shell is a Perl module that is used as a shell interface to Perl's
popular DBI (database interface) package. Forget your favorite SQL navigation
gui and give this method a shot. This has only been tested in UNIX.

1. run dbish (runs DBI::Shell; installed with DBI::Shell) and connect to any
database 2. in dbish, set /format box 3. enter your query 4. to execute query,
type "/ | vim -"

This runs the query and pipes the output to the standard input of vim. Here
are some follow-up tips: -use gvim instead of vim so a new window will pop
up -set nowrap once in vim -make a syntax highlighting file for me!

-Adam Monsen

</pre></tip> </html> <Tip category="KVim">
<html><center>combining move and scroll</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=105">http://vim.sf.net/tip_view.php?tip_id=105</A><BR>

I sometimes found myself moving down a few lines with j, then scrolling
down about the same number of lines with &lt;C-E&gt; to put the cursor in
roughly the same place as it started.  I decided I wanted to map &lt;C-J&gt;
(and &lt;C-K&gt;, respectively) to the move-and-scroll operation.  First, I did

    :map &lt;C-J&gt; &lt;C-E&gt;j

This was pretty good, but behaved funny at the beginning and end of files.
Then, I realized that &lt;C-D&gt; already combined move and scroll, so I
figured that giving &lt;C-D&gt; a count of 1 would do it:

    :map &lt;C-J&gt; 1&lt;C-D&gt;

Unfortunately, this permanently attaches a count to &lt;C-D&gt; (ugh!),
so I have to undo that:

    :map &lt;C-J&gt; 1&lt;C-D&gt;:set scroll=0&lt;CR&gt;

This has the drawback of not necessarily resetting scroll to its original
value, but since I never change scroll, it's good enough for me.  It would be
nice if there were a version of &lt;C-D&gt; that did not have the side-affect
of changing scroll.

Happy vimming, Andrew

</pre></tip> </html> <Tip category="KVim">
<html><center>Supersimple one-line solution</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=106">http://vim.sf.net/tip_view.php?tip_id=106</A><BR>

Hallo, next solution for _most_simple_ signature rotater: You can
only put one line to your .vimrc || _vimrc: map &lt;Leader&gt;ms :e
c:\sign.txt&lt;CR&gt;ggV/--&lt;CR&gt;k"*xG$a&lt;C-R&gt;&lt;C-O&gt;*&lt;Esc&gt;:w&lt;CR&gt;:bd&lt;CR&gt;G$a&lt;C-M&gt;&lt;Esc&gt;"*P

Must exist file (from eg above) c:\sign.txt, with content: -- first signature
-- second signature -- third signature --

When You finished mail, only call shortcut \ms and 'first signature' will
be insert in your mail. In c:\sign.txt will be first signature pushed
to the end of this file. When You want use other signature, only press
'u' and \ms again (Or You can change \ms to e.g. &lt;F12&gt;, indeed. )
You can change this and append one part like 'basic' from command and
append 'changing' part from .signature file, as you like...  Ok, one
unpleasant thing is here: your signature must not contain '--' (signature
separator)...  Anyhow, I find it useful brz* &lt;brz@centrum.cz&gt; <A
HREF="http://brz.d2.cz/">http://brz.d2.cz/</A><BR>

</pre></tip> </html> <Tip category="KVim">
<html><center>convert enum to string table</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=107">http://vim.sf.net/tip_view.php?tip_id=107</A><BR>

When testing your own C/C++ programs you sometimes wish to have a trace output,
which shows you, which enum value is used.  You can do this by creating
a string table for that enum type, which contains the enum identifyer as
a string.  e.g.  printf ("%s", MyEnumStringTable [ MyEnumVal] );

You can create the complete string table by - marking the lines containing
the complete typedef enum - select menu C/C++.transform enum2Stringtab

You can create string table entries by - marking the lines within the typedef
enum - select menu C/C++.transform enum2String

This makes it easy to keep the enum (on changes) consistent to the string
table.

Add the following lines to your _GVIMRC file: 31amenu C/C++.transform\
enum2Stringtab	       :s#[    ]*\\(\\w\\+\\)#/* \\1   */
"\\1"#&lt;CR&gt;o};&lt;ESC&gt;uOstatic const char* const Names[] =
{&lt;ESC&gt;&lt;CR&gt;/sdfsdf&lt;CR&gt; 31vmenu C/C++.transform\ enum2Stringtab
:s#[	]*\\(\\w\\+\\)#/* \\1	*/	"\\1"#&lt;CR&gt;o};&lt;ESC&gt;uOstatic
const char* const Names[] = {&lt;ESC&gt;&lt;CR&gt;/sdfsdf&lt;CR&gt;

31amenu C/C++.transform\ enum2String	:s#[	]*\\(\\w\\+\\)#/*
\\1   */      "\\1"#&lt;CR&gt;o}&lt;ESC&gt;/sdfsdf&lt;CR&gt; 31vmenu
C/C++.transform\ enum2String	:s#[	]*\\(\\w\\+\\)#/* \\1	*/
"\\1"#&lt;CR&gt;o}&lt;ESC&gt;/sdfsdf&lt;CR&gt;

hint: '/sdfsdf' is added for deactivating search highlighting, ok, you'll
sure find a better way to do this.

</pre></tip> </html> <Tip category="KVim"> <html><center>Toggle
a fold with a single keystroke</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=108">http://vim.sf.net/tip_view.php?tip_id=108</A><BR>

When viewing/editing a folded file, it is often needed to inspect/close
some fold.  To speed up these operation use the following (put in your
$HOME/.vimrc):

" Toggle fold state between closed and opened.	" " If there is no fold at
current line, just moves forward.  " If it is present, reverse it's state.
fun! ToggleFold()
	if foldlevel('.') == 0
		normal! l
	else
		if foldclosed('.') &lt; 0
			. foldclose
		else
			. foldopen
		endif
	endif " Clear status line echo
endfun

" Map this function to Space key.  noremap &lt;space&gt; :call
ToggleFold()&lt;CR&gt;

See :help folding for more information about folding.

</pre></tip> </html> <Tip category="KVim">
<html><center>jump between files</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=109">http://vim.sf.net/tip_view.php?tip_id=109</A><BR>

Often I know I'm likely to edit many files. I run 'vim *.pl' and get a whole
bunch of open files.

To make jumping between files to a pleasure, I defined to mapss:

map &lt;f1&gt; :previous&lt;cr&gt; map &lt;f2&gt; :next&lt;cr&gt;

Press F1 to go back and F2 to go forward.

-- Kirill

</pre></tip> </html> <Tip category="KVim">
<html><center>text-&gt;html table converter.</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=110">http://vim.sf.net/tip_view.php?tip_id=110</A><BR>

Below are two functions and a mapping which will convert lines of plain
text into HTML table code.  For example, you have several lines like:
----------------------------------------------- 1 2 3

4 5 6 --------------------------------------------------- by visualizing
all the 7 lines and press &lt;F5&gt;, you can change the text into
&lt;table&gt;&lt;tr&gt;
   &lt;td&gt;1&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;
   &lt;td&gt;4&lt;/td&gt; &lt;td&gt;5&lt;/td&gt; &lt;td&gt;6&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt; which will eventually render into a table.  So the
rule is: Every line is a table item, every empty line means starting of a
new table row.

"A text-&gt;html table code converter "By: Wenzhi Liang wzhliang@yahoo.com
"You can distribute/change this file freely as long as you keep the title
area. Thanks

func Table()
	let end=line("'&gt;") let start=line("'&lt;") let i=start

	wh i &lt;= end
		exe ":" . i let e=Empty() if e == 1
			exe "normal I&lt;/tr&gt;&lt;tr&gt;"
		else
			exe "normal I&lt;td&gt;A&lt;/td&gt;&gt;&gt;"
		endif let i=i+1
	endwh

	exe "normal o&lt;/tr&gt;&lt;/table&gt;&lt;&lt;" exe ":" . start exe
	"normal O&lt;table&gt;&lt;tr&gt;&lt;&lt;"
endfunc

vmap &lt;F5&gt; &lt;ESC&gt;:call Table()&lt;CR&gt;

func Empty()
	let line_nr= line (".")  let a=getline ( line_nr ) let m=match(a,
	"\\S") if m == -1
		return 1
	else
		return 0
	endif
endfunc

</pre></tip> </html> <Tip category="KVim"> <html><center>Printing with
syntax highlighting independent of your normal highlighting</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=111">http://vim.sf.net/tip_view.php?tip_id=111</A><BR>

I have found it undesirable to use :hardcopy directly because it uses the
current syntax highlighting to determine how to print the text.  For example,
I like to print comments in italics, but I don't like italic fonts on the
screen. This tip will show you how to set up a colorscheme for printing and
use it only when you print.

I copied an existing colorscheme to ~/.vim/colors/print.vim, and changed
all the lines like this:

  highlight Normal ctermbg=DarkGrey ctermfg=White guifg=White guibg=grey20
to this:
  highlight clear Normal

Then I set the syntax groups how I wanted them to be printed on the printer:

  highlight Comment	   term=italic	  cterm=italic	  gui=italic highlight
  Constant	 term=bold	cterm=bold	gui=bold etc....

I then defined the following command in my .vimrc file:

command! -nargs=* Hardcopy call DoMyPrint("&lt;args&gt;")

And, finally, I defined this function in my .vimrc:

function DoMyPrint(args)
    let colorsave=g:colors_name color print exec "hardcopy ".a:args exec
    'color '.colorsave
endfunction

After this is complete, you can do:
   :Hardcopy &gt; /tmp/out.ps
or just
   :Hardcopy
(Note the capital H)

</pre></tip> </html> <Tip category="KVim"> <html><center>Back
and forth between indented lines again</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=112">http://vim.sf.net/tip_view.php?tip_id=112</A><BR>

Paul Wright posted a tip which explained how to jump back and forth between
lines with the same indentation level. I do this a lot, so I came up with
this slightly more comprehensive solution.

The example mappings below work as follows:

[l and ]l jump to the previous or the next line with the same indentation
level as the one you're currently on.

[L and ]L jump to the previous or the next line with an indentation level
lower than the line you're currently on.

These movements also work in visual mode and (only as of one of the 6.0 alpha
versions) in operator pending mode, meaning that you can do a d]l. The motion
is specified as being exclusive when in operator pending mode.

When might you use this? If you're writing programs in Python, Haskell,
or editing XML files, they will be very useful. E.g. in XML you can jump to
the outer enclosing tag, or the next matching tag. I use it for practically
anything I edit, so it's not limited to this.

" " NextIndent() " " Jump to the next or previous line that has the same level
or a lower " level of indentation than the current line.  " " exclusive (bool):
true:  Motion is exclusive "			 false: Motion is inclusive "
fwd (bool):	    true:  Go to next line "			 false: Go to
previous line " lowerlevel (bool):  true:  Go to line with lower indentation
level "			    false: Go to line with the same indentation level
" skipblanks (bool):  true:  Skip blank lines "			    false:
Don't skip blank lines

function! NextIndent(exclusive, fwd, lowerlevel, skipblanks)
	let line = line('.')  let column = col('.')  let lastline = line('$')
	let indent = indent(line) let stepvalue = a:fwd ? 1 : -1

	while (line &gt; 0 && line &lt;= lastline)
		let line = line + stepvalue if (    ! a:lowerlevel &&
		indent(line) == indent ||
				\ a:lowerlevel && indent(line) &lt; indent)
			if (! a:skipblanks || strlen(getline(line)) &gt; 0)
				if (a:exclusive)
					let line = line - stepvalue
				endif exe line exe "normal " column . "|"
				return
			endif
		endif
	endwhile
endfunc

" Moving back and forth between lines of same or lower indentation.
nnoremap &lt;silent&gt; [l :call NextIndent(0, 0, 0, 1)&lt;cr&gt;
nnoremap &lt;silent&gt; ]l :call NextIndent(0, 1, 0, 1)&lt;cr&gt;
nnoremap &lt;silent&gt; [L :call NextIndent(0, 0, 1, 1)&lt;cr&gt;
nnoremap &lt;silent&gt; ]L :call NextIndent(0, 1, 1, 1)&lt;cr&gt; vnoremap
&lt;silent&gt; [l &lt;esc&gt;:call NextIndent(0, 0, 0, 1)&lt;cr&gt;m'gv''
vnoremap &lt;silent&gt; ]l &lt;esc&gt;:call NextIndent(0, 1, 0,
1)&lt;cr&gt;m'gv'' vnoremap &lt;silent&gt; [L &lt;esc&gt;:call NextIndent(0, 0,
1, 1)&lt;cr&gt;m'gv'' vnoremap &lt;silent&gt; ]L &lt;esc&gt;:call NextIndent(0,
1, 1, 1)&lt;cr&gt;m'gv'' onoremap &lt;silent&gt; [l :call NextIndent(0, 0, 0,
1)&lt;cr&gt; onoremap &lt;silent&gt; ]l :call NextIndent(0, 1, 0, 1)&lt;cr&gt;
onoremap &lt;silent&gt; [L :call NextIndent(1, 0, 1, 1)&lt;cr&gt; onoremap
&lt;silent&gt; ]L :call NextIndent(1, 1, 1, 1)&lt;cr&gt;

</pre></tip> </html> <Tip category="KVim"> <html><center>Translator
in vim (Windows solution)</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=113">http://vim.sf.net/tip_view.php?tip_id=113</A><BR>

Hallo, today I found script "translate.vim", but on Windows this will be
probably difficult to run it (maybe with Cygwin is it possible). I've simpler
solution of keymap for vim interlacing to dictionary: Must exist file with
vocabulary (e.g. "an-cs.txt"), which is called for word under cursor. In
'normal' is only displayed window with translations, in 'insert' is word
under cursor deleted and is insert selected form of word from translantion
window (select it by mouse and than press right button: It works fine on
W2k). Key _F12_ is looking for "word", shifted _S-F12_ is looking for
"pattern".  For windows is needed agrep, which is localy placed on <A
HREF="http://www.tgries.de/agrep/index.html">http://www.tgries.de/agrep/index.html</A><BR>

map &lt;F12&gt; b"*yw&lt;Esc&gt;:! c:/bin/agrep -wih
&lt;C-R&gt;* "c:/dict/an-cs.txt"&lt;CR&gt; imap &lt;F12&gt;
&lt;Esc&gt;b"*yw&lt;Esc&gt;:! c:/bin/agrep -wih &lt;C-R&gt;*
"c:/dict/an-cs.txt"&lt;CR&gt;dwi &lt;C-R&gt;* map &lt;S-F12&gt;
b"*yw&lt;Esc&gt;:! c:/bin/agrep -ih &lt;C-R&gt;* "c:/dict/an-cs.txt"&lt;CR&gt;
imap &lt;S-F12&gt; &lt;Esc&gt;b"*yw&lt;Esc&gt;:! c:/bin/agrep -ih &lt;C-R&gt;*
"c:/dict/an-cs.txt"&lt;CR&gt;dwi &lt;C-R&gt;*

brz* &lt;brz@centrum.cz&gt;

</pre></tip> </html> <Tip category="KVim">
<html><center>Browsing by  paragraph</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=114">http://vim.sf.net/tip_view.php?tip_id=114</A><BR>

It can be done by reaching the blank lines in up and down directions just
by pressing

{    ----  For going to the blank line above the paragraph }	----  For
going to the blank line below the paragraph

</pre></tip> </html> <Tip category="KVim">
<html><center>Browsing by  paragraph</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=115">http://vim.sf.net/tip_view.php?tip_id=115</A><BR>

It can be done by reaching the blank lines in up and down directions just
by pressing

{    ----  For going to the blank line above the paragraph }	----  For
going to the blank line below the paragraph

</pre></tip> </html> <Tip category="KVim"> <html><center>Search all
occurances of the word under cursor in all the open files</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=116">http://vim.sf.net/tip_view.php?tip_id=116</A><BR>

Sometimes it is useful to know all the occurances of the word under cursor in
all the open files. This can be done by pressing [I ( bracket and capital I )
. it shows the results found in the command window.

</pre></tip> </html> <Tip category="KVim"> <html><center>FAST
SEARCH ACROSS THE PROJECT</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=117">http://vim.sf.net/tip_view.php?tip_id=117</A><BR>

Searching for a word across the project wastes most of the
developres time, which can be avoided by the use of GNU Id_utils
with VIM.  The procedure needs to be followed is as follows:
download GNU idutils 3.2d (mkid,lid,fid,fnid,xtokid) from <A
HREF="http://www.mossbayeng.com/~ron/vim/builds.html">http://www.mossbayeng.com/~ron/vim/builds.html</A><BR>

uncompress and store these files in the directory from where vim is running.

goto the top level directory of the project, and run mkid, it will create ID
file in that directory (As it is time consuming process, so be patient). copy
this file ID to the directory from where vim is running.

USAGE:

Put these lines in your .vimrc:

	map _u :call ID_search()&lt;Bar&gt;execute "/\\&lt;" . g:word
	. "\\&gt;"&lt;CR&gt; map _n :n&lt;Bar&gt;execute "/\\&lt;" . g:word
	. "\\&gt;"&lt;CR&gt;

	function ID_search()
	  let g:word = expand("&lt;cword&gt;") let x = system("lid --key=none
	  ". g:word) let x = substitute(x, "\n", " ", "g") execute "next " . x
	endfun

To use it, place the cursor on a word, type "_u" and vim will load the file
that contains the word.  Search for the next ocurance of the word in the
same file with "n".  Go to the next file with "_n".

The mapping of "_u" and "_n" can be done to some other key as per your
preference but I use ^K and ^L for this purpose.

</pre></tip> </html> <Tip category="KVim"> <html><center>Configuring
gVim as Internet Explorer 'View Source' editor</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=118">http://vim.sf.net/tip_view.php?tip_id=118</A><BR>

Within the registry, you can specify the source editor to be used by Internet
Explorer when {View|Source} is selected. Unfortunately, you can't specify a
quoted filename argument here, i.e. "%1". The editor specified is supposed
to handle filenames which contain spaces. This will cause problems for
Vim because Vim treats each space as an argument separator. If an unquoted
filename contains spaces, Vim treats the filename as multiple arguments and
will open multiple files instead of one. To workaround this problem a quoted
filename has to be passed to Vim. This can be done by creating the following
Visual Basic Script file gVim.vbs:

'--- gVim.vbs -----------------------------------------------------------------
'function: Start gvim, combining multiple arguments to single file argument.
'changes:  20010905: Quoted 'oWShell.Run' filename argument, allowing spaces.
'	   20010518: Created.  'author:   Freddy Vulto &lt;fvu@fvu.myweb.nl&gt;

  ' Making variable declaration mandatory
option explicit

dim oWShell, sArg, sFile

  ' Create script object
set oWShell = CreateObject("wscript.shell")
  ' Loop through arguments
for each sArg in wscript.arguments
    ' Add argument to filename
  sFile = sFile & sArg & " "
next
  ' Remove excess space
sFile = Trim(sFile)
  ' Run Vim with file argument.  Additional arguments: ' -R: View file
  readonly ' -c "set syntax=html": Use HTML syntax-highlighting '    NOTE:
  Use "-c ""set ft=html""" to make it work for Vim v6.
oWShell.Run _
  """D:\Programs\Vim\Vim58\gvim.exe """ & _ "-R """ & sFile & """ " & _
  "-c ""set syntax=html"""

  ' Destroy script object
set oWShell = NOTHING

The source editor now can be specified by adding the following key to the
registry:

HKEY_LOCAL_MACHINE |- Software
   |- Microsoft
      |- Internet Explorer
	 |- View Source Editor
	    |- Editor Name	 (Default) = D:\Programs\Vim\gvim.vbs

Freddy Vulto &lt;fvu@fvu.myweb.nl&gt; <A
HREF="http://fvu.myweb.nl/Projects/Vim/Web/vim.htm">http://fvu.myweb.nl/Projects/Vim/Web/vim.htm</A><BR>

</pre></tip> </html> <Tip category="KVim">
<html><center>Explorer startup and shutdown</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=119">http://vim.sf.net/tip_view.php?tip_id=119</A><BR>

I really like the new explorer window, but I wanted it to function a little
more seemlessly in the editor.	The following code does two things.  First,
the explorer is started when vim is started.   I also noticed and fixed
that the explorers size is not equal to the window size, hence the strange
behavior when popping between two windows.  The other major function of
the code is to close the explorer when it's the only window that's left.
I'd actually like to take this a step further and close the window if the
last _document_ window is closed.  I'd prefer that multiple explorers or help
windows don't keep the application running - only having a file open keeps the
application running.  But I didn't see an easy way to do this... anyone else?

BTW, thank you Bram for the help figuring this out.

Code (which currently lives in my _vimrc):

" FILE BROWSER STARTUP func OpenFileWindow()
	" :runtime plugin/*.vim		" this would be useful if you were
	calling this
				"   function from the .vimrc directly
	let g:explDetailedList=1	" show size and date by default let
	g:explVertical=1	    " Split vertically let g:explStartRight=0
	" Put new explorer window to the left of the current window :Sexplore
	set nonu set winwidth=15	 " Make the width of the window match
	the explorer setting "let g:explVertical=0	     " Split vertically
	doautocmd fileExplorer BufEnter " Forces the directory refresh to
	occur :winc l		      " change to the document window
endfunc

func CloseIfLast()
	if exists("b:completePath")	" this is how I determine that I'm
	in an explorer window
		let n = winnr() wincmd p if n == winnr()
			quit	" quit the window
		endif wincmd p
	endif
endfunc

if has("autocmd")
	if !exists("rudyautocommands")
		let rudyautocommands = 1 autocmd VimEnter * call
		OpenFileWindow() autocmd WinEnter * call CloseIfLast()

	endif
endif

</pre></tip> </html> <Tip category="KVim"> <html><center>Compiling
Java with Sun JDK (javac) within VIM</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=120">http://vim.sf.net/tip_view.php?tip_id=120</A><BR>

The $VIMRUNTIME/compiler has 'jikes.vim', but there's nothing for traditional
Sun JDK(javac), so I tried (Only tested on Win 2000):

" Vim Compiler File    javac.vim " Compiler:	 Sun/IBM JDK: Javac

if exists("current_compiler")
  finish
endif let current_compiler = "javac"

" Javac defaults to printing output on stderr and no options can convert,
so we have to set 'shellpipe' setlocal shellpipe=2&gt; " 2&gt; works on Win
NT and UNIX setlocal makeprg=javac\ #&lt;.java setlocal errorformat=%f:%l:%m
" Sorry I'm not familiar with 'errorformat', so I set it very simple.

</pre></tip> </html> <Tip category="KVim"> <html><center>Using
vim as a syntax-highlighting pager</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=121">http://vim.sf.net/tip_view.php?tip_id=121</A><BR>

If you want to use Vim's syntax highlighting in a "more"-style pager, here's
one way to set it up:

First, create a vimrc like the following -- I called mine ~/.vimrc.more

---8&lt;---cut here---8&lt;--- " No compatibility -- necessary for mappings
to work.  set nocompatible

" Status line set laststatus=0 set cmdheight=1 set nomodifiable        "
Only in version 6.0 set readonly

" Syntax colouring -- lines taken from syntax.txt discussion on colour xterms.
" See ':help color-xterm'. Use appropriate lines for your own set-up.
if has("terminfo")
    set t_Co=16 set t_Sf=[3%p1%dm set t_Sb=[4%p1%dm
else
    set t_Co=16 set t_Sf=[3%dm set t_Sb=[4%dm
endif " My xterms have a navy-blue background, so I need this line too.
set background=dark " Turn syntax on syntax on

" Key bindings.  nmap b &lt;C-B&gt;&lt;C-G&gt; nmap q :q&lt;CR&gt; " To
type the following line, type *two* C-V's followed by two spaces. This "
is how you map the spacebar.  nmap ^V  &lt;C-F&gt;&lt;C-G&gt; ---8&lt;---cut
here---8&lt;---

Then, to use this .vimrc, add an alias. If you're using tcsh, the syntax
will be something like:

alias vmore "vim -u ~/.vimrc.more"

Then you can type "vmore [filename]" to view a file in this "pager". Spacebar
will move down, 'b' will move back up, and 'q' quits. You can add mappings
for other keys if you want to, also.

</pre></tip> </html> <Tip category="KVim"> <html><center>Skip
blank lines when folding text.</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=122">http://vim.sf.net/tip_view.php?tip_id=122</A><BR>

I love the text folding capabilities of vim.  I didn't like that it would
display the first line of the range as the "title" for the fold.  I like
to write my comments with the "/*" on a line by itself.  So I wrote this
little function that will skip over anything that isn't a character, and
then display whatever it finds after that character.

Just include this in your ~/.vimrc (or ~/.gvimrc):

function GetFirstLineWithChars()
	let line_num = 0 let charline = matchstr(getline(v:foldstart),
	'[a-zA-Z][a-zA-Z ]*') while strlen(charline) == 0
		let line_num = line_num + 1 let charline =
		matchstr(getline(v:foldstart + line_num), '[a-zA-Z][a-zA-Z ]*')
	endw return charline
endfunction set
foldtext='+'.v:folddashes.substitute(GetFirstLineWithChars(),'\\\/\\\/\\\|\\*\\\|\\*\\\|{{{\\d\\=','','g')
set fillchars=fold: hi folded guibg=black guifg=yellow gui=bold

And as an added bonus, for those new to text folding, add this to your .vimrc
file too:

autocmd BufWinLeave *.* mkview autocmd BufWinEnter *.* silent loadview

That way whatever folds you set won't get lost when you quit.  I had that
happen after spending 15 minutes folding up a 3000+ line file.	Happy vimming!

</pre></tip> </html> <Tip category="KVim"> <html><center>use
functionality similar to the * search on multiple files</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=123">http://vim.sf.net/tip_view.php?tip_id=123</A><BR>

The use of star as in vimtip#1 and vimtip#5 is great, here is how to use
this type of search accross a whole directory: Just add the mappings (or
choose different letter combinations): map gr :grep &lt;cword&gt; *&lt;cr&gt;
map gr :grep &lt;cword&gt; %:p:h/*&lt;cr&gt; map gR :grep \b&lt;cword&gt;\b
*&lt;cr&gt; map GR :grep \b&lt;cword&gt;\b %:p:h/*&lt;cr&gt;

mapping one will search for the word under the cursor (like g*) in any of
the files in the current directory mapping two will search for the word
under the cursor (like g*) in any of the files in the same directory as the
current file mapping three will search for the word under the cursor by itself
(i.e. surrounded by word boundary like *) in any of the files in the current
directory mapping four will search for the word under the cursor by itself
(i.e. surrounded by word boundary like *) in any of the files in the same
directory as the current file

Benoit

</pre></tip> </html> <Tip category="KVim">
<html><center>Number a group of lines</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=124">http://vim.sf.net/tip_view.php?tip_id=124</A><BR>

Below is a way to number a set of lines.  Here is an exaple before and
after snapshot:

apple bob pear tree

1 apple 2 bob 3 pear 4 tree

" Description: " This provides a command and a function.  They both can be
called with or " without a range.  In addition, they can be called with or
without " arguments.  Without a range they operate on the current line.  " "
There are two supported arguments.  They are described below: "     arg1 -&gt;
the number to start at.  The default is one.  This will "	      number
your selected lines sequentially.  The start can be a "		    number,
., $, or, 'x (like getline).  "     arg2 -&gt; Text to append after numbers.
The default is a space.  " " Examples: "     To provide your functionality:
"	  :%Nlist 20 "	       :%call Nlist(20) "     To make a list start at
1: "	     :'&lt;,'&gt;Nlist "	 :'&lt;,'&gt;call Nlist() "	To
number the whole buffer (with it's actual line number): "	  :%Nlist "
:%call Nlist() "     To number a subset of lines with their line number (and
put a '] ' in "     front of every number): "	      :'&lt;,'&gt;Nlist . ]\
"	  :'&lt;,'&gt;call Nlist(".", "] ")

command! -nargs=* -range Nlist &lt;line1&gt;,&lt;line2&gt;call
Nlist(&lt;f-args&gt;) function! Nlist(...) range
    if 2 == a:0
	let start = a:1 let append = a:2
    elseif 1 == a:0
	let start = a:1 let append = " "
    else
	let start = 1 let append = " "
    endif

    " try to work like getline (i.e. allow the user to pass in . $ or 'x)
    if 0 == (start + 0)
	let start = line(start)
    endif

    exe a:firstline . "," . a:lastline
    . 's/^/\=line(".")-a:firstline+start.append/'
endfunction

</pre></tip> </html> <Tip category="KVim">
<html><center>Auto commenting for "}"</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=125">http://vim.sf.net/tip_view.php?tip_id=125</A><BR>

I always wanted a script that would auto-comment the end of a conditional
block.	So, I wrote one.  This function searches for the previous matching
"{", grabs the line, and inserts it as a comment after the "}".  If there
is no previous matching "{", it inserts nothing.

So...

    if (test){

will generate:
    } // if (test)

This is obviously not work if you use a different style.  If you use

   if (test) {

then substituting 'getline(".")', use  'getline(line(".") - 1)' should work.

Put the following in your .vimrc: au BufNewFile,BufRead *.c,*.cc,*.C,*.h
imap } &lt;ESC&gt;:call CurlyBracket()&lt;CR&gt;a

function CurlyBracket()
  let l:my_linenum = line(".")	iunmap } sil exe "normal i}" imap }
  &lt;ESC&gt;:call CurlyBracket()&lt;CR&gt; let l:result1 =  searchpair('{',
  '', '}', 'bW') if (result1 &gt; 0)
    let l:my_string = substitute(getline("."), '^\s*\(.*\){', '\1', "")
    sil exe ":" . l:my_linenum sil exe "normal a //" . l:my_string
  endif
endfunction

</pre></tip> </html> <Tip category="KVim"> <html><center>how do
I get rid of that bold stuff with my xterm?</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=126">http://vim.sf.net/tip_view.php?tip_id=126</A><BR>

Having problems setting up your syntax highlighting because everything is
coming up in bold?

You're probably using an 8 color xterm and setting up highlighting lines such
as  hi Normal ... ctermfg=green .  The solution: use numbers! 0=black, 1=red,
2=green, 3=yellow, 4=blue, 5=magenta, 6=cyan, and 7=white.  Vim tries to use
"bright" colors when its given names (because Windoz machines prefer to use
dim text unless its been made bold).

Read more about it under :help highlight-ctermfg .

</pre></tip> </html> <Tip category="KVim">
<html><center>Preview HTML files quickly</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=127">http://vim.sf.net/tip_view.php?tip_id=127</A><BR>

I've found while writing HTML files that it can become cumbersome when I have
to switch to a web browser, load my page, and move back to VIM regularly to
preview what I've written.  I've come up with the following tricks.

The first one requires that you have lynx (the text-based browser) installed
on your computer (available from <A HREF="http://lynx.isc.org/release/).
If your HTML page is primarily text, with few (if any) images, you can
set up the following function and mapping:">http://lynx.isc.org/release/).
If your HTML page is primarily text, with few (if any) images, you can set
up the following function and mapping:</A><BR>

   function PreviewHTML_TextOnly()
      let l:fname = expand("%:p" ) new set buftype=nofile nonumber exe "%!lynx
      " . l:fname . " -dump -nolist -underscore -width " . winwidth( 0 )
   endfunction

   map &lt;Leader&gt;pt  :call PreviewHTML_TextOnly()&lt;CR&gt;

This will open a new window and display your formatted HTML document in
that window.  Note that bold-face, italics, links, etc. will be lost --
all you will see is the text -- but the "-underscore" parameter to Lynx
causes any text that would have been bold, italicized, or underlined to be
displayed like _this_.

The other trick requires that vim be running on your current machine, and that
you be running a GUI of some sort (X-Windows, Windows, etc.).  You can cause
vim to invoke your favorite browser and have it display the file, like this:
   function PreviewHTML_External()
      exe "silent !mozilla -remote \"openurl(file://" . expand( "%:p" ) . ")\""
   endfunction

   map &lt;Leader&gt;pp :call PreviewHTML_External()&lt;CR&gt;
If you don't use mozilla, you will need to modify the function to use your
preferred browser.

Happy vimming!

</pre></tip> </html> <Tip category="KVim"> <html><center>grep,
diff, patch, idutils, etc. for Windows systems</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=128">http://vim.sf.net/tip_view.php?tip_id=128</A><BR>

     If you use Vim on Windows, and you wish you had some of those nifty
     UNIX command-line tools,
but do not feel like installing all of Cygwin, you
can get many of the most-used tools from Ron Aaron's web site: <A
HREF="http://www.mossbayeng.com/~ron/vim/builds.html">http://www.mossbayeng.com/~ron/vim/builds.html</A><BR>
Since Ron is a big Vim fan (see <A
HREF="http://www.mossbayeng.com/~ron/vim/vimrant.html ) you can count
on">http://www.mossbayeng.com/~ron/vim/vimrant.html ) you can count on</A><BR>
these tools' working well with Vim.  For some hints on how to use them,
read :help :grep :help lid inside Vim.
     Happy Vimming!

</pre></tip> </html> <Tip category="KVim"> <html><center>Removing
automatic comment leaders</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=129">http://vim.sf.net/tip_view.php?tip_id=129</A><BR>

     If you include the "r" flag in the 'formatoptions' option (:help 'fo'
     , :help fo-table ) then the comment leader is inserted
automatically when you start a new line in a comment.  For example, in TeX
the "%" character is the comment leader, and you might type

% This is a tex file.  % The comment leaders on all lines but the first
were generated automatically.  % This is the last line of the comment,
but Vim will insert the comment leader on the next line.  %

You can get rid of the comment leader (along with anything you may already
have typed on the line) without affecting the indent, if any, by typing
"&lt;C-U&gt;" while in Insert mode.

     Related point:  if you want to adjust the indent while in Insert mode,
     you can use "&lt;C-D&gt;" (to Decrease the indent)
or "&lt;C-T&gt;" (to increase it).  In the docs for Vim 6.0, this is described
in the users' manual, :help 30.4 .

</pre></tip> </html> <Tip category="KVim">
<html><center>disabling default ftplugins</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=130">http://vim.sf.net/tip_view.php?tip_id=130</A><BR>

     For an overview of ftplugins (filetype plugins) see

:help ftplugins

If you want to disable all ftplugins, or disable a particular default
ftplugin, see

:help :filetype :help ftplugin-overrule

If you have your own ftplugins, and you want to disable all the default
ones, then do NOT include a check for b:did_ftplugin in your ftplugin files,
and add the line

:autocmd BufEnter * let b:did_ftplugin = 1

to your VIMRC file, BEFORE the ":filetype ftplugin on" line.

</pre></tip> </html> <Tip category="KVim">
<html><center>Scroll alternate window</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=131">http://vim.sf.net/tip_view.php?tip_id=131</A><BR>

This mapping allow you to quickly scroll inactive window when displaying
several windows concurrently.

nmap &lt;silent&gt; &lt;M-Down&gt; :call ScrollOtherWindow("down")&lt;CR&gt;
nmap &lt;silent&gt; &lt;M-Up&gt; :call ScrollOtherWindow("up")&lt;CR&gt;

fun! ScrollOtherWindow(dir)
	if a:dir == "down"
		let move = "\&lt;C-E&gt;"
	elseif a:dir == "up"
		let move = "\&lt;C-Y&gt;"
	endif exec "normal \&lt;C-W&gt;p" . move . "\&lt;C-W&gt;p"
endfun

PS: Original idea and discussion of this tip appeared on vim@vim.org mailing
list, I'm just prettified it a little.

</pre></tip> </html> <Tip category="KVim">
<html><center>window zooming convenience</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=132">http://vim.sf.net/tip_view.php?tip_id=132</A><BR>

i frequently have multiple windows open in vim -- this reduces the number
of lines each window displays -- i almost always have my windows either all
the same size or the current one as big as possible.

the following function can be toggled on or off by typing &lt;Leader&gt;max
(i can do this quite quickly); just change the mapping at the bottom to
something else if you prefer.

this causes the current window to be as big as possible (moving into another
window causes that one to become big) and all the others get very small.
i actually use this ALL the time.  turning it off (by typing the hotkey
sequence again) will cause all windows to have the same height.

"toggles whether or not the current window is automatically zoomed
function! ToggleMaxWins ()
  if exists ('g:windowMax')
    au! maxCurrWin exe "normal \&lt;c-w&gt;=" unlet g:windowMax
  else
    augroup maxCurrWin " au BufEnter * exe "normal
    \&lt;c-w&gt;_\&lt;c-w&gt;\&lt;bar&gt;" " " only max it vertically
    au! BufEnter * exe "normal \&lt;c-w&gt;_" augroup END do maxCurrWin
    BufEnter let g:windowMax=1
  endif
endfunction map &lt;Leader&gt;max :call ToggleMaxWins ()&lt;CR&gt;

</pre></tip> </html> <Tip category="KVim">
<html><center>Windo and Bufdo</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=133">http://vim.sf.net/tip_view.php?tip_id=133</A><BR>

i like bufdo and windo but i don't like the fact that the commands end in
a different window/buffer than from where i executed them.  these versions
(starts with a capital letter) will restore the current window or buffer
when the command's done.

for example, to turn on line numbers everywhere, i use :Windo set nu --
:windo set nu does the trick also but leaves me in a different window than
where i started.

" just like windo but restores the current window when it's done
function! WinDo(command)
  let currwin=winnr() execute 'windo ' . a:command execute currwin . 'wincmd w'
endfunction com! -nargs=+ -complete=command Windo call WinDo(&lt;q-args&gt;)

" just like bufdo but restores the current buffer when it's done
function! BufDo(command)
 let currBuff=bufnr("%") execute 'bufdo ' . a:command execute 'buffer '
 . currBuff
endfunction com! -nargs=+ -complete=command Bufdo call BufDo(&lt;q-args&gt;)

</pre></tip> </html> <Tip category="KVim">
<html><center>View Source in IE6 using VIM</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=134">http://vim.sf.net/tip_view.php?tip_id=134</A><BR>

You can change the "View Source" editor of IE6 by adding the following to
the Windows Registry. Change the path in case you installed VIM in another
location.

[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Internet Explorer\View Source
Editor\Editor Name] @="C:\\vim\\vim60\\gvim.exe"

</pre></tip> </html> <Tip category="KVim">
<html><center>Vim buffer FAQ</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=135">http://vim.sf.net/tip_view.php?tip_id=135</A><BR>

Vim provides various commands and options to support editing multiple buffers.
This document covers some of the questions asked about using multiple buffers
with Vim.  You can get more detailed information about Vim buffer support using
":help windows.txt" in Vim.  You can also use the help keywords mentioned in
this document to read more about a particular command or option.  To read more
about a particular command or option use, ":help &lt;helpkeyword&gt;" in Vim.

1. What is a Vim buffer?
   A buffer is a file loaded into memory for editing.  All opened files
   are associated with a buffer. There are also buffers not associated with
   any file.

   Help keyword(s): windows-intro

2. How do I identify a buffer?
   Vim buffers are identified using a name and a number.  The name of the
   buffer is the name of the file associated with that buffer.	The buffer
   number is a unique sequential number assigned by Vim.  This buffer number
   will not change in a single Vim session.

   Help keyword(s): :buffers

3. How do I create a buffer?
   When you open a file using any of the Vim commands, a buffer is
   automatically created.  For example, if you use the ":edit file" command
   to edit a file, a new buffer is automatically created.

4. How do I add a new buffer for a file to the buffer list without opening
   the file?  You can add a new buffer for a file without opening it, using
   the ":badd" ex command.  For example,

       :badd f1.txt :badd f2.txt

   The above commands will add two new buffers for the files f1.txt and
   f2.txt to the buffer list.

   Help keyword(s): :badd

5. How do I get a list of all the existing buffers?
   You can get a list of all the existing buffers using the ":buffers" or
   ":ls" or ":files" ex command.  This list is called the 'buffer list'.

   In Vim 6.0, to display all the buffers including unlisted buffers, use the
   ":buffers!" or ":ls!" or ":files!" ex command.

   Help keyword(s): :buffers, :ls, :files

6. How do I delete a buffer?
   You can delete a buffer using the ":bdelete" ex command.  You can use either
   the buffer name or the buffer number to specify a buffer.  For example,

       :bdelete f1.txt :bdelete 4

   The above commands will delete the buffer named "f1.txt" and the fourth
   buffer in the buffer list.  The ":bdelete" command will remove the buffer
   from the buffer list.

   In Vim 6.0, when a buffer is deleted, the buffer becomes an unlisted-buffer
   and is no longer included in the buffer list.  But the buffer name and other
   information associated with the buffer is still remembered.	To completely
   delete the buffer, use the ":bwipeout" ex command.  This command will remove
   the buffer completely (i.e. the buffer will not become a unlisted buffer).

   Help keyword(s): :bdelete, :bwipeout

7. How do I delete multiple buffers?
   You can delete multiple buffers in several ways:

   1. Pass a range argument to the ":bdelete" command. For example,

	   :3,5bdelete

      This command will delete the buffers 3, 4 and 5.
   2. Pass multiple buffer names to the ":bdelete" command.  For example,

	   :bdelete buf1.txt buf2.c buf3.h

      This command will delete buf1.txt, buf2.c and buf3.h buffers.  In this
      example, after typing ":bdelete buf", you can press &lt;Ctrl-A&gt;
      to expand all the buffer names starting with 'buf'.

   Help keyword(s): :bdelete, :bwipeout

8. How do I remove a buffer from a window?
   You can remove a buffer displayed in a window in several ways:

   1. Close the window or edit another buffer/file in that window.  2. Use
   the ":bunload" ex command. This command will remove the buffer
      from the window and unload the buffer contents from memory.  The buffer
      will not be removed from the buffer list.

   Help keyword(s): :bunload

9. How do I edit an existing buffer from the buffer list?
   You can edit or jump to a buffer in the buffer list in several ways:

   1. Use the ":buffer" ex command passing the name of an existing buffer
      or the buffer number.  Note that buffer name completion can be used
      here by pressing the &lt;Tab&gt; key.
   2. You can enter the buffer number you want to jump/edit and press the
      Ctrl-^ key.
   3. Use the ":sbuffer" ex command passing the name of the buffer or the
      buffer number.  Vim will split open a new window and open the specified
      buffer in that window.
   4. You can enter the buffer number you want to jump/edit and press the
      Ctrl-W ^ or Ctrl-W Ctrl-^ keys.  This will open the specified buffer
      in a new window.

   Help keyword(s): :buffer, :sbuffer, CTRL-W_^, CTRL-^

10. How do I browse through all the available buffers?
    You can browse through the buffers in the buffer list in several ways:

    1. To jump to the first buffer in the buffer list, use the ":bfirst" or
       ":brewind" ex command.
    2. To jump to the first buffer in the buffer list in a new window, use
       the ":sbfirst" or ":sbrewind" ex command.
    3. To edit the next buffer in the buffer list, use the ":bnext" ex
       command.
    4. To open the next buffer in the buffer list in a new window, use the
       ":sbnext" ex command.
    5. To edit the previous buffer in the buffer list, use the ":bprevious"
       or ":bNext" ex command.
    6. To open the previous buffer in the buffer list in a new window, use
       the ":sbprevious" or ":sbNext" ex command.
    7. To open the last buffer in the buffer list, use the ":blast" ex
       command.
    8. To open the last buffer in the buffer list in a new window, use the
       ":sblast" ex command.

    Help keyword(s): :bfirst, :brewind, :sbfirst, :sbrewind, :bnext,
		     :sbnext, :bprevious, :bNext, :sbprevious, :sbNext,
		     :blast, :sblast

11. How do I open all the buffers in the buffer list?
    You can open all the buffers present in the buffer list using the ":ball"
    or ":sball" ex commands.

    Help keyword(s): :ball, :sball

12. How do I open all the loaded buffers?
    You can open all the loaded buffers in the buffer list using the ":unhide"
    or ":sunhide" ex commands.	Each buffer will be loaded in a separate
    new window.

    Help keyword(s): :unhide, :sunhide

13. How do I open the next modified buffer?
    You can open the next or a specific modified buffer using the ":bmodified"
    ex command.  You can open the next or a specific modified buffer in a
    new window using the ":sbmodified" ex command.

    Help keyword(s): :bmodified, :sbmodified

14. I am using the GUI version of Vim (gvim), is there a simpler way for
    using the buffers instead of the ex commands?  Yes.  In the GUI version of
    Vim, you can use the 'Buffers' menu, which simplifies the use of buffers.
    All the buffers in the buffer list are listed in this menu.  You can
    select a buffer name from this menu to edit the buffer.  You can also
    delete a buffer or browse the buffer list.

    Help keyword(s): buffers-menu

15. Is there a Vim script that simplifies using buffers with Vim?
    Yes.  You can use the bufexplorer.vim script to simplify the process of
    using buffers.  You can download the bufexplorer script from:

	<A
	HREF="http://lanzarotta.tripod.com/vim.html">http://lanzarotta.tripod.com/vim.html</A><BR>

16. Is it possible to save and restore the buffer list across Vim sessions?
    Yes.  To save and restore the buffer list across Vim session, include the
    '%' flag in the 'viminfo' option.  Note that if Vim is invoked with a
    filename argument, then the buffer list will not be restored from the
    last session.  To use buffer lists across sessions, invoke Vim without
    passing filename arguments.

    Help keyword(s): 'viminfo', viminfo

17. How do I remove all the entries from the buffer list?
    You can remove all the entries in the buffer list by starting Vim with
    a file argument.  You can also manually remove all the buffers using the
    ":bdelete" ex command.

18. What is a hidden buffer?
    A hidden buffer is a buffer with some unsaved modifications and is not
    displayed in a window.  Hidden buffers are useful, if you want to edit
    multiple buffers without saving the modifications made to a buffer while
    loading other buffers.

    Help keyword(s): :buffer-!, 'hidden', hidden-buffer, buffer-hidden

19. How do I load buffers in a window, which currently has a buffer with
    unsaved modifications?  By setting the option 'hidden', you can load
    buffers in a window that currently has a modified buffer.  Vim will
    remember your modifications to the buffer.	When you quit Vim, you will be
    asked to save the modified buffers.  It is important to note that, if you
    have the 'hidden' option set, and you quit Vim forcibly, for example using
    ":quit!", then you will lose all your modifications to the hidden buffers.

    Help keyword(s): 'hidden'

20. Is it possible to unload or delete a buffer when it becomes hidden?
    The following works only in Vim 6.0 and above. By setting the 'bufhidden'
    option to either 'hide' or 'unload' or 'delete', you can control what
    happens to a buffer when it becomes hidden.  When 'bufhidden' is set to
    'delete', the buffer is deleted when it becomes hidden. When 'bufhidden'
    is set to 'unload', the buffer is unloaded when it becomes hidden.
    When 'bufhidden' is set to 'hide', the buffer is hidden.

    Help keyword(s): 'bufhidden'

21. How do I execute a command on all the buffers in the buffer list?
    In Vim 6.0, you can use the ":bufdo" ex command to execute an ex command
    on all the buffers in the buffer list.

    Help keyword(s): :bufdo

22. When I open an existing buffer from the buffer list, if the buffer is
    already displayed in one of the existing windows, I want Vim to jump to
    that window instead of creating a new window for this buffer.  How do I
    do this?  When opening a buffer using one of the split open buffer commands
    (:sbuffer, :sbnext), Vim will open the specified buffer in a new window.
    If the buffer is already opened in one of the existing windows, then
    you will have two windows containing the same buffer.  You can change
    this behavior by setting the 'switchbuf' option to 'useopen'.  With this
    setting, if a buffer is already opened in one of the windows, Vim will
    jump to that window, instead of creating a new window.

    Help keyword(s): 'switchbuf'

23. What information is stored as part of a buffer?
    Every buffer in the buffer list contains information about the last
    cursor position, marks, jump list, etc.

24. What is the difference between deleting a buffer and unloading a
    buffer?  When a buffer is unloaded, it is not removed from the buffer list.
    Only the file contents associated with the buffer are removed from memory.
    When a buffer is deleted, it is unloaded and removed from the buffer list.
    In Vim 6, a deleted buffer becomes an 'unlisted' buffer.

    Help keyword(s): :bunload, :bdelete, :bwipeout, unlisted-buffer

25. Is it possible to configure Vim, by setting some option, to re-use the
    number of a deleted buffer for a new buffer?  No.  Vim will not re-use the
    buffer number of a deleted buffer for a new buffer.  Vim will always assign
    the next sequential number for a new buffer.  The buffer number assignment
    is implemented this way, so that you can always jump to a buffer using the
    same buffer number.  One method to achieve buffer number reordering is to
    restart Vim.  If you restart Vim, it will re-assign numbers sequentially
    to all the buffers in the buffer list (assuming you have properly set
    'viminfo' to save and restore the buffer list across vim sessions).

    Help keyword(s): :buffers

26. What options do I need to set for a scratch (temporary) buffer?
    The following works only in Vim 6.0 and above.  You can set the the
    following options to create a scratch (temporary) buffer:

	:set buftype=nofile :set bufhidden=hide :setlocal noswapfile

    This will create a buffer which is not associated with a file, which
    does not have a associated swap file and will be hidden when removed
    from a window.

    Help keyword(s): special-buffers, 'buftype'

27. How do I prevent a buffer from being added to the buffer list?
    The following works only in Vim 6.0 and above. You can prevent a buffer
    from being added to the buffer list by resetting the 'buflisted' option.

	:set nobuflisted

    Help keyword(s): 'buflisted'

28. How do I determine whether a buffer is modified or not?
    There are several ways to find out whether a buffer is modified or not.
    The simplest way is to look at the status line or the title bar.  If the
    displayed string contains a '+' character, then the buffer is modified.
    Another way is to check whether the 'modified' option is set or not.
    If 'modified' is set, then the buffer is modified.	To check the value
    of modified, use

	:set modified?

    You can also explicitly set the 'modified' option to mark the buffer as
    modified like this:

	:set modified

    Help keyword(s): 'modified'

29. How can I prevent modifications to a buffer?
    The following works only in Vim 6.0 and above. You can prevent any
    modification to a buffer by re-setting the 'modifiable' option.  To reset
    this option, use

	:set nomodifiable

    To again allow modifications to the buffer, use:

	:set modifiable

    Help keyword(s): 'modifiable'

30. How do I set options specific to the current buffer?
    The following works only in Vim 6.0 and above.  You can set Vim options
    which are specific to a buffer using the "setlocal" command.  For example,

	:setlocal textwidth=70

    This will set the 'textwidth' option to 70 only for the current buffer.
    All other buffers will have the default or the previous 'textwidth' value.

    Help keyword(s): 'setlocal', local-options

31. How do I define mappings specific to the current buffer?
    The following works only in Vim 6.0 and above.  You can define mappings
    specific to the current buffer by using the keyword "&lt;buffer&gt;"
    in the map command.  For example,

	:map &lt;buffer&gt;  ,w  /[.,;]&lt;CR&gt;

    Help keyword(s): :map-local

32. How do I define abbreviations specific to the current buffer?
    The following works only in Vim 6.0 and above.  You can define
    abbreviations specific to the current buffer by using the keyword
    "&lt;buffer&gt;" in the :abbreviate command.  For example,

	:abb &lt;buffer&gt; FF	for (i = 0; i &lt; ; ++i)

    Help keyword(s): :abbreviate-local

</pre></tip> </html> <Tip category="KVim"> <html><center>Remapping
Alt, Ctrl and Caps in Win2k</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=136">http://vim.sf.net/tip_view.php?tip_id=136</A><BR>

Since I installed Win2K on my laptop, I had been unable to locate a utilitie
that would simply enable me to remap my Crtl Alt and Caps the way I think they
should be and the way they were until MS kill all competition in computing,
that is Crtl on the left of the letter A, Alt to the left bottom of the
letter Z and Caps approximately until the C.

After some research, I came across a tip posted here by juano@mindspring.com. I
tried to make sense of it and then downloaded the MS scan keys map at the
URL he mentionned.

Extrapolating his tip, I wrote this ASCI file that I named keys2000.reg :

Regedit4 [HKey_Local_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard
Layout] "Scancode
Map"=hex:00,00,00,00,00,00,00,00,04,00,00,00,3A,00,38,00,38,00,1D,00,1D,00,3A,00,00,00,00

Once you have saved this file, left click on it from Explorer and answer
yes to the prompt "do you want to enter this into the registry".

Reboot and you are done.

A few explanations :04 stands for 3 remappings (Caps lock to Control, Control
to Alt and Alt to Caps Lock) plus the closing one which is always required
(1 remapping would require 02, 2 would require 03, and so on). 3A,00,38
remaps Caps to Left Alt, 38,00,1D remaps Left Alt to Left Ctrl and 1D,00,3A
remaps Left Ctrl to Caps Lock since 3A=Caps, 1D=Left Ctrl and 38=Left Alt.

Based on Juano tip and on this one, I believe a lot of remapping can be done
as long as you keep the separators 00 and remember to add one to the number
of remappings. What I do not know is how far you can extend this instruction
without getting into trouble with the registry. At worst, if you keyboard does
not behave as expected, go into the registry and delete this instruction (be
careful here since it is easy to confuse this instruction with the Keyboard
LayoutS (S for emphasis) which must not be deleted.

Again, thanks to Juano@mindspring.com who got me going and suggested I
post my tip. Took me some time to retrieve the VIM Url but fortunately,
I had printed his tip.

Regards

</pre></tip> </html> <Tip category="KVim">
<html><center>automatically wrap left and right</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=137">http://vim.sf.net/tip_view.php?tip_id=137</A><BR>

I hate it when I hit left (or h) and my screen flickers.  I want it to go up
to the next line.  Ditto fir right (or l).  Below are two functions / mappings
to help with that.  I'm pretty sure that if you remove the &lt;silent&gt;,
then it will work in 5.x...

nnoremap &lt;silent&gt; &lt;Left&gt;  :call WrapLeft()&lt;cr&gt; nnoremap
&lt;silent&gt; &lt;Right&gt; :call WrapRight()&lt;cr&gt;

nnoremap &lt;silent&gt; h	:call WrapLeft()&lt;cr&gt; nnoremap
&lt;silent&gt; l       :call WrapRight()&lt;cr&gt;

function! WrapLeft()
    let col = col(".")

    if 1 == col
	" don't wrap if we're on the first line if 1 == line(".")
	    return
	endif normal! k$
    else
	normal! h
    endif
endfunction

function! WrapRight()
    let col = col(".")	if 1 != col("$")
	let col = col + 1
    endif

    if col("$") == col
	" don't wrap if we're on the last line if line("$") == line(".")
	    return
	endif normal! j1|
    else
	normal! l
    endif
endfunction

</pre></tip> </html> <Tip category="KVim">
<html><center>Getting name of the function</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=138">http://vim.sf.net/tip_view.php?tip_id=138</A><BR>

Hi All,

While browsing code one always needs to know which function you are currently
looking. Getting the name is very painful when the functions are lengthy
and you are currently browsing NOT near to the start of the function. You
can get the function's name by using this simple mapping.

Just place this in your .vimrc.

map _F ma[[k"xyy`a:echo @x&lt;CR&gt;

now _F will display which function you are currently in.

Enjoy the power of Vim -Nitin Raut

PS: The working is as follows, mark the current line with a, jump to the
previous '{' in the first column, go one line up, yank the line in register
x, return to the mark a, echo the value of register x, which is the wanted
function name.

</pre></tip> </html> <Tip category="KVim"> <html><center>=,
LaTeX tables, declarations, etc</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=139">http://vim.sf.net/tip_view.php?tip_id=139</A><BR>

Check out

<A
HREF="http://www.erols.com/astronaut/vim/textab.html">http://www.erols.com/astronaut/vim/textab.html</A><BR>

and see some examples of text alignment (its hopeless to do it here with
proportional fonts).  You'll be able to download textab source, a Windows-based
textab executable, and a scriptfile containing a convenient interface
(ttalign.vim).	The textab program coupled with &lt;ttalign.vim&gt; lets you:

1. align C language statements on their = += -= /= etc symbols 2. align C
language declararations: separate columns for types, *[, variable
   names, initializations (=), and comments (// or /* .. */)
3. align C/C++ language comments (//, /* .. */) 4. align C/C++ language
(ansi) function argument lists 5. align LaTeX tables on their && separators
6. align HTML tables with &lt;/TD&gt;&lt;TD&gt; separators 7. align on
several characters: &lt; ? : | @ ;  (or modify them to handle whatever
   alignment characters you want)

</pre></tip> </html> <Tip category="KVim"> <html><center>tip
using embedded perl interpreter</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=140">http://vim.sf.net/tip_view.php?tip_id=140</A><BR>

When writing scripts using the embedded interpreter available if vim has the
+perl ore +perl/dyn on gives you access to this powerfull and FAST scripting
language (especially fast compared to vim scripts)  there are some gotchas.

First: never embed complex perl command in the body of a vim function this
will be recompiled and evaled each time for a tremendous loss of time.instead
to it like this

perl &lt;&lt; EOF sub mySub {
  #some usefull perl stuff
} EOF

function! MyFunction perl mySub "an argument", "another" endfunction

to pass computed argument to your perl sub use the vim exec command
function! MyFunction exec "perl mySub " . aLocalVar . ", " b:aBufferLocalVar
endfunction

It may be very hard to debug your perl sub since the output of the perl
compiler is somehow lost in the middle of nowhere and the debugger is not
available.  When a compilation error occurs in your sub definition you'll get
an error message when you try to call it saying that the sub does not exists.
One thing which I have found very usefull is to write a fake VIM module with
stub methods which will allow you to use the command line perl interpretor
to at least compile your program.  You could make your stub smart enough to
fake a vim and use the debugger.  Here is a sample for such a fake module
defining just those method which I was using.

package VIM; use diagnostics; use strict; sub VIM::Eval {
	$_ = shift;

	print "Eval $_\n";

	{
		  return
		  '^(?!!)([^\t]*)\t[^\t]*\t(.*);"\t([^\t]*)\tline:(\d*).*$'
		  if (/g:TagsBase_pattern/); return $ARGV[0] if
		  (/b:fileName/); return '$3' if (/g:TagsBase_typePar/);
		  return '$1' if (/g:TagsBase_namePar/); return '$4' if
		  (/g:TagsBase_linePar/); return 'Ta&gs' if (/s:menu_name/);
		  return $ARGV[1] if (/g:TagsBase_groupByType/);
		die "unknown eval $_";
	}
} sub VIM::Msg {
	my $msg = shift; print "MSG $msg\n";
} sub VIM::DoCommand {
	my $package; my $filename; my $line;
    ($package, $filename, $line) = caller;

	my $command = shift; print "at $filename $line\n"; print "DoCommand
	$command\n";
} 1;

Then you can copy other your perl code in a separate file and add a use VIM;
at the top and your set to debug.

Good Vimming good perling.  Benoit PS: this tips are probably true for other
scripting languages

</pre></tip> </html> <Tip category="KVim"> <html><center>Add
your function heading with a keystroke</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=141">http://vim.sf.net/tip_view.php?tip_id=141</A><BR>

Below is a tip that the C/C++ Newbies may find interesting and handy to use.
The following code will add a function heading and position your cursor just
after Description so that one can document as one proceeds with code.

function FileHeading()
	let s:line=line(".")  call
	setline(s:line,"/***************************************************")
	call append(s:line,"* Description - ") call append(s:line+1,"*
	Author -      Mohit Kalra") call append(s:line+2,"* Date
	-	 ".strftime("%b %d %Y")) call append(s:line+3,"*
	*************************************************/") unlet s:line
endfunction

imap &lt;F4&gt;  &lt;esc&gt;mz:execute FileHeading()&lt;RET&gt;`zjA

Where &lt;esc&gt; stands for ^V+ESC and &lt;RET&gt; for ^V+ENTER

</pre></tip> </html> <Tip category="KVim"> <html><center>Automatic
function end commenting for C++ and Java</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=142">http://vim.sf.net/tip_view.php?tip_id=142</A><BR>

Some people have a habit of adding the function name as a comment to the
end of that function, if it is long, so that he/she knows which function the
'}' ends. Here's a way to automate the process.

Use the following abbreviation: iab }// } // END:
&lt;esc&gt;10h%$?\w\+\s*(&lt;cr&gt;"xy/\s*(&lt;cr&gt;/{&lt;cr&gt;:nohl&lt;cr&gt;%$"xpa

If you now end the function with '}//', the follwoing string will be
automatically generated: '} //END: functionname'

</pre></tip> </html> <Tip category="KVim"> <html><center>Use
of Vim folds for javadocs</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=143">http://vim.sf.net/tip_view.php?tip_id=143</A><BR>

Hi,

The fold-method marker can be effectively use to set the folds in your
Java source.  Define some marker and place it inside HTML comments &lt;!--
xx --&gt;.  This way, it does not affect the Javadocs generated without the
necessity of a seprate comment line.  e.g.

/**
 * &lt;!-- zz.FOLDSTART class AbcClass --&gt; * The class description.
 * ...	*/
public class AbcClass {

    /**
     * &lt;!-- method zz.FOLDSTART someMethod() --&gt; * Method description.
     */
    public void someMethod();

    ...

} /* zz.END: AbcClass */

/* Put this at the end of your file */ /* vim:fdm=marker
fmr=zz.FOLDSTART,zz.END fdl=2 fdc=2: */

Now, the files will be opened with the methods neatly folded.  You can use
"zR" to open all folds (or click on the "+" at the left column).

Sameer.

</pre></tip> </html> <Tip category="KVim"> <html><center>recording
keystrokes by "q" for repested jobs</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=144">http://vim.sf.net/tip_view.php?tip_id=144</A><BR>

The most useful feature that I find in VIM is the "recording" feature (:help
recording).  I have used this to automatically insert function headers,
re-indent lines, and convert some 34 source files into HTML.

This feature is most useful when you want to do some repeated jobs, which
you cant do easily using ".".  You can set about writing a function, define
a mapping, etc, but then these things might take time.	By recording, you
can try out and find the actual keystrokes that does the job.

To start recording, press "q" in normal mode followed by any of "0-9a-z".
This will start recording the keystrokes to the register you choose.  You can
also see the word "recording" in the status(?) line.  You can start the key
sequences that you want to record.  You can go to insert mode and type if
you want.

To stop recording, press "q" in the normal mode.

To playback your keystrokes, press "@" followed by the character you choose.
Pressing "@@" will repeat the same again.

Sameer.

</pre></tip> </html> <Tip category="KVim"> <html><center>Changing
DOS style end of line to UNIX, or vise-versa</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=145">http://vim.sf.net/tip_view.php?tip_id=145</A><BR>

Those of us doomed to work in both the Unix and Windows world have many times
encountered files that were create/editted on systems other that the one
we are on at the time of our edits.  We can easily correct the dreaded '^M'
at the end of our Unix lines, or make files have more than one line in DOS by:

To change from &lt;CR&gt;&lt;LF&gt; (DOS) to just &lt;LF&gt; (Unix): :set
fileformat=unix :w

Or to change back the other way: :set fileformat=dos :w

It also works for Apple land: :set fileformat=mac :w

And to tell the difference: set statusline=%&lt;%f%h%m%r%=%{&ff}\ %l,%c%V\ %P
					      ^^^^^  This shows what the
					      current file's format is.

Happy Vimming!

</pre></tip> </html> <Tip category="KVim"> <html><center>opening
multiple files from a single command-line</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=146">http://vim.sf.net/tip_view.php?tip_id=146</A><BR>

i use the :split command a lot -- both to open a second window containing
the currently edited file and to edit a new file altogether (with the :split
&lt;filename&gt; option).  however, i also like to be able to edit more than
one file and calling :sp multiple times is inconvenient.  so, i created the
following command, function and abbreviation:

function! Sp(...)
  if(a:0 == 0)
    sp
  else
    let i = a:0 while(i &gt; 0)
      execute 'let file = a:' . i execute 'sp ' . file

      let i = i - 1
    endwhile
  endif
endfunction com! -nargs=* -complete=file Sp call Sp(&lt;f-args&gt;) cab sp Sp

this retains the behaviour of :sp in that i can still type :sp (the
abbreviation takes care of that).  :Sp takes any number of files and opens
them all up, one after the other.

the things i have noticed are that this causes 'sp' to be expanded to 'Sp'
everywhere, even in search patterns.  also, prepending 'vert' doesn't work.
if there is interest, i'll do that.

</pre></tip> </html> <Tip category="KVim">
<html><center>How to write a plugin</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=147">http://vim.sf.net/tip_view.php?tip_id=147</A><BR>

This tip gives a skeleton for writing a plugin; Vim's help files have plenty
of details (:he plugin, :he write-plugin, :he plugin-details).

#
------------------------------------------------------------------------------
# Exit when your app has already been loaded (or "compatible" mode set)
if exists("loaded_YourAppName") || &cp
  finish
endif

# Public Interface: #  AppFunction: is a function you expect your users to
call #	PickAMap: some sequence of characters that will run your AppFunction #
Repeat these three lines as needed for multiple functions which will # be used
to provide an interface for the user if !hasmapto('&lt;Plug&gt;AppFunction')
  map &lt;unique&gt; &lt;Leader&gt;PickAMap &lt;Plug&gt;AppFunction
endif

# Global Maps: # map &lt;silent&gt; &lt;unique&gt;
&lt;script&gt; &lt;Plug&gt;AppFunction \ :set lz&lt;CR&gt;:call
&lt;SID&gt;AppFunc&lt;CR&gt;:set nolz&lt;CR&gt;

#
------------------------------------------------------------------------------

# AppFunction: this function is available vi the &lt;Plug&gt;/&lt;script&gt;
interface above fu! &lt;SID&gt;AppFunction() ..whatever..

# your script function can set up maps to internal functions
nmap &lt;silent&gt; &lt;left&gt; :set lz&lt;CR&gt;:silent! call
&lt;SID&gt;AppFunction2&lt;CR&gt;:set nolz&lt;CR&gt;

# your app can call functions in its own script and not worry about
name # clashes by preceding those function names with &lt;SID&gt; call
&lt;SID&gt;InternalAppFunction(...)

# or you could call it with call s:InternalAppFunction(...)  endf #
------------------------------------------------------------------------------

# InternalAppFunction: this function cannot be called from outside the #
script, and its name won't clash with whatever else the user has loaded
fu! &lt;SID&gt;InternalAppFunction(...)  ..whatever..  endf

#
------------------------------------------------------------------------------

Plugins are intended to be "drop into &lt;.vim/plugin&gt;" and work.
The problem that the &lt;Plug&gt;, &lt;SID&gt;, etc stuff is intended to
resolve: what to do about functions that have the same names in different
plugins, and what to do about maps that use the same sequence of characters?
The first problem is solved with &lt;SID&gt; (a script identifier number)
that vim assigns: program with it and your users will be happier when your
stuff works with all their other stuff.  The second problem: what to about
those maps is addressed with &lt;Plug&gt;, &lt;unique&gt;, etc.  Basically
the idea is: let the user know that there are clashes and don't overwrite
previously existing maps.  Use the user's preferred map-introducer sequence
(I like the backslash, but there are many keyboards which make producing
backslashes unpleasant, and those users usually prefer something else).

What I like to do is to have a pair of start/stop maps to reduce my impact
on the namespace.  When the starting map is used, it kicks off a starting
function that introduces all the maps needed.  When the stopping map is
used, it not only removes the maps the starter made but restores any maps
the user had had that would have clashed.  I also use the start/stop pair
of functions to set and restore options that cause my scripts difficulties.

Check out DrawIt.vim's SaveMap() function for a way to save user maps.
Restoring maps with it is easy:

if b:restoremap != ""
 exe b:restoremap unlet b:restoremap
endif

So you can see it sets up a string variable with all the maps that the user
had that would have clashed with my application.

One final thing: if your application needs to share information between
its various functions, see if you can use s:varname (a variable that only
your script's functions can access) or b:varname (a variable that anything
associated with the buffer your application is running with can access)
instead of using global variables.

Good luck and happy Vimming!

</pre></tip> </html> <Tip category="KVim"> <html><center>Make
great use of those homemade menus</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=148">http://vim.sf.net/tip_view.php?tip_id=148</A><BR>

Accidently discovered that using &lt;alt&gt;&lt;Menu Hotletter&gt;&lt;cr&gt;
(e.g &lt;alt&gt;b&lt;cr&gt; - for the buffer menu) causes the menu to break
out in a seperate window.  Selecting the menu with the mouse and then hitting
enter does not seem to do it.

I will have to learn to add hotletters to my menus now so that the mouse
can take a break.

I am a total newbie with vim, but constantly amazed....

</pre></tip> </html> <Tip category="KVim"> <html><center>Automatically
update your diff upon writing.</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=149">http://vim.sf.net/tip_view.php?tip_id=149</A><BR>

When trying to reconcile differences between files, and using the new 'diff'
functionality in Vim 6.0 you may want to automatically update the differences
as you are working along.  A convienent time is when you write out either of
the files you are diff'ing.  This autocmd will take care of doing that for you.

" If doing a diff.  Upon writing changes to file, automatically update the
  " differences au BufWritePost			 *		if &diff ==
  1 au BufWritePost		     *		    :diffupdate au BufWritePost
  *		 endif

</pre></tip> </html> <Tip category="KVim"> <html><center>Generating
a column of increasing numbers</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=150">http://vim.sf.net/tip_view.php?tip_id=150</A><BR>

You can use the "Visual Incrementing" script from

  <A
  HREF="http://www.erols.com/astronaut/vim/index.html#VimFuncs">http://www.erols.com/astronaut/vim/index.html#VimFuncs</A><BR>

to convert a block of numbers selected via ctrl-v (visual block) into a
column of increasing integers.	Select the column, press :I&lt;CR&gt;, and
the first line's number will be used as a starting value.  Subsequent lines's
numbers will be incremented by one.

If the ctrl-v block is "ragged right", which can happen when "$" is used to
select the right hand side, the block will have spaces appended as needed
to straighten it out.  If the strlen of the count exceeds the visual-block
allotment of spaces, then additional spaces will be inserted.

Example:  Put cursor on topmost zero, select column with ctrl-v, then :I

   vector[0]= 1;       vector[0]= 1; vector[0]= 1;	 vector[1]= 1;
   vector[0]= 1;  --&gt;  vector[2]= 1; vector[0]= 1;	    vector[3]= 1;
   vector[0]= 1;       vector[4]= 1;

This script works with both vim 5.7 (:so visincr.vim) or vim 6.0 (source it
as for vim 5.7 or drop it into the .vim/plugin directory).

</pre></tip> </html> <Tip category="KVim">
<html><center>an ascii table</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=151">http://vim.sf.net/tip_view.php?tip_id=151</A><BR>

There is an ascii table in the vim-help files, but it's hard to find.  Thus,
I shall give a pointer to it:

:help digraph-table

</pre></tip> </html> <Tip category="KVim"> <html><center>Dutch,
English, German, Hungarian, and Yiddish</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=152">http://vim.sf.net/tip_view.php?tip_id=152</A><BR>

Under <A
HREF="http://www.erols.com/astronaut/vim/index.html#vimlinks_scripts">http://www.erols.com/astronaut/vim/index.html#vimlinks_scripts</A><BR>
are links to spelling checkers for Dutch, English, German, Hungarian,
and Yiddish, all based on the original engspchk.vim.  The spelling checker
provides as-you-type spell checking; with vim6.0 it will avoid checking on
partially typed words.

Provided are several maps:

  \et : add  word under cursor into database for just this file \es : save
  word under cursor into database (permanently) \en : move cursor to the
  next	   spelling error \ep : move cursor to the previous spelling error
  \ea : look for alternative spellings of word under cursor

To use \ea you will need agrep:

  agrep source: <A
  HREF="ftp://sunsite.unc.edu/pub/Linux/utils/text/agrep-2.04.tar.Z">ftp://sunsite.unc.edu/pub/Linux/utils/text/agrep-2.04.tar.Z</A><BR>
  agrep Win exe: <A
  HREF="http://www.tgries.de/agrep">http://www.tgries.de/agrep</A><BR>

To use the spell checkers just source it in:

  ex.  so engspchk.vim

To read more about it see

  <A
  HREF="http://www.erols.com/astronaut/vim/index.html#Spelling">http://www.erols.com/astronaut/vim/index.html#Spelling</A><BR>

</pre></tip> </html> <Tip category="KVim"> <html><center>Making
Parenthesis And Brackets Handling Easier</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=153">http://vim.sf.net/tip_view.php?tip_id=153</A><BR>

1) ++++++++++++++++++++++++++ "Automatic" bracket setting
+++++++++++++++++++++++++++++ 2) +++++++++++++ Further improvement of
parenthesis/bracket expanding +++++++++++++++++ 3) ++++++++++++++++++++++++++++
"Late" bracketing of text +++++++++++++++++++++++++++++ 4)
+++++++++++++++++++++++++++++ Conclusion ++++++++++++++++++++++++++++++++++++++
++++

=======================================================================================

1) ++++++++++++++++++++++++++ "Automatic" bracket setting
+++++++++++++++++++++++++++++

To automatically insert a closing parenthesis when typing an opening
parenthesis you can insert the following simple mapping to your vimrc:

	:inoremap ( ()&lt;ESC&gt;i

This ends up with the cursor between the opening and the closing parenthesis
in insert mode.

You can apply this and the following tips, of course, with the kind of
parenthesis/bracket character you want to, i.e. (, {, [, &lt; ..... and,
pretty useful as well, quotation marks ",',.... (to be continued)

2) +++++++++++++++ Further improvement of parenthesis/bracket expanding
++++++++++++++++++

I you are ready with filling the parenthesis/brackets, you likely want to
"escape" from the brackets again to continue coding.  To make this pretty
comfortable, I invented the following kind of mappings, which get out of
the last expanded parenthesis/bracket, regardless of the actual type of it,
and enter append mode again.  I mapped this kind of "getaway" with CTRL_j,
you may use your favorite keystroke with it.

			...
	:inoremap ( ()&lt;ESC&gt;:let leavechar=")"&lt;CR&gt;i :inoremap [
	[]&lt;ESC&gt;:let leavechar="]"&lt;CR&gt;i
			...
	:imap &lt;C-j&gt; &lt;ESC&gt;:exec "normal f" . leavechar&lt;CR&gt;a

Explanation: The variable "leavechar" contents the actual char which is to
"escape" from.

3) ++++++++++++++++++++++++++++ "Late" bracketing of text
+++++++++++++++++++++++++++++

Occasionally I later want already written text parts to put in parenthesis.

I use the following macro, which brackets previously visually selected text.
I mapped it with _(.

	:vnoremap _( &lt;ESC&gt;`&gt;a)&lt;ESC&gt;`&lt;i(&lt;ESC&gt;

Furthermore, a sort of mapping for bracketing a *single word* is conceivable.
Because this is not as general like the kind of visual mode mapping, I use
this kind of "word bracketing" only for surrounding the word right behind
the cursor in insert mode with **.  I use the following macro to "emphasize"
the word i just typed, for newsgroup articles.

	:imap _* &lt;Esc&gt;bi*&lt;Esc&gt;ea*&lt;Space&gt;

4) ++++++++++++++++++++++++++++++ Conclusion
++++++++++++++++++++++++++++++++++++++++++

Since I use these macros, I never caused a syntax error because of missing
brackets, and furthermore I can quickly insert parenthesis and qutotes into
code- and non-code files.

 JH 04.11.2001

</pre></tip> </html> <Tip category="KVim"> <html><center>Mappings
to facilitate the creation of text</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=154">http://vim.sf.net/tip_view.php?tip_id=154</A><BR>

" " Mappings to facilitate the creation of text " " Author:  Suresh Govindachar
sgovindachar@yahoo.com " Date:	   November 5, 2001 " " While typing text to
create a document, I often end up hitting " &lt;Esc&gt;, issuing some commands
(with or without ":") and getting back " to typing by issuing a command such
as "i", "O", "s" etc.  " " I looked into using "set insertmode" to speed
up such actions, but " found that too confusing.  " " I have come up with
a set of mappings that have speeded up my process " of creating documents.
I have saved these mappings in a file, named " FullScreenVI.vim, in vim's
plugin directory.  " " Perhaps you will find these mappings helpful too.
" " Please send me feedback.  "

"To allow overriding the Alt key set winaltkeys=no "To enable viewing messages
from commands issued using the mappings presented here set cmdheight=2

"The fundamental mapping that makes full-screen editing possible imap
&lt;A-o&gt;  &lt;C-o&gt; imap &lt;A-;&gt;  &lt;C-o&gt;:

"Basic motions imap &lt;A-h&gt;  &lt;Left&gt; imap &lt;A-j&gt;	&lt;Down&gt;
imap &lt;A-k&gt;  &lt;Up&gt; imap &lt;A-l&gt;  &lt;Right&gt; imap &lt;A-f&gt;
&lt;PageDown&gt; imap &lt;A-b&gt;  &lt;PageUp&gt; imap &lt;A-^&gt;
&lt;Home&gt; imap &lt;A-$&gt;  &lt;End&gt;

"Numbers for repeats imap &lt;A-1&gt;  &lt;C-o&gt;1 imap &lt;A-2&gt;
&lt;C-o&gt;2 imap &lt;A-3&gt;  &lt;C-o&gt;3 imap &lt;A-4&gt;  &lt;C-o&gt;4
imap &lt;A-5&gt;  &lt;C-o&gt;5 imap &lt;A-6&gt;  &lt;C-o&gt;6 imap &lt;A-7&gt;
&lt;C-o&gt;7 imap &lt;A-8&gt;  &lt;C-o&gt;8 imap &lt;A-9&gt;  &lt;C-o&gt;9

"Basic searches imap &lt;A-/&gt;  &lt;C-o&gt;/ imap &lt;A-*&gt;  &lt;C-o&gt;*
imap &lt;A-#&gt;  &lt;C-o&gt;# imap &lt;A-n&gt;  &lt;C-o&gt;n imap &lt;A-N&gt;
&lt;C-o&gt;N

"Deleting imap &lt;A-x&gt;  &lt;C-o&gt;x imap &lt;A-d&gt;  &lt;C-o&gt;d imap
&lt;A-D&gt;  &lt;C-o&gt;D

"Yanking and putting imap &lt;A-y&gt;  &lt;C-o&gt;y imap &lt;A-Y&gt;
&lt;C-o&gt;Y imap &lt;A-p&gt;  &lt;C-o&gt;p imap &lt;A-P&gt;  &lt;C-o&gt;P

"Common prefixes:  marking, matching etc.  imap &lt;A-~&gt;  &lt;C-o&gt;~
imap &lt;A-m&gt;  &lt;C-o&gt;m imap &lt;A-`&gt;  &lt;C-o&gt;` imap &lt;A-"&gt;
&lt;C-o&gt;" imap &lt;A-%&gt;  &lt;C-o&gt;% imap &lt;A-h&gt;  &lt;C-o&gt;:h
imap &lt;A-s&gt;  &lt;C-o&gt;:s

"Interacting with the 'outside' imap &lt;A-!&gt;  &lt;C-o&gt;:!  imap
&lt;A-w&gt;  &lt;C-o&gt;:w&lt;CR&gt; imap &lt;A-e&gt;  &lt;C-o&gt;:e

"Other commands imap &lt;A-u&gt;  &lt;C-o&gt;u imap &lt;A-.&gt;  &lt;C-o&gt;.

</pre></tip> </html> <Tip category="KVim"> <html><center>Decompile
Java .class files automatically</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=155">http://vim.sf.net/tip_view.php?tip_id=155</A><BR>

Here's a plugin to automatically decompile Java .class files as they're
read in.  Tweak the javap flags for what you want to see.  I didn't post
this as a script because it's too simple and it's really more useful for
demonstrating how to read decompilable files (or other binary files that
can be converted to text).

function s:ReadClass(dir, classname)
    execute "cd " . a:dir execute "0read !javap -c " . a:classname 1 setlocal
    readonly setlocal nomodified
endfunction

autocmd BufReadCmd *.class
    \ call &lt;SID&gt;ReadClass(expand("&lt;afile&gt;:p:h"),
    expand("&lt;afile&gt;:t:r"))

</pre></tip> </html> <Tip category="KVim"> <html><center>describe
&lt;table name&gt; from vim</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=156">http://vim.sf.net/tip_view.php?tip_id=156</A><BR>

i had some trouble with the sqlplus scripts (probably my fault).  but it
seemed a little heavy for what i need, usually all i want is a listing of
the columns for a given table while i'm whipping on some sql inside vim.

so i wrote a bash script (describe)...

~~~~~~~~~~~~~~~begin describe script #!/usr/bin/bash

f=aTempFile.sql u=&lt;uName&gt; p=&lt;pWord&gt; d=&lt;dBase&gt;

echo "/* describe for $1" echo "describe $1;" &gt; $f; echo "quit;"
&gt;&gt; $f;

sqlplus -S $u/$p@$d @$f rm -f $f; echo " end describe for $1 */"
~~~~~~~~~~~~~~~end describe script

your path needs to include the script (as well as sqlplus), then from vim
you can just type....

:r !describe &lt;tableName&gt;

and you get a listing of the table columns slammed into wherever your cursor
was, complete with java/c comments

</pre></tip> </html> <Tip category="KVim">
<html><center>Incredible new functionality</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=157">http://vim.sf.net/tip_view.php?tip_id=157</A><BR>

if you get away from vim and get any other editor that was built *after*
1970....

</pre></tip> </html> <Tip category="KVim"> <html><center>Using
Computer Modern TT as gvim font (Win32)</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=158">http://vim.sf.net/tip_view.php?tip_id=158</A><BR>

If you really like the Computer Modern typewriter font (as seen in most TeX
distributions) you can use it as the font in gvim! (looks excellent with
font smoothing turned on)

First, get hold of the free Blue Sky Type 1 PS versions of the CM fonts from
your local CTAN mirror. Unpack to a suitable directory.

Next locate the cmtt8.pfb file and open it (in Vim, naturally ;) - find the
line saying dup 32 /visiblespace put

and change it to dup 32 /space	      put

that is, inserting enough spaces to keep the file size exactly the same
(IMPORTANT!)

Save the file in Mac format (:set fileformat=mac).

Now install the cmtt.pfm file - in Win9x/NT4, you'll need Adobe Type Manager
(free download), but in Win2k, you can just drop the .pfm file into the
Fonts folder.

Now in your _gvimrc: set guifont=CMTT8:h11:cSYMBOL

(use whatever height you like instead of h11)

..and enjoy! It's the first scalable font I can bear to edit code in... %-)

</pre></tip> </html> <Tip category="KVim"> <html><center>Keystroke
Saving Substituting and Searching</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=159">http://vim.sf.net/tip_view.php?tip_id=159</A><BR>

1) ++++++++++++++ Saving Keystrokes for common Searching
and Substituting +++++++++++ --- a) Searching  b) Substituting
--------------------------------------------------- 2) ++++  Searching for
resp. Substituting of the current word under the cursor ++++++ --- a) Searching
b) Substituting ---------------------------------------------------
3) ++ Searching and Substituting for an arbitrary visually
selected part of text ++++ --- a) Searching  b) Substituting
---------------------------------------------------
4) ++++++++++++++++++++++++++++++++  Conclusion
+++++++++++++++++++++++++++++++++++++

=====================================================================================

1) ++++++++++++++ Saving Keystrokes for common Substituting and Searching
+++++++++++

a) Searching ............  Sorry, there is not much that can be saved for
common Searching. It's just hitting /mypattern&lt;RETURN&gt;

b) Substituting .........  I think, common substitution requires pretty many
keystrokes. So I use the following macro with my favorite substitution options:

:map &lt;F4&gt; :%s//gc&lt;Left&gt;&lt;Left&gt;&lt;Left&gt;

This ends up with the cursor after the first '/' in the
commandline. To complete it, you only have to enter -&gt;
myoldpattern/mynewpattern&lt;RETURN&gt;

Remark: I mapped it to &lt;F4&gt; (cause of tribute to the &lt;F4&gt; of
the good old Norton Commander editor). You may map it where you want to.

2) ++++  Searching for resp. Substituting of the current word under the
cursor ++++++

a) Searching ............  If you don't know how to look for the next
occurence of the word under the cursor, you should *now* type :help * or
:help star or refer to the tips vimtip #1 or vimtip #5 ((Tip within tip:
To make your pattern more visible, look for :help hls))

b) Substituting .........  The following macro extends the one above with
automatically inserting the current word under the cursor into the from -
pattern of the :s command.

:map &lt;S-F4&gt;
:%s/&lt;C-r&gt;&lt;C-w&gt;//gc&lt;Left&gt;&lt;Left&gt;&lt;Left&gt;

To complete it, just enter -&gt;   mynewpattern&lt;RETURN&gt;

I use this i.e. for reliable and quickly renaming a variable in the entire
buffer.  I mapped it to Shift-&lt;F4&gt;. You may map it to the keystroke
you want.

Explanation: CTRL-v+CTRL-w expands to the word under the cursor.

3) ++ Searching and Substituting for an arbitrary visually selected part of
text ++++

If you want to look or substitute (for) an *arbritary* pattern (which
already exists at least once in your text), the following 2 mappings do it
for you.  The advantage is that you dont have to type again or cut & paste
the appropriate text but only have to visually select it.

a) Searching ...........

:vmap / y:execute "/".escape(@",'[]/\.*')&lt;CR&gt;

This immediately finds to the next occurence of the previously visually
selected text.

b) Substituting .........

:vmap &lt;F4&gt; y:execute
"%s/".escape(@",'[]/\')."//gc"&lt;Left&gt;&lt;Left&gt;&lt;Left&gt;&lt;Left&gt;

Again, as in the mapping in chapter 2), you just have to complete it by
entering -&gt; mynewpattern&lt;RETURN&gt;

Explanation/Discussion: What both Substituting and Searching in this way
generally does is: - *y*anking the selected text - Inserting the visually
selected via adressing the '"' register with '@"' as a
  parameter of the escape() function going finally into the 'myoldpattern'
  part.  The trickery problem is, if you have characters in your myoldpattern,
  which are regular expression chars, they are recognized and threated
  accordingly.	That is most likely not what you wanted.  To escape them, these
  chars have to be declared by the second parameter of the excape() function,
  which then escapes them with a backslash.  The few characters above work
  for me. If you run into problems, you should check for additional regexp
  chars in your text, and try to escape them by adding them to the escape()
  function parameter.

4) ++++++++++++++++++++++++++++++++  Conclusion
+++++++++++++++++++++++++++++++++++++

With the appropriate mappings in your vimrc you can save keystrokes when
Searching or Substituting and avoid typing errors. That way, you can take
lunch sooner

</pre></tip> </html> <Tip category="KVim">
<html><center>Dutch spelling checker</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=161">http://vim.sf.net/tip_view.php?tip_id=161</A><BR>

Download at <A
HREF="http://www.thomer.com/thomer/vi/nlspchk.vim.gz.">http://www.thomer.com/thomer/vi/nlspchk.vim.gz.</A><BR>

This sciript is based on Charles E. Campbell's English spelling checker script
for ViM (<A HREF="http://users.erols.com/astronaut/vim/) and Piet Tutelaers'
Dutch word list (http://www.ntg.nl/spell-nl-v5b/) using  Thomas Köhler's
script (http://jeanluc-picard.de/vim/gerspchk/create). In other words, I
didn't do much.">http://users.erols.com/astronaut/vim/) and Piet Tutelaers'
Dutch word list (http://www.ntg.nl/spell-nl-v5b/) using  Thomas Köhler's
script (http://jeanluc-picard.de/vim/gerspchk/create). In other words,
I didn't do much.</A><BR>

</pre></tip> </html> <Tip category="KVim"> <html><center>write
plugin with explorer like interfaces</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=162">http://vim.sf.net/tip_view.php?tip_id=162</A><BR>

Several plugins use a text base interface based on a special buffer, this
is the case of the standard explorer plugin, several bufexplorer plugins,
the option buffer and others...  Here is a quick guide in how to do this

Writing a special buf script
	| using a special buffer is a common technic when writing
	Vim scripts, it is used by | explorer, bufexplorer,
	DirDiff...  | I'm currently writing one for TagsBase.vim | <A
	HREF="http://vim.sourceforge.net/scripts/script.php?script_id=100
	">http://vim.sourceforge.net/scripts/script.php?script_id=100 </A><BR>
	| and I'll use this document to take notes on how to do it.  |

Setting up the buffer
	Opening the window TODO

	Using a setup function
		Principle
			| we can use a specific function to open and setup
			the special buffer. s:SetupBuf()
		Setup Function advantage
			| since the command will be defined in the main
			script you | can use script local functions
	Using a special filetype
		Principle
			| we can also use a new filetype and distribute a
			syntax and an ftplugin for this | filetype, the only
			thing needed in this case is to set the | filetype
			after creating the buffer
		Filetype advantage
			| better separations of different parts of your
			script. If | the main function of your plugin is
			not to have this | special buffer then it is nice
			to avoid clutering it.
	Things which needs to be done to setup the buffer
		The buffer should not be listed and does not correspond to
		a file
			* setlocal buftype=nofile -	  options always local
			to buffer * set nobuflisted * set bufhidden=delete *
			set nomodifiable
		Setup the syntax for this buffer
			| see :help syntax | This is usually done in two
			steps, first describe the | syntax groups using :syn
			commands then setup the | hilighting using :hi def
			link commands.	Usually it is | best to link the
			newly defined groups to predefine ones in | order
			to make the coloring work fine with colorschemes.
			| You'll find the list of predefined group by doing:
			| :help group-name
		Setup the special mappings
			| since we have chosen to use the set nomodifiable
			option | our buffer will never be in insert mode. All
			our mapping | are in Normal, Visual or operator
			pending, they should | therefore use the map, nmap,
			vmap and omap mapping command | plus the associated
			'nore' version.  I usually find it | better to use the
			'nore' version to avoid surprises due to | mapping
			in the user configuration.  | | We also want our
			mappings to be local to the special | buffer so all
			the commands will use the &lt;buffer&gt; modifier.
			| | Finally we want our mappings not to polute the
			status bar | so we use the &lt;silent&gt; modifier |
			| Putting all this together we end up with mapping
			commands | which look like: | noremap &lt;buffer&gt;
			&lt;silent&gt; {lhs} {rhs}
		Setup the special command
			| we will then setup special commands for this buffer.
			Like | for the mapping there are some precautions to
			take: | we don't want an error message if the command
			is defined | twice so we use the command! variant.  |
			We want a command local to our buffer wo we use the |
			-buffer attribute.  The rests of the command attributes
			|  and options depend on the actual command.  |  So
			our commands look like: |  command! -buffer {attr}
			{cmd} {rep} |  where attr is optional.

</pre></tip> </html> <Tip category="KVim">
<html><center>Toggle Search Highlighting</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=163">http://vim.sf.net/tip_view.php?tip_id=163</A><BR>

" Map H to toggle search highlighting map H :let &hlsearch =
!&hlsearch&lt;CR&gt;

</pre></tip> </html> <Tip category="KVim"> <html><center>Make
non-ASCII characters displayed on console</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=164">http://vim.sf.net/tip_view.php?tip_id=164</A><BR>

I had a problem with VIM on the FreeBSD console: it didn't display characters
like German umlauts correctly, but escaped them with a tilde. The solution
is to teach VIM about printable characters. I use the following on my .vimrc:

set isprint=@,128-255

</pre></tip> </html> <Tip category="KVim"> <html><center>Deleting
a buffer without closing the window</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=165">http://vim.sf.net/tip_view.php?tip_id=165</A><BR>

I'm not sure if this functionality is already within Vim, but I sometimes I
find it useful to keep a split window from closing when deleting a buffer.
This has already been discussed on the vim@vim.org mailing list.  However,
I feel this solution is a little easier to use.

" Put this into .vimrc or make it a plugin.  " Mapping :Bclose to some
keystroke would probably be more useful.  " I like the way buflisted()
behaves, but some may like the behavior " of other buffer testing functions.

command! Bclose call &lt;SID&gt;BufcloseCloseIt()

function! &lt;SID&gt;BufcloseCloseIt()
	let l:currentBufNum = bufnr("%") let l:alternateBufNum = bufnr("#")

	if buflisted(l:alternateBufNum)
		buffer #
	else
		bnext
	endif

	if bufnr("%") == l:currentBufNum
		new
	endif

	if buflisted(l:currentBufNum)
		execute("bdelete ".l:currentBufNum)
	endif
endfunction

</pre></tip> </html> <Tip category="KVim"> <html><center>Mapping
caps lock to esc in XWindows</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=166">http://vim.sf.net/tip_view.php?tip_id=166</A><BR>

(This originally appeared on the vim mailing list as post by Adam Monsen <A
HREF="http://groups.yahoo.com/group/vim/message/19856)">http://groups.yahoo.com/group/vim/message/19856)</A><BR>

If you want to completely swap caps lock and escape, you have to replace
the "Lock" on caps lock. Drop this file in your home dir:&lt;br&gt;
-----------start------------&lt;br&gt; ! Swap caps lock and escape&lt;br&gt;
remove Lock = Caps_Lock&lt;br&gt; keysym Escape = Caps_Lock&lt;br&gt;
keysym Caps_Lock = Escape&lt;br&gt; add Lock = Caps_Lock&lt;br&gt;
------------end-------------&lt;br&gt; and call it ".speedswapper". Then
open a terminal and type&lt;br&gt; $ xmodmap .speedswapper&lt;br&gt;
and you'll be twice as efficient in vim. Who needs caps lock anyway? The
swapping lasts for the duration of the X session, so you can put it in a
.xinitrc or similar startup file. As far as other people using my laptop,
I'd rather they didn't! Using a Dvorak layout might protect me even more... :)

</pre></tip> </html> <Tip category="KVim"> <html><center>Using
vim as a man-page viewer under Unix</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=167">http://vim.sf.net/tip_view.php?tip_id=167</A><BR>

To use vim as a man-page viewer involves setting an environment variable:

    sh, ksh:  export MANPAGER="col -b | view -c 'set ft=man nomod nolist'
    -" csh    :  setenv MANPAGER "col -b | view -c 'set ft=man nomod nolist' -"

Put one of the above two lines into your &lt;.profile&gt; or &lt;.login&gt;
file as appropriate for your shell.

The man pages will then be displayed with vim called as "view" and
will use the &lt;man.vim&gt; syntax highlighting.  I myself use some
additional highlighting which is enabled by putting the following file into
&lt;.vim/after/syntax/man.vim&gt;.  I usually use the &lt;astronaut&gt;
colorscheme (also available from this archive); those who use bright
backgrounds may find the colors selected for manSubSectionStart and
manSubSection something they'll want to change:

  ---------------------------------------------------------------------
" DrChip's additional &lt;man.vim&gt; stuff

syn match  manSectionHeading	"^\s\+[0-9]\+\.[0-9.]*\s\+[A-Z].*$"
contains=manSectionNumber syn match  manSectionNumber
"^\s\+[0-9]\+\.[0-9]*"		    contained syn region manDQString
start='[^a-zA-Z"]"[^", )]'lc=1	    end='"'	    contains=manSQString
syn region manSQString		start="[ \t]'[^', )]"lc=1	    end="'"
syn region manSQString		start="^'[^', )]"lc=1		    end="'"
syn region manBQString		start="[^a-zA-Z`]`[^`, )]"lc=1	    end="[`']"
syn region manBQSQString	start="``[^),']"		    end="''"
syn match  manBulletZone	transparent "^\s\+o\s" contains=manBullet
syn case    match syn keyword manBullet contained o syn match	manBullet
contained "\[+*]" syn match   manSubSectionStart  "^\*"   skipwhite
nextgroup=manSubSection syn match   manSubSection	".*$"	contained

hi link manSectionNumber    Number hi link manDQString	       String hi
link manSQString	 String hi link manBQString	    String hi
link manBQSQString	 String hi link manBullet	    Special hi
manSubSectionStart	 term=NONE cterm=NONE gui=NONE ctermfg=black
ctermbg=black guifg=navyblue guibg=navyblue hi manSubSection
term=underline cterm=underline gui=underline ctermfg=green guifg=green set ts=8
  ---------------------------------------------------------------------


</pre></tip> </html> <Tip category="KVim"> <html><center>Viewing
the actual XPM data in GVIM</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=168">http://vim.sf.net/tip_view.php?tip_id=168</A><BR>

GVIM has an excellent syntax highlighting for XPM images, but sometimes
it's useful to view the actual data. This can be achieved by searching for
everything, type in "/." and all characters will be highlighted and therefore
the old colouring is lost. To regain the normal highlighting you can search
for a non-existent sequence, like "/foo".

</pre></tip> </html> <Tip category="KVim"> <html><center>&lt;Tab&gt;
= &lt;C-I&gt; and &lt;Esc&gt; = &lt;C-[&gt;</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=169">http://vim.sf.net/tip_view.php?tip_id=169</A><BR>

     An FAQ on the vim users' mailing list is whether &lt;Tab&gt; and
     &lt;C-I&gt;
can be mapped to different things.  The answer is no.  As I understand it,
this is a low level issue:  &lt;Tab&gt; and &lt;C-I&gt; are different names
for the same ASCII code, and there is no way for vim to tell them apart.
Similarly, &lt;Esc&gt; and &lt;C-[&gt; are the same thing.

</pre></tip> </html> <Tip category="KVim"> <html><center>Repeating
a sequence of commands without defining a macro</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=170">http://vim.sf.net/tip_view.php?tip_id=170</A><BR>

Imagine.

You have just finished a complicated modification of a file, involving
numerous replace commands :%s/xxx/yyyy/g, and other ex commands.

Then you realize, you have done it a little bit wrong, and you have to begin
all the operation again, just to change one replace string, or do one more
operation "somewhere 10 commands ago".

Or you realize, you will have to do the same stuff tomorrow with another file.

or you realize, you want to perform the same sequence of commands, you have
typed a few days ago

You should have made it a macro (normal command q), but you haven't.

Nothing is lost yet.

You go to the command line (by typing :) and press Ctrl+F.  (Ctrl+F in other
modes scrolls the screen)

You get a temporary window, listing the history of command line.
It is possible to yank appropriate lines here, make a new file called
$VIMRUNTIME/macros/something.vim put those lines here, edit them and save

see :help cedit

Then you can call the macro using :source something.vim

You might want to set variable 'history' to a higher number then default in
your vimrc file like :set history=300 see :help history :help vimrc

</pre></tip> </html> <Tip category="KVim"> <html><center>Do
you know the "g/" and "g?" commands?</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=171">http://vim.sf.net/tip_view.php?tip_id=171</A><BR>

Directly from the Vim Todo list:

7   For Visual mode: Command to do a search for the string in the marked area.
    Only when less than two lines. Use "g/" and "g?".

In other words, a way to search for visually selected text !!  :-)

"==== vsearch.vim ====

" Visual mode search

vmap g/ :call VsearchPatternSave()&lt;cr&gt;/&lt;c-r&gt;/&lt;cr&gt; vmap
g? :call VsearchPatternSave()&lt;cr&gt;?&lt;c-r&gt;/&lt;cr&gt;

function! VsearchPatternSave()
  let l:temp = @@ normal gvy let @/ = substitute(escape(@@, '/\'), "\n",
  "\\\\n", "g") let @@ = l:temp unlet l:temp
endfunction

"==== END ====

Normally, this file should reside in the plugins directory and be
automatically sourced. If not, you must manually source this file using
':source vsearch.vim'.

In Visual mode, highlight the text for searching.  Then you can use the
default visual key mappings

g/ - search forwards g? - search backwards

Visual searches behave like normal searches.  The 'n' and 'N' commands
work as they should, and the search history correctly records each search.
Multi-line searches behave as they should (this corrects the 'yank-only'
method mentioned in the Vim help files).  Block visual searches do not
work yet.  Hopefully, someone can figure out a way to do this easily.

I've only tested this on Win2000 and Redhat Linux 7.1.	I'm not really clear
on how the carriage returns are dealt with on other systems.

Anyway, enjoy!

</pre></tip> </html> <Tip category="KVim"> <html><center>Using
Ispell on a highlighted region</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=172">http://vim.sf.net/tip_view.php?tip_id=172</A><BR>

Suppose you would like to use Ispell to check a word or region that you've
visually highlighted.  The following macro will do the job.  Just type
Shift-Insert while in visual mode.

vnoremap &lt;S-Insert&gt; &lt;C-C&gt;`&lt;v`&gt;s&lt;Space&gt;&lt;Esc&gt;mq:e
ispell.tmp&lt;CR&gt;i&lt;C-R&gt;"&lt;Esc&gt;:w&lt;CR&gt;:! xterm
-bg ivory -fn 10x20 -e ispell %&lt;CR&gt;&lt;CR&gt;:e
%&lt;CR&gt;&lt;CR&gt;ggVG&lt;Esc&gt;`&lt;v`&gt;s&lt;Esc&gt;:bwipeout!&lt;CR&gt;:!rm
ispell.tmp*&lt;CR&gt;`q"_s&lt;C-R&gt;"&lt;Esc&gt;

This is based on Chip Campbell's macro which uses Ispell on the whole file
(in normal mode).

noremap &lt;S-Insert&gt; :w&lt;CR&gt;:! xterm -bg ivory -fn 10x20 -e ispell
%&lt;CR&gt;&lt;Space&gt;:e %&lt;CR&gt;&lt;Space&gt;

Carl Mueller

</pre></tip> </html> <Tip category="KVim"> <html><center>Switch
between splits very fast (for multi-file editing)</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=173">http://vim.sf.net/tip_view.php?tip_id=173</A><BR>

I am a Web developer and I use Vim as my primary editor.

Most programming projects (and Web programming projects, in particular)
are spread out over multiple files, which you often want to have open
concurrently. If you don't already know, Vim supports this very well! Just use:

:sp name-of-another-file-to-edit

My problems were that (1) it took too long to move between files, and (2)
the files were taking up too much room on the screen.

(1) In order to move to the file in the split above my current window, I was
typing Ctrl-W, Up (move up a window) Ctrl-W, _ (maximize the menu). That's
four keystrokes (more if you count Ctrl and Shift), and they are all over
the keyboard. To help avoid this problem, I created this mapping in my .vimrc:

map &lt;C-J&gt; &lt;C-W&gt;j&lt;C-W&gt;_ map &lt;C-K&gt;
&lt;C-W&gt;k&lt;C-W&gt;_

Now I can hold down Ctrl and move between windows with the standard Vim
movement keys. Much, much quicker!

(2) By default, Vim displays the current line of each minimized file, which
(to me) isn't much help and takes up too much screen real estate. I use this
line in my .vimrc:

set wmh=0

This sets the minimum window height to 0, so you can stack many more files
before things get crowded. Vim will only display the filename.

Hope this helps those of you who are working on projects with large numbers
of files you're constantly flipping through. Happy Vimming!

</pre></tip> </html> <Tip category="KVim">
<html><center>Footnotes</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=174">http://vim.sf.net/tip_view.php?tip_id=174</A><BR>

ab (1
[1]&lt;esc&gt;:/^--\s/-1/&lt;cr&gt;o&lt;insert&gt;&lt;cr&gt;Footnotes:&lt;cr&gt;----------&lt;cr&gt;[1]
ab (2 [2]&lt;esc&gt;:/^Footnotes\:/+2/&lt;cr&gt;o&lt;insert&gt;[2]
ab (3 [3]&lt;esc&gt;:/^Footnotes\:/+3/&lt;cr&gt;o&lt;insert&gt;[3] ab
(4 [4]&lt;esc&gt;:/^Footnotes\:/+4/&lt;cr&gt;o&lt;insert&gt;[4] ab (5
[5]&lt;esc&gt;:/^Footnotes\:/+5/&lt;cr&gt;o&lt;insert&gt;[5]

</pre></tip> </html> <Tip category="KVim"> <html><center>how to make
VIM as ur default editor even without root ac.</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=175">http://vim.sf.net/tip_view.php?tip_id=175</A><BR>

hi, if u have installed vim in your home directory somewhere and u don't have a
root account, and you want to make VIM the default editor for anything u do.
i.e if ur using SQLplus and want to edit a sql command.  normally typing
edit brings up the vi editor and not vim editor.  to solve this problem.
define these three variables in your .profile VIM=&lt;base directory where
vim executable is placed&gt; VIMRUNTIME=&lt;base direcoty where vim runtimes
are kept&gt; EDITOR=$VIM/vim

note if u have installed vim with another name, say vim.exe then change
EDITOR=$VIM/vim to EDITOR=$VIM/vim.exe

source the .profile and viola. next time u start an editor from any program
u have the vim editor.

Njoy.

</pre></tip> </html> <Tip category="KVim">
<html><center>Autocheckout from perforce</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=176">http://vim.sf.net/tip_view.php?tip_id=176</A><BR>

The following code automatically checks out files from perforce when the
user modifies them. It first confirms the check-out with the user.

(Perforce is a commercial version control system.  I imagine this could be
modified for RCS, CVS, etc., but I don't use those.)

I'm a vim newbie -- I've used vi since 1984, but just started with vim a couple
days ago.  Color me impressed!	Please excuse any stupidity in the code..

Note that this function needs the "P4HOME" environment variable to be set.
I could extract it by invoking "p4 client", but I don't want to invoke p4
every time I start vim.  So I assume the user sets it in the environment.

" Set a buffer-local variable to the perforce path, if this file is under
the perforce root.  function IsUnderPerforce()
    if exists("$P4HOME")
	if expand("%:p") =~ ("^" . $P4HOME)
	    let b:p4path = substitute(expand("%:p"), $P4HOME, "//depot", "")
	endif
    endif
endfunction " Confirm with the user, then checkout a file from perforce.
function P4Checkout()
   if exists("b:p4path")
	if (confirm("Checkout from Perforce?", "&Yes\n&No", 1) == 1)
	    call system("p4 edit " . b:p4path . " &gt; /dev/null") if
	    v:shell_error == 0
		set noreadonly
	    endif
	endif
    endif
endfunction

if !exists("au_p4_cmd")
    let au_p4_cmd=1

    au BufEnter * call IsUnderPerforce() au FileChangedRO * call P4Checkout()
endif

</pre></tip> </html> <Tip category="KVim"> <html><center>Highlight
matching brackets as one moves in normal mode (plugin)</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=177">http://vim.sf.net/tip_view.php?tip_id=177</A><BR>

Check out <A HREF="http://www.erols.com/astronaut/vim/index.html#VimFuncs
for">http://www.erols.com/astronaut/vim/index.html#VimFuncs for</A><BR>
a plugin script which highlights matching brackets.  The script has two
always-on maps:
	\[i   : start [HiMtchBrkt] mode \[s   : stop [HiMtchBrkt] mode
The plugin will save all user maps and options that the plugin uses and will
restore them when the mode is stopped.

</pre></tip> </html> <Tip category="KVim"> <html><center>Making
a "derived" colorscheme without copy & paste</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=178">http://vim.sf.net/tip_view.php?tip_id=178</A><BR>

Suppose there's a colorscheme that you're pretty fond of, but hate one or
two particular aspects about.  For example, I love the "blue" colorscheme
that ships with vim, but I find it's colors for the non-active status line
to be unreadable.  Here's how to create a colorscheme which extends "blue"
without copying it to a new file and editing it.

In my ~/.vim/colors, I created a "my-blue.vim" file with these contents:

"these lines are suggested to be at the top of every colorscheme hi clear
if exists("syntax_on")
   syntax reset
endif

"Load the 'base' colorscheme - the one you want to alter runtime
colors/blue.vim

"Override the name of the base colorscheme with the name of this custom one
let g:colors_name = "my-blue"

"Clear the colors for any items that you don't like hi clear StatusLine hi
clear StatusLineNC

"Set up your new & improved colors hi StatusLine guifg=black guibg=white hi
StatusLineNC guifg=LightCyan guibg=blue gui=bold

That's all there is to it.

</pre></tip> </html> <Tip category="KVim">
<html><center>Simplify help buffer navigation</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=179">http://vim.sf.net/tip_view.php?tip_id=179</A><BR>

Vim is distributed with comprehensive help system, which has basic hyperlink
support - you can press &lt;C-]&gt; over |some subject| or 'some option'
to read more about particular term.

The following mappings simplify help buffer navigation: pressing s(or S)
will find next(previous) subject from cursor position pressing o(or O) will
find next(previous) option from cursor position pressing Enter will jump to
subject under cursor pressing Backspace will return from the last jump

Put them into help filetype plugin (like ~/.vim/ftplugin/help.vim on UNIX).

nmap &lt;buffer&gt; &lt;CR&gt; &lt;C-]&gt; nmap &lt;buffer&gt; &lt;BS&gt;
&lt;C-T&gt; nmap &lt;buffer&gt; o /'[a-z]\{2,\}'&lt;CR&gt; nmap &lt;buffer&gt;
O ?'[a-z]\{2,\}'&lt;CR&gt; nmap &lt;buffer&gt; s /\|\S\+\|&lt;CR&gt; nmap
&lt;buffer&gt; S ?\|\S\+\|&lt;CR&gt;

</pre></tip> </html> <Tip category="KVim"> <html><center>Reload
your filetype/syntax plugin</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=180">http://vim.sf.net/tip_view.php?tip_id=180</A><BR>

Ever tried to write/debug your own  filetype/syntax plugin?

It's an iterative process which involves editing plugin code and testing it
on some sample file. To see changes you made in your plugin simply do :e
on sample file.  This will force Vim to reload all buffer-specific files,
including your plugin.

</pre></tip> </html> <Tip category="KVim">
<html><center>get the vim patched source</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=181">http://vim.sf.net/tip_view.php?tip_id=181</A><BR>

Hi, there has been a number of person (including) asking in the vim list how
to keep up with Bram's incredible bug correction and patch writing skills, but
there is a great way to do this!  Use the cvs source which is available at <A
HREF="http://sourceforge.net/cvs/?group_id=8">http://sourceforge.net/cvs/?group_id=8</A><BR>
it is kept up to date and its a lot easier than applying all the patch
in order.  Benoit

</pre></tip> </html> <Tip category="KVim"> <html><center>Keep
your cursor centered vertically on the screen</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=182">http://vim.sf.net/tip_view.php?tip_id=182</A><BR>

i hope i don't hear a collective 'DUH!' from around the world but i just
did this and i think it's kinda cool.

in your .vimrc add...

map j jzz map k kzz

so whenever you go up or down, vim does that and then re-centers.  obviously it
doesn't work when you page up/ down.

</pre></tip> </html> <Tip category="KVim"> <html><center>Select
a buffer from those matching a pattern</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=183">http://vim.sf.net/tip_view.php?tip_id=183</A><BR>

The :bu command will take a pattern as an argument and jump to the matching
buffer.  However, it's not very helpful if there is more than one buffer
matching the pattern.  In that case, it will jump to the first match, which
may not be what you want.  The following function and user-command will
print a list of the matching buffers in the command-line area, and allow
you to select one of the matching buffers by number.

"Select from buffers matching a certain pattern "the 'pattern' argument
shouldn't be prepended with a slash

function! BufSel(pattern)
   let bufcount = bufnr("$") let currbufnr = 1 while currbufnr &lt;= bufcount
      if(bufexists(currbufnr))
	 let currbufname = bufname(currbufnr) if(match(currbufname, a:pattern)
	 &gt; -1)
	       echo currbufnr . ":	". bufname(currbufnr)
	 endif
      endif let currbufnr = currbufnr + 1
   endwhile let desiredbufnr = input("Enter buffer number: ")
   if(strlen(desiredbufnr) != 0)
      exe ":bu ". desiredbufnr
   endif
endfunction

"Bind the BufSel() function to a user-command command! -nargs=1 Bs :call
BufSel("&lt;args&gt;")

</pre></tip> </html> <Tip category="KVim"> <html><center>How
to obscure text instantaneously</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=184">http://vim.sf.net/tip_view.php?tip_id=184</A><BR>

Hi, Lets say your writing some imp. doc. and your colleague comes along. you
don't wan't him to see what you are typing.  so u start fumbling to type
:wq! or switch with Alt-TAB. etc.  but wouldn't it be nice to just obsucre the
text temporarily, so that u don't have to quit or swith to another application
using Alt-tab.	(and if u don;t have any other window open u can;t even use
alt-tab) well rot-13 comes to help. vim has a built in rot-13 encoder.

jut put the follwoing in your .vimrc

map &lt;F3&gt; ggVGg?

so next time some body comes along just press &lt;F3&gt; and all the buffer
will be rot-13 encoded. to decode just press &lt;f3&gt; again.	Njoy

</pre></tip> </html> <Tip category="KVim"> <html><center>Make vim the
editor for files with unregistered extensions in Windows</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=185">http://vim.sf.net/tip_view.php?tip_id=185</A><BR>

Normally in Windows, if you try to "launch" a file whose extension is not
registered with the system, the OS will prompt you for what editor you would
like to use to open the file.  A much more appealing solution, in my mind,
is to make vim the default editor for any unregistered extension.

To set vim up as the default editor for unregistered extensions, follow
these steps: 1. Copy the following into a file named unregistered.reg
-------------begin unregistered.reg----------------- REGEDIT4
[HKEY_CLASSES_ROOT\Unknown\shell\Open\Command] @="d:\\program
files\\vim\\vim60\\gvim.exe \"%1\"" -------------end
unregistered.reg-----------------

2. Import unregistered into your registry.  This can be done in vim by
executing the following :!regedit "unregistered.reg"

Disclaimer: This has been tested only on NT4.

</pre></tip> </html> <Tip category="KVim">
<html><center>Making search powerful</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=186">http://vim.sf.net/tip_view.php?tip_id=186</A><BR>

My tip is just a bunch of mappings that can be used while searching.

</pre></tip> </html> <Tip category="KVim">
<html><center>Making search powerful</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=187">http://vim.sf.net/tip_view.php?tip_id=187</A><BR>

(Sorry, I think I accidentally added an incomplete tip)

My tip is just a bunch of mappings that can be used while searching.
What it does?
  o. Extend your current search. (kinda emacs search where you can search
  each occurences
      one by one and go back to the cursor position.
  o. Scroll/position during mapping.  o. Other miscellaneous stuffs ;) read on

How to use?
   o. copy and paste the mappings into a file o. open vim (like vim .profile)
   o. :so &lt;saved-file&gt; o. start using the mappings

Note:
   In case these mappings dont work run like, 'vim -u NONE -U NONE -c
   "so the-saved-file.vim"'

   Some of my mappings override the default vim bindings. (like Ctrl-A,
   Ctrl-Q). I selected those because, I feel by taking those I can do all
   the search stuff with my left hand.

   One thing I did not like with this is, I usually miss the "search hit
   bottom" message. I could have handled that by complicating the current
   mappings, but I preferred to make it simple

Mappings Used /		 =&gt; regular forward search start ?	      =&gt;
regular backward search start Rest of the mappings are used during search
Ctrl-A	=&gt; search again forward (In normal mode, search forward with
the word under cursor) Ctrl-Q  =&gt; search again backward (in normal mode,
search backward with the word under cursor) Ctrl-X  =&gt; restore cursor (use
at any point of time/during-any-operation mentioned during searching) Ctrl-F
=&gt; search with the word under cursor Ctrl-G	=&gt; incrementally add the
letters following the search pattern (in current line) Ctrl-T Ctrl-T =&gt;
search for the exact Ctrl-T Ctrl-Y =&gt; search partial (just strips \&lt;
and \&gt;) Ctrl-E  =&gt; scroll up during searching Ctrl-Y  =&gt; scroll down
during searching Ctrl-Z Ctrl-Z =&gt; position the cursor to mid of screen
(like zz in normal) Ctrl-Z Ctrl-A =&gt; position the cursor to top of screen
(like zt in normal) Ctrl-Z Ctrl-X =&gt; position the cursor to bottom of
screen (like zb in normal)

Misc: Ctrl-K during search save the current matching line Ctrl-K in normal
mode pastes the saved line

C mappings Ctrl-V Ctrl-G search for the global variable of the search
pattern/word under cursor Ctrl-V Ctrl-H search for the local variable of
the search pattern/word under cursor

" --- cut n paste from here to end of document --- se nocp incsearch " core
mappings noremap  / mg/ noremap  ? mg?	ounmap / ounmap ?  noremap &lt;C-A&gt;
mg"gyiw/&lt;C-R&gt;g cnoremap &lt;C-A&gt; &lt;CR&gt;/&lt;Up&gt; cnoremap
&lt;C-X&gt; &lt;CR&gt;`g cnoremap &lt;C-Q&gt; &lt;CR&gt;?&lt;Up&gt;

" extending current search mappings cnoremap &lt;C-F&gt;
&lt;CR&gt;yiw&lt;BS&gt;/&lt;C-R&gt;" cnoremap &lt;C-G&gt;
&lt;CR&gt;y/&lt;Up&gt;/e+1&lt;CR&gt;&lt;BS&gt;/&lt;C-R&gt;=escape(@",'.*\/?')&lt;CR&gt;

" miscellaneous: copy current line during search and later paste in NORMAL
mode cnoremap &lt;C-K&gt; &lt;CR&gt;"hyy?&lt;Up&gt;&lt;CR&gt;/&lt;Up&gt;
noremap &lt;C-K&gt; "hp

" exact/partial search mappings cnoremap &lt;C-T&gt;&lt;C-T&gt;
&lt;Home&gt;\&lt;&lt;C-End&gt;\&gt; cnoremap &lt;C-T&gt;&lt;C-Y&gt;
&lt;Home&gt;&lt;Del&gt;&lt;Del&gt;&lt;End&gt;&lt;Del&gt;&lt;Del&gt;

" C global/local variable search mappings noremap &lt;C-V&gt;&lt;C-G&gt;
mgyiw&lt;CR&gt;gg/\&lt;&lt;C-R&gt;"\&gt; noremap &lt;C-V&gt;&lt;C-H&gt;
mgyiw?^{&lt;CR&gt;/\&lt;&lt;C-R&gt;"\&gt; cnoremap &lt;C-V&gt;&lt;C-G&gt;
&lt;CR&gt;yiwgg/\&lt;&lt;C-R&gt;"\&gt; cnoremap &lt;C-V&gt;&lt;C-H&gt;
&lt;CR&gt;yiw?^{&lt;CR&gt;/\&lt;&lt;C-R&gt;"\&gt;

" positioning/scrolling during search mappings cnoremap &lt;C-E&gt;
&lt;CR&gt;mt&lt;C-E&gt;`t&lt;BS&gt;/&lt;Up&gt; cnoremap &lt;C-Y&gt;
&lt;CR&gt;&lt;C-Y&gt;&lt;BS&gt;/&lt;Up&gt; cnoremap &lt;C-Z&gt;&lt;C-A&gt;
&lt;CR&gt;zt&lt;BS&gt;/&lt;Up&gt; cnoremap &lt;C-Z&gt;&lt;C-X&gt;
&lt;CR&gt;zb&lt;BS&gt;/&lt;Up&gt; cnoremap &lt;C-Z&gt;&lt;C-Z&gt;
&lt;CR&gt;zz&lt;BS&gt;/&lt;Up&gt;

" VISUAL mappings vnoremap / ymg/&lt;C-R&gt;=escape(@",'.*\/?')&lt;CR&gt;
vnoremap ? ymg?&lt;C-R&gt;=escape(@",'.*\/?')&lt;CR&gt;

</pre></tip> </html> <Tip category="KVim"> <html><center>Searching
for more than one word at the same time.</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=188">http://vim.sf.net/tip_view.php?tip_id=188</A><BR>

Did you know that with VIM u can search for more than one word with a single
command.  say you want to search all occurances of "bill" or "ted", or "harry"
in a text.  in normal mode do the following.  /\(bill\)\|\(ted\)\|\(harry\)
&lt;Enter&gt;

this will match all instances of either "bill", or "ted", or "harry" in your
text. the key is the \(\) and \| operators.  \(\) group characters in a word
and \| is for ORing.

this is so cool u can even use it for replacing text.  to replace all
instances of "bill" or "ted" or "harry" with "greg" do the following
:%s/\(bill\)\|\(ted\)\|\(harry\)/greg/g &lt;enter&gt; (note :- if u have
set the option "gdefault" u don't need the "g" at the end of the above command)

I don't know of any other editor which can do this, with so much ease.
Rock on VIM Njoy

</pre></tip> </html> <Tip category="KVim"> <html><center>Make
Ctrl-Backspace delete previous word (like GTK inputs)</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=189">http://vim.sf.net/tip_view.php?tip_id=189</A><BR>

Stuff this into your ~/.gvimrc and then you'll be able to type
Control-Backspace to delete the previous word.	I had gotten so used to
C-BS working a certain way in all my editors with a ceezy input area (like
mozilla/galeon, gabber, etc...), that I wanted the same behaviour when I
used gvim.

" map control-backspace to delete the previous word :imap &lt;C-BS&gt;
&lt;Esc&gt;vBc

Simple, I know, but reasonably useful.

--Robert

</pre></tip> </html> <Tip category="KVim"> <html><center>XP &gt;
I-Explorer &gt; HTML Editor &lt; REG files</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=190">http://vim.sf.net/tip_view.php?tip_id=190</A><BR>

The issue is permitting other programs, besides NOTEPAD, be the HTML editor
under Internet Explorer.  (Adding "Edit" as a New Action in the publicly
exposed Files Types for HTM/L does NOT do the job.)

Given below are two REG files for vim.	Just cut 'em up where indicated.
They have been tested under Windows XP.

-------------------------------------------------------CUT HERE---------------
Windows Registry Editor Version 5.00

; GOAL: Set gvim as HTML editor in Internet Explorer 6.0 ; Vim version :
6.0 ; Windows version: XP ; EASY USAGE: name this file iex-vim60.reg and
double click on it ; Hard Usage: IMPORT this file using REGEDIT.EXE found
in c:\WINDOWS ; Last modified date : Dec 16, 2001

; gvim is expected in "C:\Program Files\Vim\vim60\gvim.exe" ; Be sure to
also reset Explorer&gt;Tools&gt;Internet Options&gt;Programs

; Microsoft documentation ; <A
HREF="http://msdn.microsoft.com/workshop/browser/configuration/clientreg/clientregistrylayout.asp">http://msdn.microsoft.com/workshop/browser/configuration/clientreg/clientregistrylayout.asp</A><BR>

; Add Vim in the list of supported HTML editors
[HKEY_CLASSES_ROOT\.htm\OpenWithList\Vim]

[HKEY_CLASSES_ROOT\.htm\OpenWithList\Vim\shell]

[HKEY_CLASSES_ROOT\.htm\OpenWithList\Vim\shell\edit]

[HKEY_CLASSES_ROOT\.htm\OpenWithList\Vim\shell\edit\command] @="\"C:\\Program
Files\\Vim\\vim60\\gvim.exe\" \"%1\""

; Do NOT add to .html, registry for .htm type suffices
;[HKEY_CLASSES_ROOT\.html\OpenWithList\Vim]

;[HKEY_CLASSES_ROOT\.html\OpenWithList\Vim\shell]

;[HKEY_CLASSES_ROOT\.html\OpenWithList\Vim\shell\edit]

;[HKEY_CLASSES_ROOT\.html\OpenWithList\Vim\shell\edit\command]
;@="\"C:\\Program Files\\Vim\\vim60\\gvim.exe\" \"%1\""

; OPTIONAL: Within Internet Explorer "View Source" with gvim
; but prefer to use Edit button (got to add this) on Toolbar
;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Internet Explorer\View Source Editor]

;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Internet Explorer\View Source
Editor\Editor Name] ;@="C:\\Program Files\\Vim\\vim60\\gvim.exe"

; ============================================= EOF

-------------------------------------------------------CUT HERE---------------
Windows Registry Editor Version 5.00

; GOAL: UNINSTALL gvim as HTML editor in Internet Explorer 6.0 ; Vim version :
6.0 ; Windows version: XP ; EASY USAGE: name this file iex-vim60-uninstall.reg
and double click on it ; Hard Usage: IMPORT this file using REGEDIT.EXE
found in c:\WINDOWS ; Last modified date : Dec 16, 2001

; gvim is expected in "C:\Program Files\Vim\vim60\gvim.exe" ; Be sure to
also reset Explorer&gt;Tools&gt;Internet Options&gt;Programs

; Microsoft documentation ; <A
HREF="http://msdn.microsoft.com/workshop/browser/configuration/clientreg/clientregistrylayout.asp">http://msdn.microsoft.com/workshop/browser/configuration/clientreg/clientregistrylayout.asp</A><BR>

[-HKEY_CLASSES_ROOT\.htm\OpenWithList\Vim]

[-HKEY_CLASSES_ROOT\.html\OpenWithList\Vim]

[-HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Internet Explorer\View Source Editor]

; ============================================= EOF
-------------------------------------------------------CUT HERE---------------

Happy Vimming...

</pre></tip> </html> <Tip category="KVim">
<html><center>Transposing</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=191">http://vim.sf.net/tip_view.php?tip_id=191</A><BR>

You can easily move lines with these maps using &lt;C-Up&gt; and &lt;C-Down&gt;
(only in GUI version :( ) (Works in normal, insert, and visual mode, but
you can't add a count to them) " Transposing lines nmap &lt;C-Down&gt;
:&lt;C-u&gt;move .+1&lt;CR&gt; nmap &lt;C-Up&gt; :&lt;C-u&gt;move .-2&lt;CR&gt;

imap &lt;C-Down&gt; &lt;C-o&gt;:&lt;C-u&gt;move .+1&lt;CR&gt; imap &lt;C-Up&gt;
&lt;C-o&gt;:&lt;C-u&gt;move .-2&lt;CR&gt;

vmap &lt;C-Down&gt; :move '&gt;+1&lt;CR&gt;gv vmap &lt;C-Up&gt; :move
'&lt;-2&lt;CR&gt;gv

" Transpose chars (like Ctrl-T in emacs, shell...)  imap &lt;C-F&gt;
&lt;Esc&gt;Xpa

</pre></tip> </html> <Tip category="KVim">
<html><center>Latex Help for VIM</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=192">http://vim.sf.net/tip_view.php?tip_id=192</A><BR>

LaTeX Help for aucTeX `translated' as vim help file.

Installing

:help add-local-help

</pre></tip> </html> <Tip category="KVim"> <html><center>Insert
the current filename at cursor postion.</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=193">http://vim.sf.net/tip_view.php?tip_id=193</A><BR>

I found this one good for when I was starting to learn Java, it simply inserts
the current filename, at the cursor position, when you are in insert mode.
Honestly, its a mish-mash of some other tips I found here, but I thought it
might be useful.

imap \fn   &lt;C-R&gt;=expand("%:t:r")&lt;CR&gt;

Enjoy!

</pre></tip> </html> <Tip category="KVim">
<html><center>Inserting text in multiple lines</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=194">http://vim.sf.net/tip_view.php?tip_id=194</A><BR>

Do you know the I key in visual-block mode?

Suppose you have let a=2 let b=3 let c=4

You want to make these variables script-wise. Then you move to over a, hit
&lt;C-v&gt;, press jj and now press I.	You will be in insert mode before a
Now enter s:&lt;Esc&gt;, and when you press &lt;Esc&gt;, b and c will have
the s: prefix too.  See |v_b_I|

Happy vimming!	Gergely Kontra

</pre></tip> </html> <Tip category="KVim">
<html><center>Switching between files</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=195">http://vim.sf.net/tip_view.php?tip_id=195</A><BR>

When you edit multiple files, you often need to change windows.  You can set
up vim in windows and gvim to switch between windows with the commonly used
Ctrl-Tab and Ctrl-Shift-Tab The mappings nmap &lt;C-Tab&gt; &lt;C-w&gt;w
nmap &lt;C-S-Tab&gt;&lt;C-w&gt;W (They wrap around) See also |Ctrl-w|

</pre></tip> </html> <Tip category="KVim"> <html><center>FileName
Completion in Shell Scripts</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=196">http://vim.sf.net/tip_view.php?tip_id=196</A><BR>

In shell scripts, you often define environment variables for diff directory
names.	i.e.  JAVA_HOME=/opt/java/jdk1.4 PATH=/usr/local/bin:/bin....

Normally typing Ctrl-X Ctrl-F is used to complete FileName under cursor.
But this does not work if used on lines given above.  This is because vim
treats "=" sign as a valid filename character.	Since the actual possibility
of "=" being in any filename is very less, this char can be removed from
the list of valid filename char.

set isfname-==

putting the above line in .vimrc will remove "=" from the list of valid
filename chars.  thus u can easyly complete filenames using &lt;Ctrl-X&gt;
&lt;Ctrl-F&gt; Njoy

</pre></tip> </html> <Tip category="KVim"> <html><center>Open
file in already running vim from elsewhere</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=197">http://vim.sf.net/tip_view.php?tip_id=197</A><BR>

If you want edit new file, and you  want do it	in alrady running vim,
instead of launching another instance, you may use --remote argument:

gvim first_file gvim --remote +split first_file

:he --remote It requires X windows (but works in terminal version of vim
there too) or MS windows and built-in client-server mechanism. If there are
several instances of vim already running, you may choose to which you talk
using --servername :help --servername

</pre></tip> </html> <Tip category="KVim"> <html><center>Pasting
code with syntax coloring in emails</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=198">http://vim.sf.net/tip_view.php?tip_id=198</A><BR>

When sending code snippets or diffs to your colleagues either for code review
or for something else as email, how nice and clear it will be if you can
paste it with the Vim syntax highlighting? I am sure they will be impressed
and feel much easier to read the code. It is also very easy and fast (once
you practice it) to do this.

This probably works only on windows and requires you to use Internet Explorer
and an email client that understand RTF content coming from clipboard, such
as Outlook or Outlook Express. At least that would make the process faster. I
haven't tried on any other combination though. This is what you need to do:

- Open the file containing the code/code snippet/diff etc. in gvim. If you
use dark background for GVim (like me), then I would suggest you to change
your color scheme temporarily to something else that has a white background
or just use the "-U NONE" as below:

    gvim -U NONE &lt;file&gt;

- Convert the file into HTML by using the following command at the colon
prompt as below:

    :runtime syntax/2html.vim

- The above step will open a new window with the HTML content in it. You might
want to just save it with the suggested name or write into a temporary file as:

    :w! c:/tmp/t.html

- Open the IE browser window and open the above temp file "c:/tmp/t.html".
- Now you select all (press ^A) and copy it (^C).  - You are ready to paste
it with syntax coloring in any application that accepts RTF content from
clipboard, including Outlook or Outlook Express mail composing window.

</pre></tip> </html> <Tip category="KVim"> <html><center>maximize
window and return to previous split structure</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=199">http://vim.sf.net/tip_view.php?tip_id=199</A><BR>

Say you have layed out a complex window split structure, and want to
temporarily open 1 window with max dimensions, but don't want to lose your
split structure.  The following function and mappings let you toggle between
the split windows and on window maximized. The mappings prevent the default
behavior of calling :only and losing your finely tuned splits.

Put this bit in your vimrc file, change mappings if you don't want to override
the defaults:

nnoremap &lt;C-W&gt;O :call MaximizeToggle ()&lt;CR&gt; nnoremap &lt;C-W&gt;o
:call MaximizeToggle ()&lt;CR&gt; nnoremap &lt;C-W&gt;&lt;C-O&gt; :call
MaximizeToggle ()&lt;CR&gt;

function! MaximizeToggle()
	if exists("s:maximize_session")
		source s:maximize_session call delete(s:maximize_session)
		unlet s:maximize_session let &hidden=s:maximize_hidden_save
		unlet s:maximize_hidden_save
	else
		let s:maximize_hidden_save = &hidden let s:maximize_session =
		tempname() set hidden mksession! s:maximize_session only
	endif
endfunction

</pre></tip> </html> <Tip category="KVim"> <html><center>Bouncing
Parentheses (during insertion)</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=200">http://vim.sf.net/tip_view.php?tip_id=200</A><BR>

When one is inserting parentheses some folks like to see the cursor bounce
off the matching parenthesis.  To do that, put the following map into your
&lt;.vimrc&gt; file:

    inoremap ) )&lt;c-o&gt;%&lt;c-o&gt;:sleep
    500m&lt;CR&gt;&lt;c-o&gt;%&lt;c-o&gt;a

Adjust the time delay (its 500 milliseconds above) to suit your needs.

</pre></tip> </html> <Tip category="KVim">
<html><center>The meaning of life</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=201">http://vim.sf.net/tip_view.php?tip_id=201</A><BR>

Use this tip if you need to discover the meaning of life, the universe
and everything.

Simply do: :h 42

</pre></tip> </html> <Tip category="KVim">
<html><center>debugging window autocommands</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=202">http://vim.sf.net/tip_view.php?tip_id=202</A><BR>

Don't know how people debug autocommands, but I just found out that you can
debug (at least) those that result due to window close by just doing a debug
quit, i.e.,

:debug quit

Vim will let you step into the autocommands. Try it to believe.

</pre></tip> </html> <Tip category="KVim">
<html><center>Make make more helpful</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=203">http://vim.sf.net/tip_view.php?tip_id=203</A><BR>

I find this a very useful command to use.  Add the below 4 lines to your vimrc.
Then instead of "make" use "Make".

" Command Make will call make and then cwindow which " opens a 3 line error
window if any errors are found.  " if no errors, it closes any open cwindow.
:command -nargs=* Make make &lt;args&gt; | cwindow 3

</pre></tip> </html> <Tip category="KVim"> <html><center>Some
mappings for using cscope with vim.</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=204">http://vim.sf.net/tip_view.php?tip_id=204</A><BR>

These mappings can make using cscope a fun. You can copy the word under the
cursor in one window, and search for it from other window.

" Copy and paste the word under cursor map &lt;silent&gt; &lt;C-Space&gt;
:let@m=expand("&lt;cword&gt;")&lt;CR&gt;

" Use the C-Space word as the search criterion map &lt;C-F6&gt; :cscope
find s &lt;C-R&gt;=@m&lt;CR&gt;&lt;CR&gt; map &lt;C-F5&gt; :cscope find
c &lt;C-R&gt;=@m&lt;CR&gt;&lt;CR&gt; map &lt;C-F7&gt; :cscope find g
&lt;C-R&gt;=@m&lt;CR&gt;&lt;CR&gt;

</pre></tip> </html> <Tip category="KVim">
<html><center>Computing a sum of numbers in vim</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=205">http://vim.sf.net/tip_view.php?tip_id=205</A><BR>

"Sometimes you need to sum a some numbers in vim.  There *are* some plugins
"that can do the job.  But what if the numbers are not in a columns or are on
"the same line or are sacttered all across the file? You might also need to
"sum all the numbers in file that look like '1234$', or '54565 Eu'  ignoring
others.  " "There is a very simple trick, using (my favourite) command ":s "
"First you define following function

:let g:S=0		"In global variable S we later find the result

:function! Sum(number)		"The function is defined with a '!',
				"so it does not complain during debugging
				"when you are redefining the function
	:let g:S=g:S+a:number	"we accumulate the result in global variable
	S :return a:number	  "function returns the argument, so after a :s
				"command the text remains the same
:endfunction

"you can do issue those few commands from a command line, "or create a small
file and put it into your plugin directory, "or write those few commands
into a file end issue a command :so %

"how to use this little function: "let's suppose you have a simple
column of numbers like " "10 "20 "30 " "you issue command like: :let S=0
:%s/[0-9]\+/\=Sum(submatch(0))/ "the command finds the first number on the
line and adds it to the S " "the result is displayed :echo $S

"!!!! don't forget to do :let g:S=0 "before use.

"you can also use \zs and \ze atoms in a regular expression to "delimit the
number, so submatch(0) returns only a number and "the text remains unchanged
after 'substitute'

"for starter on the wonderfull world of regular expressions see: :help
usr_27.txt

"for the definition of the search pattern see :help :s :help pattern

"for replacement strings begining with \= and special function submatch(0)see
:help sub-replace-special

"for the *ultimate* guide through the world of regular expressions see book:
"Mastering Regular Expressions "Powerful Techniques for Perl and Other Tools
"by Jeffrey E.F. Friedl "from O'REILLY

"the book does not write about vim, yet here you can learn that ":s command
is the most powerfull command you can find in a text editor.  "(with the
possible exception of :global command)

</pre></tip> </html> <Tip category="KVim"> <html><center>Highlight
doubled word errors in text</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=206">http://vim.sf.net/tip_view.php?tip_id=206</A><BR>

An error I sometimes make while working on a LaTeX file is the repetition of
a word as in "the the". Most often, such doubled words come about through
a careless edit. Doubled words are hard to spot when the first word of the
doubled pair is the last word on one line, and the second word of the pair
is the the first word on the next line. There is an example of such an error
in the last sentence. Vim's syntax mechanism can be used to highlight doubled
words as an error.

To obtain this highlighting for TeX and LaTeX files, place the following
two lines:

       syn match texDoubleWord "\c\&lt;\(\a\+\)\_s\+\1\&gt;" hi def link
       texDoubleWord Error

in a file called tex.vim in the directory that shows up last in your
runtimepath (:set runtimepath? to check). This will often be either
~/.vim/after/syntax/tex.vim or $VIM/vimfiles/after/syntax/tex.vim

The same effect can be obtained for files of a different filetype, say html,
by putting the same lines in a file called html.vim in the same location.

For more on the runtimepath, :he runtimepath.  For more on syntax highlighting,
:he syntax

</pre></tip> </html> <Tip category="KVim"> <html><center>editing
databases with Vim/Perl/DBI</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=207">http://vim.sf.net/tip_view.php?tip_id=207</A><BR>

Perl's Data-Base-Independent (DBI) module provides programming language
level access to a lot of databases.

Vim hosts an embedded Perl interpreter. So it is only a matter of some key
strokes to interactively issue DB commands from within Vim or to search,
edit, and replace database contents including retrieval and storage. Of course
"create table" scripts can be worked upon in Vim as well as storing recurring
patterns in Vim functions or Perl modules.

Prerequisites: Vim needs to be compiled with Perl support enabled. See the
|if_perl.txt| manual page! The CPAN module DBI as well as an appropriate
database driver has to be installed with Perl in order to execute these
Vim commands:

" connect to perl's dbi module: :perl use dbi;

" connect to the database: :perl $dbh = dbi-&gt;connect(
"DBI:mysql:$DBNAME:$HOST",$USER,$PASSWORD,
					{ raiseerror =&gt; 1});

" perform a simple query: :perl $result = $dbh-&gt;selectall_arrayref("show
tables;");

" insert the list of tables into the current buffer's top: :perl
$curbuf-&gt;Append(0, map($_-&gt;[0], @{$result}));

In MySql the command "show tables;" results in a list of table names. Inserted
into a Vim buffer this results in one line per table.

You can find more on my web page <A
HREF="http://members.chello.at/intelliware/dbEdit">http://members.chello.at/intelliware/dbEdit</A><BR>

</pre></tip> </html> <Tip category="KVim"> <html><center>Alter
the display of buffers in the buffers menu</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=208">http://vim.sf.net/tip_view.php?tip_id=208</A><BR>

If you use the buffers menu, here's where you can change how the buffernames
are displayed:

menu.vim, function s:BMMunge

OLD:   let name2 = name2 . ' (' . a:bnum . ')'

displays:

  .vimrc (1) menu.vim (2)

NEW:	let name2 = '&' . a:bnum . '. ' . name2

displays

  1. .vimrc 2. menu.vim
(with the 1 and the 2 underlined)

which is more useful, because you can (almost) always pick the buffer you
want with one keystroke, the buffernumber, until you get to buffer 10 anyway.

Roger

</pre></tip> </html> <Tip category="KVim">
<html><center>backtracking your movements in a file</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=209">http://vim.sf.net/tip_view.php?tip_id=209</A><BR>

If you are jumping from one line to another a lot.  You may find the "Ctrl-o"
command handy.	Usually u can set markers in a buffer to keep track of your
movements.  but Ctrl-o makes it even easier. it takes you back sequentially
to all your previous cursor locations in a buffer.  just press ctrl-o in
normal mode and u will go to your last cursor position.

Njoy

</pre></tip> </html> <Tip category="KVim">
<html><center>compiling the actual file with gcc</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=210">http://vim.sf.net/tip_view.php?tip_id=210</A><BR>

if you use  set makeprg=gcc\ -o\ %&lt;\ % in your .vimrc, and your actual
file is file.c,  then :make will compile file.c with the output file. (gcc
file.c -o file).

</pre></tip> </html> <Tip category="KVim">
<html><center>Rotate color themes</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=211">http://vim.sf.net/tip_view.php?tip_id=211</A><BR>

This tip is for those who like to change their vim color themes pretty often.
I like different themes just for a change in my work environment.  To achieve
this just add the following to your .vimrc or _vimrc file.

let themeindex=0 function! RotateColorTheme()
	let y = -1 while y == -1
		let colorstring =
		"#blue.vim#elflord.vim#evening.vim#koehler.vim#murphy.vim#pablo.vim#ron.vim#"
		let x = match(colorstring,"#",g:themeindex) let y =
		match(colorstring,"#",x+1) let g:themeindex = x+1 ":echo x
		y g:themeindex if y == -1
			let g:themeindex = 0
		else
			let themestring = strpart(colorstring,x+1,y-x-1)
			echo("Setting Theme to-&gt; ".themestring) return
			":so $VIMRUNTIME/colors/".themestring
		endif
	endwhile
endfunction

Change the value of colorstring above by changing the line let colorstring =
"#blue.vim#elflord.vim#evening.vim#koehler.vim#murphy.vim#pablo.vim#ron.vim#"
You can add your favorite color themes in this string so that you can rotate
between them.  Just make sure that any string that you add is in between the #
as shown above.  Just follow the format above and things will work.

Then assign a key to roate the theme.  map &lt;F8&gt; :execute
RotateColorTheme()

Dunno if there are better ways to do the same.	I just did a "help eval"
and wrote the above.

</pre></tip> </html> <Tip category="KVim"> <html><center>Setting
file attributes without reloading a buffer</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=212">http://vim.sf.net/tip_view.php?tip_id=212</A><BR>

While creating scripts and others executable files with Vim it is needed to
set UNIX executable bit on the file.  You can do this from inside Vim with
:!chmod a+x %. The % represents current buffer's filename.  The problem is
that Vim will notice attribute changes and prompt you to reload a file. If
you do this, your undo history for the file will be lost.

The following function facilitate changing executable attributes without
reloading a buffer.  Thanks to Bram for the algorithm for this function.

fun! SetExecutableBit()
	let fname = expand("%:p") :checktime exec "au FileChangedShell
	" . fname . " :echo" :silent !chmod a+x % :checktime exec
	"au! FileChangedShell " . fname
endfun

" Create an EX command that will call the function.  command -nargs=0 Xbit
call SetExecutableBit()

Now you can type :Xbit to make the file executable!

</pre></tip> </html> <Tip category="KVim">
<html><center>delet all lines containt TXT</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=213">http://vim.sf.net/tip_view.php?tip_id=213</A><BR>

I needed this one when I was editing an ldif file:

I needed to delete all lines containing "profile":

:g/profile/d

very handydandy

</pre></tip> </html> <Tip category="KVim">
<html><center>Current buffer based menus</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=214">http://vim.sf.net/tip_view.php?tip_id=214</A><BR>

If you have different menus for different filetypes, and you want to have
only the menu relevant to current buffer displayed, you can use this approach:

in .vimrc: au BufEnter * if exists('b:BuffEnter')|exec b:BuffEnter|endif au
BufLeave * if exists('b:BuffEnter')|exec b:BuffLeave|endif

In appropriate ftplugin/?.vim, there are assigned commands to create or
destroy the menus - here typed in directly, may be of course call to a
menu-generating function or whatever.

let b:BuffEnter='amenu C.added ...'  let b:BuffLeave='unmenu! C|unmenu C'

</pre></tip> </html> <Tip category="KVim"> <html><center>Edit
configuration files for a filetype</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=215">http://vim.sf.net/tip_view.php?tip_id=215</A><BR>

When you open a file, vim may load several scripts to customize itself for
editing the file type the file is associated with (for example a file "test.c"
is associated with the filetype "c").  Such configurations include the setting
of syntax highlighting colors (:help syntax) and support for indentation
(:help filetype-indent-on).  When you start to override these files for
yourself, it can sometimes be confusing, which file sets a specific option.
The following function can be used, to edit the configuration files which
are associated with a specific filename. It open a buffer for all files which
get loaded.  If I invoke it with ':call Edit_ft_conf("test.c")', for example,
I end up with the following buffers / windows:
  1  a	 "[No File]"			line 1 2  a   "test.c"
  line 1 3  a=	"/usr/local/share/vim/vim60/syntax/c.vim"
  line 1 4  a	"~/.vim/after/syntax/c.vim"    line 1 5 #a=
  "/usr/local/share/vim/vim60/indent/c.vim" line 1 6 %a=
  "/usr/local/share/vim/vim60/ftplugin/c.vim" line 1

Here comes the function:

" Edit filetype configuration files " Usage: ':call Edit_ft_conf("file")'
" Purpose: open all scripts which get loaded implicitly by opening "file" "
(syntax highlighting, indentation, filetype plugins, ..)  "   The order of
windows reflects the order of script loading (but "file" is "	the topmost
window) fun! Edit_ft_conf(name)
    " we may not do this with a loaded file, since this won't trigger the
    " configuration file loading as desired.  " try calling with 'call
    Edit_ft_conf("nonexistingfile.&lt;EXT&gt;")' if this " gives you troubles
    if bufexists(a:name) && bufloaded(a:name)
	echo "!Attention: buffer for " . a:name . " is loaded, unload first."
	return
    endif " split-open the file with verbose set, grab the output into a
    register " (without clobbering) let safereg = @u redir @u " redirect
    command output to register @u exec "silent 2verbose split " . a:name
	" verbose level 2 suffices to catch all scripts which get opened
    redir END " Parse register @u, looking for smth like:
    'sourcing"/usr/local/share/vim/vim60/syntax/c.vim"' let pos = 0 let
    regexp = 'sourcing "[^"]\+"' while match(@u,regexp,pos) &gt;= 0
	let file = matchstr(@u,regexp,pos) let pos = matchend (@u,regexp,pos)
	let file = strpart(file,10,strlen(file)-11) exec "silent below split
	" . file
    endwhile " restore the register let @u = safereg
endfun

</pre></tip> </html> <Tip category="KVim"> <html><center>calculate
equations from within vim</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=216">http://vim.sf.net/tip_view.php?tip_id=216</A><BR>

The following map and function calculates equations using the program 'bc'
(found on most linux systems, available for most systems).  Visually select the
equation you want to calculate, then hit ;bc - if the selection ends with an
'=' sign, the answer will be appended after the equal, otherwise, the answer
is echoed as a message.  The code to put in a vimrc and source is at the end.

Equations can span multiple lines, and the full bc syntax is probably
supported.  Additionally, sin (), cos (), etc, are transformed into the
names used by bc (s () c (), etc).

Here are some example lines:

2 * sqrt (2) =

3 * (2 - 1) + 4.0 ^ 6 =

4 / 3 =

3 +
   4 -
      2 * (1 / (3 + 2)) =

define rad (x) {
  return (x / 180) * 4 * atan (1)
} cos (rad (45)) =

Select each of these in turn (continguous non-blank lines, and hit ;bc for
each), and this is what you get: 2 * sqrt (2) = 2.82842712474619009760

3 * (2 - 1) + 4.0 ^ 6 = 4099.000000

4 / 3 = 1.33333333333333333333

3 +
   4 -
      2 * (1 / (3 + 2)) = 6.60000000000000000000

define rad (x) {
  return (x / 180) * 4 * atan (1)
} cos (rad (45)) = .70710678118654752440

Fun, no?  Here is the code you need to put in your vimrc file:

vnoremap ;bc "ey:call CalcBC()&lt;CR&gt; function! CalcBC()
	let has_equal = 0

	" remove newlines and trailing spaces let @e = substitute (@e, "\n",
	"", "g") let @e = substitute (@e, '\s*$', "", "g")

	" if we end with an equal, strip, and remember for output if @e =~ "=$"
		let @e = substitute (@e, '=$', "", "") let has_equal = 1
	endif

	" sub common func names for bc equivalent let @e = substitute (@e,
	'\csin\s*(', "s (", "") let @e = substitute (@e, '\ccos\s*(', "c
	(", "") let @e = substitute (@e, '\catan\s*(', "a (", "") let @e =
	substitute (@e, "\cln\s*(", "l (", "")

	" escape chars for shell let @e = escape (@e, '*()')

	" run bc, strip newline let answer = substitute (system ("echo "
	. @e . " \| bc -l"), "\n", "", "")

	" append answer or echo if has_equal == 1
		normal `&gt; exec "normal a" . answer
	else
		echo "answer = " . answer
	endif
endfunction

</pre></tip> </html> <Tip category="KVim"> <html><center>Translate
&#nnn; in html source to readable ascii</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=217">http://vim.sf.net/tip_view.php?tip_id=217</A><BR>

I found a website *cough*Tivoli.com*cough* that likes to obfuscate some of
its help file web pages using &#nnn; instead of normal ascii.  If you load
the source with Vim (in Opera you can just designate Vim as your source
viewing program), you can :so the following code to make it readable.

let n = 32 while n &lt; 127
    if n == 38
	silent! exec '%s/&#38;/\&amp;/g'
    elseif n == 47
	silent! exec '%s/&#47;/\//g'
    else
	silent! exec '%s/&#' . n . ';/' . nr2char(n) . '/g'
    endif let n = n + 1
endwhile

Disclaimer: I hacked this together in about 10 minutes (or possibly longer :).
It worked suitably for the website I wrote it for (or possibly "against" :).
Your Milage May Vary.

See :help eval, :help silent, :help exec, :help :s

</pre></tip> </html> <Tip category="KVim"> <html><center>Check
for comments, independent of the filetype</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=218">http://vim.sf.net/tip_view.php?tip_id=218</A><BR>

For some scripts it might be useful to detect, whether a specific position
in a buffer is inside of a comment or not. Syntax highlighting can save us
the work for parsing the comments ourselves.

The command
  :echo synIDattr(synIDtrans(synID(line("."), col("."), 0)), "name")
echoes the group used for *highlighting* the character at the current
cursor position, see ':help synIDtrans()'. It will usually be "Comment"
if the cursor is inside of a comment, so
   synIDattr(synIDtrans(synID(line("."), col("."), 0)), "name") == "Comment"
detects, independent of the filetype (which have their own group 'names'
for comments), if the cursor is inside a comment or not.  The expression
  synIDattr(synIDtrans(synID(line("."), col("."), 0)), "name") =~
  'Comment\|Constant\|PreProc'
will detect additionally, if the cursor is inside of a string or some
preprocessor statement.

</pre></tip> </html> <Tip category="KVim"> <html><center>make
from command line, open vim on errors</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=219">http://vim.sf.net/tip_view.php?tip_id=219</A><BR>

A simple alias (*csh) or shell function (bash) will let you run make from your
shell, then automatically open vim or gvim on the errors (if there were any):

csh or tcsh:

alias Make 'make \!* |& tee make.errors || gvim -q make.errors -c :copen'

bash:

Make () { command make "$@" |& tee make.errors || gvim -q make.errors -c
:copen ; }

If you use vanilla sh or ksh or even cmd.exe, you can probably do the same -
add a not if you have ideas.

</pre></tip> </html> <Tip category="KVim">
<html><center>Match every word except 'foo'</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=220">http://vim.sf.net/tip_view.php?tip_id=220</A><BR>

This is a regular expression that matches all words except 'foo'
\v&lt;(foo&gt;)@!\k+&gt;

\v		Very magic &lt;		   Start-of-word (Foo&gt;)	 The
atom 'Foo' followed by end-of-word @!		   Match (with zero length)
when the previous atom doesn't match.  \k+	       Match one or more
Keywords &gt;		 Match end-of-word.

This is a kool example of using \@! in the middle of a regexp.	The non-magic
version is: \&lt;\(foo\&gt;\)\@!\k\+\&gt;

</pre></tip> </html> <Tip category="KVim">
<html><center>indenting "throws" in java</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=221">http://vim.sf.net/tip_view.php?tip_id=221</A><BR>

I want to indent java files like this:

    int x(int y, int z)
	throws Exception
    {
	[...]  return something;
    }

By default vim will properly indent "throws" line, but following "{" will
not be deindented back to the method declaration.

The following indentexpr does the trick: let
&indentexpr='getline(v:lnum)=~"^\\s*{" && getline(v:lnum-1)=~"^\\s*throws\\s"
? cindent(v:lnum)-&sw : cindent(v:lnum)'

It just checks that the current line starts with "{" and the previous line
starts with "throws" and if that is the case, it subtracts one shiftwidth
from the number returned by cindent.

</pre></tip> </html> <Tip category="KVim">
<html><center>Building vim with color on HP-UX</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=222">http://vim.sf.net/tip_view.php?tip_id=222</A><BR>

Following the normal steps of running "./configure" and "make" to build vim
on an HP-UX 10.20 will result in vim being linked with the termlib library.
This library does not support certain termcap capability codes, such as the
"Co" code used to query the number of colors supported by the terminal.
Consequently, vim will not display colors when used with a color terminal
such as a color xterm.

One solution to this is to run the configure script with the
"--with-tlib=curses" option, like this:

    ./configure --with-tlib=curses

This will cause vim to be linked with the HP-UX curses library, which does
support the color termcap capability codes.

Note that the xterm that comes standard with HP-UX 10.20 does not display color
character attributes.  To see colors when running vim in a terminal window,
you will also need to install a color terminal emulator such as a recent xterm.

</pre></tip> </html> <Tip category="KVim">
<html><center>Reverse Selected Text</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=223">http://vim.sf.net/tip_view.php?tip_id=223</A><BR>

Suppose you want to reverse some text - I don't know why you would want to -
maybe you're dyslexic.	Anyway, I had a need, so this mapping will reverse
visually selected text.  Put the mapping in your vimrc or otherwise source
it, then visually select the word or words, and hit ;rv - really only works
with selections on one line:

vnoremap ;rv c&lt;C-O&gt;:set revins&lt;cr&gt;&lt;C-R&gt;"&lt;esc&gt;:set
norevins&lt;cr&gt;

</pre></tip> </html> <Tip category="KVim">
<html><center>Shifting blocks visually</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=224">http://vim.sf.net/tip_view.php?tip_id=224</A><BR>

I use the &lt; and &gt; commands on blocks a lot, and it has always annoyed me
that if you want to shift more than one 'shiftwidth', you have count how many
'shiftwidth's you want to enter the '[count]&gt;', or restore the selection
with "gv". So I've cooked up two mappings that come in very handy:

:vnoremap &lt; &lt;gv :vnoremap &gt; &gt;gv

These mappings will reselect the block after shifting, so you'll just have
to select a block, press &lt; or &gt; as many times as you like, and press
&lt;ESC&gt; when you're done to unselect the block.

I know it's not rocket science, but it sure has helped me a lot.

</pre></tip> </html> <Tip category="KVim">
<html><center>vim can interact with xdvi</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=225">http://vim.sf.net/tip_view.php?tip_id=225</A><BR>

 vim can interact with the tricks that the latest xdvi does:

 * If one clicks at some place in xdvi, vim automatically jumps to the
   corresponding line in the LaTeX source file ("reverse search")
 * Also, from inside vim, one can jump to the corresponding line in xdvi
   which becomes highlighted ("forward search").

 Here is how to do it:

 * Reverse search:
   We start a vim server by:  vim --servername xdvi We start xdvi(k) on
   file.dvi by:
      xdvik -editor "vim --servername xdvi --remote +%l %f" file.dvi
   At the desired location in xdvi, we press:	&lt;ctrl&gt;&lt;left_mouse&gt;
   Then, vim will jump to the corresponding line in the source file.

 * Forward search:
   Inside vim, we type, for example,  _g  which is the following mapping:
	(the following should be a single line)

   map _g  :execute "!xdvik -name xdvi -sourceposition "
   . line(".") . expand("%") . " " . expand("%:r") . ".dvi"
   &lt;cr&gt;&lt;cr&gt;

    [the command to go to the point of xdvi that corresponds to line, eg, 77
     of the source file is (no space after 77)
       xdvik -name xdvi -sourceposition 77file.tex file.dvi  ]

  For the above to work one needs: 1) A recent version of xdvi or xdvik
  (&gt;22.39 I think) 2) The package srcltx.sty and \usepackage{srcltx}
  (which should  be
     commented out when one finishes and is ready for printing etc).
  3) Our version of vim should have been compiled with +clientserver
     (however, my vim doesn't have it and still works, so try it before
      Bram finds out what is happening and fixes it)

</pre></tip> </html> <Tip category="KVim"> <html><center>Edit
file under cursor after a horizontal split</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=226">http://vim.sf.net/tip_view.php?tip_id=226</A><BR>

I use the command 'gf' quite often. But with this command the current buffer
is hidden. To avoid that I use the following mapping :

map gw &lt;Esc&gt;:sp %&lt;CR&gt; gf

With this mapping the file under the cursor is opened after a horizontal split.

</pre></tip> </html> <Tip category="KVim">
<html><center>Power of :g</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=227">http://vim.sf.net/tip_view.php?tip_id=227</A><BR>

:g is something very old and which is very powerful. I just wanted to
illustrate the use of it with some examples. Hope, it will be useful for
someone.

Brief explanation for ":g" ------------------------- Syntax is:
    :[range]:g/&lt;pattern&gt;/[cmd]
You can think the working as, for the range (default whole file), execute
the colon command(ex) "cmd" for the lines matching &lt;pattern&gt;. Also,
for all lines that matched the pattern, "." is set to that particular line
(for certain commands if line is not specified "." (current line) is assumed).

Some examples ------------- Display context (5 lines) for all occurences of
a pattern
    :g/&lt;pattern&gt;/z#.5 :g/&lt;pattern&gt;/z#.5|echo "==========" &lt;&lt;
    same as first, but with some beautification &gt;&gt;
Delete all lines matching a pattern
    :g/&lt;pattern&gt;/d
Delete all blank lines (just an example for above)
    :g/^\s*$/d
Double space the file
    :g/^/pu =\"\n\" :g/^/pu _ &lt;&lt; the above one also works &gt;&gt;
Copy all lines matching a pattern to end of file
    :g/&lt;pattern&gt;/t$
Yank all lines matching a pattern to register 'a'
    0"ay0:g/&lt;pattern&gt;/y A
Increment the number items from current line to end-of-document by one
    :.,$g/^\d/exe "normal! \&lt;c-a&gt;"
Comment (C) lines containing "DEBUG" statements
    g/^\s*DEBUG/exe "norm! I/* \&lt;Esc&gt;A */\&lt;Esc&gt;"
A Reverse lookup for records (eg: An address book, with Name on start-of-line
and fields after a space)
    :g/&lt;patern&gt;?^\w?p		  "if only name is interested
    :g/&lt;patern&gt;/ka|?^\w?p|'ap	  "if name and the lookup-line
    is interested :g/&lt;patern&gt;/?^\w?|+,/^[^ ]/-1p	"if entire record
    is interested
Reverse a file (just to show the power of 'g')
    :g/^/m0

Foot note 1: use :v to negate the search pattern Foot note 2: Some explanation
of commonly used commands with :g
 :2,8co15 =&gt; Copy lines 2 through 8 after line 15 :4,15t$  =&gt; Copy
 linesa 4 through 15 towards end of document (t == co)
    :-t$  =&gt; Copy previous line to end of document
     :m0  =&gt; Move current line to the top of the document
:.,+3m$-1 =&gt; Move current line through cur-line+3 to the last but one line
	     of the document
Foot note 3: Commands used with :g are ex commands, so a help search should
	     be,
		:help :&lt;help-topic&gt; eg. :help :k

</pre></tip> </html> <Tip category="KVim"> <html><center>Deleting
nested reply threads in emails</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=228">http://vim.sf.net/tip_view.php?tip_id=228</A><BR>

I find the following setting useful when replying to email threads that have
lots of lines like the following: &gt; blah &gt; &gt; blah &gt; &gt; &gt; blah

autocmd FileType mail map &lt;F8&gt; :%g/^&gt; &gt;/d&lt;CR&gt;

When replying to a mail and you want to remove everything except what the
person you are directly replying to wrote just press F8.  From the example
above, you would just be left with &gt; blah

What it does is simply match any line starting with &gt; &gt; and deletes it.
It's not perfect as sigs and other debris may remain but it takes a lot
of the grunt work out of replying to mails.  The autocmd only maps F8 when
using mails, this is handy if you use F8 for other things as I do.

:help autocmd :help map :help :g

</pre></tip> </html> <Tip category="KVim"> <html><center>First
thing to try before asking help</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=229">http://vim.sf.net/tip_view.php?tip_id=229</A><BR>

I've seen several questions asked in the reflector which is available in the
help files.  Yeah, I know the help is huge. But, you can try this command
to show a list of related topics you are trying:
   :he &lt;topic&gt;&lt;c-d&gt;
It is "some topic" followed by the key sequence Ctrl-D. For eg:
   :he xterm&lt;c-d&gt;
will show all the help topics matching xterm. Then you can do
completion/copy-n-paste the topic you are searching. Of course you can cycle
through all the topics through repeated &lt;TABS&gt;, but if the number of
hits are huge, it is cumbersome.

Enjoy vimming beginners!!!  -Arun

</pre></tip> </html> <Tip category="KVim"> <html><center>copy
current file to another location from within vim</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=230">http://vim.sf.net/tip_view.php?tip_id=230</A><BR>

I work on jsp pages in my source tree but I have to copy the jsp files over
to the tomcat directory in order to view my changes.The following mapping
will copy the file being edited to another location.

command Cpage silent !cp '%:p' "c:/Progra~1/Tomcat/webapps/console/pages/%"

Explanation:

% refers to the current buffer %:p refers to the path to the file silent
suppresses the command prompt window.

Usage:

:Cpage

</pre></tip> </html> <Tip category="KVim">
<html><center>Localized color schemes</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=231">http://vim.sf.net/tip_view.php?tip_id=231</A><BR>

i frequently like to edit multiple files in the same vim session.  however,
if i come into vim from another window i frequently hit 'i' and start typing
in whatever buffer is currently being used -- this is often the wrong one
(requires &lt;esc&gt;, undo, go the other buffer and . to redo).

one way to work around this for me is to use a different color scheme
depending on what file i'm working on:

au BufEnter * if (exists("b:colors_name")) | let b:current_colors=colors_name
| execute "colorscheme " . b:colors_name | endif

au BufLeave * if (exists("b:current_colors")) | execute "colorscheme "
. b:current_colors | endif

if you define b:colors_name with a particular color scheme name, then the
above autocommands will switch to that colorscheme when you enter that window
and will return to the original color upon departure.

inside ftplugin/java.vim, for example, i might have b:colors_name set to
'morning', causing all java files to have a distinguishing color scheme.

</pre></tip> </html> <Tip category="KVim"> <html><center>Search
JDK help for keyword at cursor</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=232">http://vim.sf.net/tip_view.php?tip_id=232</A><BR>

 If you are using the Win32 version of Vim you can use this tip to search
 the Jdk help for the keyword under the cursor.
You need the winhlp32 version of the Jdk docs from this URL - <A
HREF="http://www.confluent.fr/javadoc/indexe.html.">http://www.confluent.fr/javadoc/indexe.html.</A><BR>
It is a 16mb D/L and approx 85mb unzipped!

I added a command to the popup menu :amenu PopUp.JavaHelp   :!start winhlp32
-k &lt;cword&gt; F:\jdk\winhelp\JDK13.HLP &lt;CR

And also made a keymapping map J :!start winhlp32 -k &lt;cword&gt;
F:\jdk\winhelp\JDK13.HLP &lt;CR&gt;

Trivial yes, but I find it quite useful.

</pre></tip> </html> <Tip category="KVim"> <html><center>Some
tips for using Vim to write Lisp code</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=233">http://vim.sf.net/tip_view.php?tip_id=233</A><BR>

For some tips on how to use Vim for writing Lisp code, see <A
HREF="http://www.lisp-p.org/i000/15-vim.">http://www.lisp-p.org/i000/15-vim.</A><BR>

</pre></tip> </html> <Tip category="KVim"> <html><center>Vi(M)
Command Line tips & tricks</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=234">http://vim.sf.net/tip_view.php?tip_id=234</A><BR>

Hi VIMMERs

These tips save me wearing out my delicate little fingers with unnecessary
keystrokes.  They assume Unix, but I also use them on a Windows Unix Shell
(MKS) as well

# When I know the file i want to edit is the most recent file in a directory

alias -x vew='vi `l\s -t * | head -1 `'

#When I know the file I want to edit contains a unique keyword #this is
actually in a little shell script call ed vg where the keyword is passed as
parameter $1 #/bin/sh #name vg vi.exe  $(grep -isl $1 *) &

# some variations alias -x vp='vi `l\s -t *.@(pl|cgi)| head -1 `'

#execute the most recent script (I call this from within VIM with a mapped
button) alias -x xew='`l\s -t *.pl | head -1 `'

Cheers zzapper

</pre></tip> </html> <Tip category="KVim"> <html><center>Toggle
highlight word under cursor, to find cursor.</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=235">http://vim.sf.net/tip_view.php?tip_id=235</A><BR>

When the screen has scrolled such as during a search, it may be difficult to
find the cursor.  :help %# explains the pattern one can use to highlight the
word around the cursor, which gives a bigger target to look for on the screen.
I have this in my .vimrc:

function VIMRCWhere()
    if !exists("s:highlightcursor")
	match Todo /\k*\%#\k*/ let s:highlightcursor=1
    else
	match None unlet s:highlightcursor
    endif
endfunction map &lt;C-K&gt; :call VIMRCWhere()&lt;CR&gt;

This means that in "normal" mode ctrl-k will toggle the highlight.  Todo is
a hightlight group whch is particularly easy to see.  For further information
see ":help s:", ":help match",	":help exists()"  and ":help funtion".

</pre></tip> </html> <Tip category="KVim"> <html><center>Menu
for inserting special characters</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=236">http://vim.sf.net/tip_view.php?tip_id=236</A><BR>

First, thanks for the script printascii.vim.

When looking at the ascii table, I found some characters I'd like to have
inserted when editing.	Add the following lines in your _gvimrc and you
can select them via menu.  (change the names of the menu if you don't have
German installed or don't like my titles).  I also made some abbreviations
to get separation lines in documentation or code files, e.g.  abb dotlin
^M
abb cdotlin
/**/^M
abb fdotlin
^M
abb cfdotlin
/**/^M abb
dlin =======================================================================^M
abb cdlin
/*===================================================================*/^M abb
lin -----------------------------------------------------------------------^M
abb clin
/*-------------------------------------------------------------------*/^M abb
ulin _______________________________________________________________________^M
abb culin
/*___________________________________________________________________*/^M abb
Ulin ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯^M
abb cUlin
/*¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯*/^M

(you have to substitute ^M with CTRL_V CTRL_M or delete it)

20imenu Editieren.Sonderzeichen.open\ angle\	«
&lt;C-R&gt;=nr2char(171)&lt;CR&gt; 20nmenu Editieren.Sonderzeichen.open\
angle\	  «	  a&lt;C-R&gt;=nr2char(171)&lt;CR&gt;&lt;ESC&gt;
20imenu Editieren.Sonderzeichen.close\ angle\	»
&lt;C-R&gt;=nr2char(187)&lt;CR&gt; 20nmenu Editieren.Sonderzeichen.close\
angle\	 »	 a&lt;C-R&gt;=nr2char(187)&lt;CR&gt;&lt;ESC&gt;
20imenu Editieren.Sonderzeichen.start\ mark\	
&lt;C-R&gt;=nr2char(132)&lt;CR&gt; 20nmenu Editieren.Sonderzeichen.start\
mark\	 	 a&lt;C-R&gt;=nr2char(132)&lt;CR&gt;&lt;ESC&gt;
20imenu Editieren.Sonderzeichen.end\ mark\	\	
&lt;C-R&gt;=nr2char(148)&lt;CR&gt; 20nmenu Editieren.Sonderzeichen.end\
mark\	   \	   	   a&lt;C-R&gt;=nr2char(148)&lt;CR&gt;&lt;ESC&gt;
20imenu Editieren.Sonderzeichen.fat\ dot\	\	
&lt;C-R&gt;=nr2char(149)&lt;CR&gt; 20nmenu Editieren.Sonderzeichen.fat\
dot\	   \	   	   a&lt;C-R&gt;=nr2char(149)&lt;CR&gt;&lt;ESC&gt;
20imenu Editieren.Sonderzeichen.etc\	\	\	
&lt;C-R&gt;=nr2char(133)&lt;CR&gt; 20nmenu Editieren.Sonderzeichen.etc\
\	\		a&lt;C-R&gt;=nr2char(133)&lt;CR&gt;&lt;ESC&gt;
20imenu Editieren.Sonderzeichen.!underscore\	\	¯
&lt;C-R&gt;=nr2char(175)&lt;CR&gt; 20nmenu Editieren.Sonderzeichen.!underscore\
\	¯	a&lt;C-R&gt;=nr2char(175)&lt;CR&gt;&lt;ESC&gt;
20imenu Editieren.Sonderzeichen.copyright\	\	©
&lt;C-R&gt;=nr2char(169)&lt;CR&gt; 20nmenu Editieren.Sonderzeichen.copyright\
\	©	a&lt;C-R&gt;=nr2char(169)&lt;CR&gt;&lt;ESC&gt;
20imenu Editieren.Sonderzeichen.paragraph\	\	§
&lt;C-R&gt;=nr2char(167)&lt;CR&gt; 20nmenu Editieren.Sonderzeichen.paragraph\
\	§	a&lt;C-R&gt;=nr2char(167)&lt;CR&gt;&lt;ESC&gt;
20imenu Editieren.Sonderzeichen.noitamalcxe\	¡
&lt;C-R&gt;=nr2char(161)&lt;CR&gt; 20nmenu Editieren.Sonderzeichen.noitamalcxe\
¡	a&lt;C-R&gt;=nr2char(161)&lt;CR&gt;&lt;ESC&gt;

</pre></tip> </html> <Tip category="KVim"> <html><center>If
you prefer vertical splits</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=237">http://vim.sf.net/tip_view.php?tip_id=237</A><BR>

This is just in case there's somebody else who likes to work in a maximized
vim window on a high resolution desktop. If you follow good coding practice
and make sure your programs use only 80 characters in each row, have you
noticed how much space lies unused on the right?

I find that the following settings keep me from ever seeing another horizontal
split, unless I specifically ask for it.

cabbrev split vsplit cabbrev hsplit split cabbrev sta vertical sta cabbrev
help vertical help cabbrev new vnew cabbrev right botright

; A more heavyweight solution for ^W^] function! ToggleSplit (dir)
    let currFname = bufname ("%") let old = winnr ()

    " Window navigation to ensure the correct window is 'last'.  if (a:dir ==
    "u")
	wincmd k let back="j"
    elseif (a:dir == "d")
	wincmd j let back="k"
    elseif (a:dir == "l")
	wincmd h let back="l"
    elseif (a:dir == "r")
	wincmd l let back="h"
    endif

    if (winnr () == old)
	echo "Ouch" return
    endif

    exec "wincmd " . back

    quit

    if (back == "j" || back == "k")
	let orientation = "vsplit"
    else
	let orientation = "split"
    endif

    if (back == "j" || back == "l")
	let dir = "below"
    else
	let dir = "above"
    endif

    exec dir . " " . orientation " " . currFname
endfunction noremap ^W^] ^W^]:silent call ToggleSplit ("d")&lt;CR&gt;

; Optional.  set splitright ; In which case the above mapping becomes: noremap
^W^] :set splitbelow&lt;CR&gt;^W^]:silent call ToggleSplit ("u")&lt;CR&gt;:set
nosplitbelow&lt;CR&gt; ; Or you could just set splitbelow ; :-)

; Very elegant and almost perfect, but it screws up if you want to run a
command with ranges :-) ;noremap : :vertical&lt;Space&gt;

; EOF

</pre></tip> </html> <Tip category="KVim"> <html><center>Very
basic session persistence</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=238">http://vim.sf.net/tip_view.php?tip_id=238</A><BR>

I use the following code in my plugins dir to ease session persistance. If
I want my session to persist I use :mks! and then whenever I open the
Session.vim file, my session is restored. If I am working from a restored
session and I close VIM, the session is saved automatically. Drawback is
that it makes editing the Session.vim file a bit cumbersome ;)

  au BufRead Session.vim so % au VimLeave * call SaveCurrentSession()

  function! SaveCurrentSession()
    if v:this_session != ""
      exe "mksession! " . v:this_session
    endif
  endfunction

</pre></tip> </html> <Tip category="KVim">
<html><center>map shift-up and shift-down</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=239">http://vim.sf.net/tip_view.php?tip_id=239</A><BR>

You can make Vim scroll the text using the shifted up/down arrows, sort
of like your browser (except with shifted keys :), by mapping Shift-Up to
Ctrl-Y and Shift-Down to Ctrl-E.

    map &lt;s-Down&gt; &lt;C-E&gt; map &lt;s-Up&gt; &lt;C-Y&gt;

Shift-Down will then scroll down (like moving a scroll-bar down, or like
moving a cursor at the bottom of a window down), and Shift-Up will then
scroll up (like moving a scroll-bar up, etc).

If you'd rather think about the text moving down/up instead of the cursor
moving up/down, you can of course swap the mappings.

If you normally use j and k for cursor movement, and rarely use the arrow
keys, you can map the arrow keys directly, in which case I'd probably map
the shifted arrow keys back to cursor movement:

    map &lt;down&gt; &lt;c-e&gt; map &lt;up&gt; &lt;c-y&gt; map &lt;s-down&gt;
    j map &lt;s-up&gt; k

See :help ctrl-e, :help ctrl-y, and :help key-mapping.

See also :help i_ctrl-o and :help map-modes for how to set up these mappings
for use in other modes (like insert mode :).

(Vim by default maps s-Down and s-Up to Ctrl-F and Ctrl-B, for both normal and
visual mode.  Keep this in mind if you change some of the above mappings to
"nmap", 'cause you'll probably also want to look in to "vmap".)

</pre></tip> </html> <Tip category="KVim">
<html><center>Hideall for Vim</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=240">http://vim.sf.net/tip_view.php?tip_id=240</A><BR>

Xemacs has a hide all function which can make all the function in your C file a
fold and close them. And here is something small to achieve similiar under Vim.

func! HideAll()
   syn region myFold start="{" end="}" transparent fold syn sync fromstart
   set foldnestmax=1 set foldmethod=syntax
endfunc

amenu Whatever.Hide\ all :call HideAll()&lt;CR&gt;

</pre></tip> </html> <Tip category="KVim">
<html><center>"Hide" Folding Markers</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=241">http://vim.sf.net/tip_view.php?tip_id=241</A><BR>

I wanted to start using folding without having to get used to seeing the
(default) markers, a.k.a {{{ and }}}. So, here are 2 autocmd's that will
make them fade to black....bg=black fg=black

au BufRead,BufNewfile	* syn match fmrkr '"*{{{\|"*}}}'		 |
			\ syn cluster vimCommentGroup contains=fmrkr	 |
			\ hi fmrkr term=NONE guibg=black   guifg=black \
			ctermbg=black ctermfg=black

au BufRead,BufNewfile	* syn match fmrkr '"*{{{\|"*}}}'
			\ containedin=vimLineComment contained		 |
			\ hi fmrkr term=NONE guibg=black   guifg=black \
			ctermbg=black ctermfg=black

They both accomplish the same thing, but with different methods, so simply pick
one and see those annoying (at least to me) markers fade away.	I just tried
it out with vim files, but you can easily modify it for any other filetypes.

Thanks to Colin's lead with ':help c-syntax'	for the 1st au.  Thanks to
Benji's lead with ':help containedin' for the 2nd au.  Understanding most
of the syntax.txt document file would also be helpful.

To figure out what highlighting group the Marker is in, I would suggest
using Chip's vimtip#99.

Happy Vimming!

</pre></tip> </html> <Tip category="KVim">
<html><center>The power of "\_" in reg-ex</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=242">http://vim.sf.net/tip_view.php?tip_id=242</A><BR>

One of the most uncelebrated feature of vim 6.0 is the ability to span a
search across multiple lines.

\_^   maps a begining of line anywhere in search pattern.  \_$	 ---"----- end
----------------------"-------------------------.  \_s	---"------ space
------------"------------------------- .

e.g  /{\_s will map all white spaces and new-line chars after a "{"

The \_ can be appended to other objects as well. such as \_U,  \_L,  \_. (this
one's risky) .

See :help pattern for more details.  Njoy

</pre></tip> </html> <Tip category="KVim">
<html><center>Develop vim modules on Win</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=243">http://vim.sf.net/tip_view.php?tip_id=243</A><BR>

We're trying to develop txt2pdf.vim <A
HREF="http://vim.sourceforge.net/scripts/script.php?script_id=283 on
Win.">http://vim.sourceforge.net/scripts/script.php?script_id=283
on Win.</A><BR> It's a very simple module to save the
current file and convert it to PDF using our txt2pdf tool <A
HREF="http://www.sanface.com/txt2pdf.html">http://www.sanface.com/txt2pdf.html</A><BR>
On our Windows 2000 we've developed it. It works good.	Today we've tested
the module on Linux. Surprise: it doesn't work.  Default Win Vim configure
save on Win text in Win way: EOL \r\n.	A Vim module made in this way can't
work on Linux (probably on every Unix OS).  If you want to make a Vim module
on Win and you want it can work also on Unix (we hope the same rula can work
also on different OS) you've to save the Vim module with Unix EOL (\n).

Please send us (sanface@sanface.com) your notes about other OS (e.g. OpenVMS).

</pre></tip> </html> <Tip category="KVim"> <html><center>Ask
vim where an option was set.</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=244">http://vim.sf.net/tip_view.php?tip_id=244</A><BR>

     When things go wrong, it is sometimes hard to figure out why.
     For example,
an option might be set in the system vimrc file, in a personal vimrc file,
in a plugin (global or local), or interactively.  Vim will tell you where
the current value was set if you ask:

:verbose set history?

will tell you the current value of the 'history' option, and where it was set.

</pre></tip> </html> <Tip category="KVim"> <html><center>Working
with Unicode (platform-independent)</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=245">http://vim.sf.net/tip_view.php?tip_id=245</A><BR>

Here are the main options you will want to set if you want to work with
Unicode files in (g)vim (see at bottom what help tags to look for)

if has("multi_byte")
     set encoding=utf-8			      " how vim shall represent
     characters internally setglobal fileencoding=utf-8		" empty is
     also OK (defaults to same as 'encoding'). Or you may want to set one
     of the ucs encodings (which
							  " may use less disk
							  space if you use
							  only "alphabetic"
							  scripts such as
							  Latin, Greek,
							  Cyrillic, Hebrew
							  or Arabic, and "
							  not "ideographic"
							  scripts like
							  Chinese, Japanese
							  or Korean. With
							  the ucs encodings
							  it is usually better
     set bomb					   "  to also set 'bomb'
     on ('byte-order-mark" option, irrelevant for utf-8 but not for
     ucs) set termencoding=iso-8859-15	  " or whatever is appropriate
     to your locale (iso-8859-15 is Latin1 + Euro currency sign) set
     fileencodings=ucs-bom,iso-8859-15,iso-8859-3,utf-8
	 " or whatever is appropriate to the kinds of files you want to
	 edit " 'fileencodings' defines the heuristic to set 'fillencoding'
	 (local to buffer) when reading an existing file. The first one that
	 matches will be used.	" ucs-bom is "ucs with byte-order-mark";
	 it must not come after ucs-8 if you want it to be used
else
     echoerr "Sorry, this version of (g)vim was not compiled with +multi_byte"
endif

In "replace" mode, one utf character (one or more data bytes) replaces one
utf character (which need not use the same number of bytes) In "normal" mode,
ga shows the character under the cursor as text, decimal, octal and hex; g8
shows which byte(s) is/are used to represent it In "insert" or "replace" mode,
  - any character defined on your keyboard can be entered the usual way (even
  with dead keys if you have them, e.g. âêîôû  äëïöü) - any character which
  has a "digraph" (there are a huge lot of them, see :dig after setting
  enc=utf-8) can be entered with a Ctrl-K prefix - any utf character at
  all can be entered with a Ctrl-V prefix, either &lt;Ctrl-V&gt; u aaaa
  or &lt;Ctrl-V&gt; U bbbbbbbb, with 0 &lt;= aaaa &lt;= FFFF, or 0 &lt;=
  bbbbbbbb &lt;= 7FFFFFFF

Unicode can be used to create html "body text", at least for Netscape 6 and
probably for IE; but on my machine it doesn't display properly as "title text"
(i.e., between &lt;title&gt;&lt;/title&gt; tags in the &lt;head&gt; part).

Gvim will display it properly if you have the fonts for it, provided that
you set 'guifont' to some fixed-width font which has the glyphs you want
to use (Courier New is OK for French, German, Greek, Russian and more,
but I'm not sure about Hebrew or Arabic; its glyphs are of a more "fixed"
width than those of, e.g. Lucida Console: the latter can be annoying if you
need bold Cyrillic writing).

see:

:h utf8 :h 'enc' :h 'fenc' :h 'fencs' :h 'tenc' :h 'bomb' :h 'guifont'
:h ga :h g8 :h i_Ctrl-V_digit

Happy Vimming !  Tony.

</pre></tip> </html> <Tip category="KVim"> <html><center>Working
with Unicode (the same, rewritten for legibility)</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=246">http://vim.sf.net/tip_view.php?tip_id=246</A><BR>

1. Where to look for help ------------------------- :h utf8 :h encoding-values
:h 'enc' :h 'fenc' :h 'fencs' :h 'tenc' :h 'bomb' :h 'guifont' :h ga :h g8
:h :dig :h i_Ctrl-V_digit :h has()

2. What to do (These are *examples*. Modify them to suit your work
environment.)  ------------- if has("multi_byte")
     set encoding=utf-8 setglobal fileencoding=utf-8
     set bomb set termencoding=iso-8859-15 set
     fileencodings=ucs-bom,iso-8859-15,iso-8859-3,utf-8
else
     echoerr "Sorry, this version of (g)vim was not compiled with +multi_byte"
endif

3. What the above does ---------------------- * has("multi_byte") checks if
you have the right options compiled-in. If you haven't got what it takes,
it's no use trying to use Unicode.

* 'encoding' sets how vim shall represent characters internally. Utf-8 is
necessary for most flavors of Unicode.

* 'fileencoding' sets the encoding for a particular file (local to buffer);
:setglobal sets the default value. An empty value can also be used: it defaults
to same as 'encoding'. Or you may want to set one of the ucs encodings, It
might make the same disk file bigger or smaller depending on your particular
mix of characters. Also, IIUC, utf-8 is always big-endian (high bit first)
while ucs can be big-endian or little-endian, so if you use it, you will
probably need to set 'bomb" (see below).

* 'bomb' (boolean): if set, vim will put a "byte order mark" at the start
of ucs files. This option is irrelevant for most non-ucs files (utf-8,
iso-8859, etc.)

* 'termencoding' defines how your keyboard encodes what you type. The value
you put there will depend on your locale: iso-8859-15 is Latin1 + Euro currency
sign, but you may want something else for, say, an Eastern European keyboard.

* 'fileencodings' defines the heuristic to set 'fileencoding' (local to buffer)
when reading an existing file. The first one that matches will be used (and,
IIUC, if there is no match, Vim falls back on Latin1). Ucs-bom is "ucs with
byte-order-mark"; it must not come after utf-8 if you want it to be used.

4. Additional remarks --------------------- * In "replace" mode, one utf
character (one or more data bytes) replaces one utf character (which need
not use the same number of bytes)

* In "normal" mode, ga shows the character under the cursor as text, decimal,
octal and hex; g8 shows which byte(s) is/are used to represent it.

* In "insert" or "replace" mode,
  - any character defined on your keyboard can be entered the usual way
  (even with dead keys if you have them, e.g. French circumflex, German
  umlaut, etc.); - any character which has a "digraph" (there are a huge lot
  of them, see :dig after setting enc=utf-8) can be entered with a Ctrl-K
  prefix; - any utf character at all can be entered with a Ctrl-V prefix,
  either &lt;Ctrl-V&gt; u aaaa or &lt;Ctrl-V&gt; U bbbbbbbb, with 0 &lt;=
  aaaa &lt;= FFFF, or 0 &lt;= bbbbbbbb &lt;= 7FFFFFFF.

* Unicode can be used to create html "body text", at least for Netscape 6 and
probably for IE; but on my machine it doesn't display properly as "title text"
(i.e., between &lt;title&gt;&lt;/title&gt; tags in the &lt;head&gt; part).

* Gvim will display it properly if you have the fonts for it, provided
that you set 'guifont' to some fixed-width font which has the glyphs you
want to use (Courier New is OK for French, German, Greek, Russian and more,
but I'm not sure about Hebrew or Arabic; its glyphs are of a more "fixed"
width than those of, e.g. Lucida Console: the latter can be awkward if you
need bold Cyrillic writing).

Happy Vimming !  Tony.

</pre></tip> </html> <Tip category="KVim">
<html><center>Preexisting code indentation</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=247">http://vim.sf.net/tip_view.php?tip_id=247</A><BR>

Using tabs as elementary unit in your code indentation has two advantages:
first, you may modify 'tabstop' and immediately all the indentations depths
are modified according to it; second, your file will be smaller.

But how can we change some already-written code in order to convert spaces
to tabs. Very simple!  Suppose your old code has an indentation unit of
2 spaces :ret! 2 :x will replace every 2-spaces to one tab, independently
from your current tabstop value, and will save the modified file.  Then,
if you open again the file with tabstop=2, the file will look as before but
it will be smaller. If you open the file with tabstop=4, the code vill have
a more indented look, and so on...

Cheers!

</pre></tip> </html> <Tip category="KVim"> <html><center>Auto-save
the current buffer periodically.</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=248">http://vim.sf.net/tip_view.php?tip_id=248</A><BR>

I have no  idea if this was implemented  in vim 5.3 or not,  but you can
definitely  do the  following  kludge  in 6.x  by  using CursorHold  and
localtime:

- When you  start reading a file,  set a buffer variable  to the current
  time:

  au BufRead,BufNewFile * let b:start_time=localtime()

- Set a  CursorHold event  to check  to see if	enough time  has elapsed
  since the last save and save if not:

  au CursorHold * call UpdateFile()

- Define a function to save the file if needed:

  " only write if needed and update the start time after the save
  function! UpdateFile()
    if ((localtime() - b:start_time) &gt;= 60)
      update let b:start_time=localtime()
    else
      echo "Only " . (localtime() - b:start_time) . " seconds have elapsed
      so far."
    endif
  endfunction

- Reset the start time explicitly after each save.

  au BufWritePre * let b:start_time=localtime()

Obviously, you	should get rid of  the else portion once  you're certain
that this does indeed do what you wanted.

The  thing  to	note  is  that	the  CursorHold  will  only  fire  after
'updatetime' milliseconds  of inactivity have  elapsed. So, if	you type
rapidly for  one and  a half  minutes non-stop,  it won't  actually save
anything until you STOP activity long  enough. This may be what you want
anyway because it won't interrupt your activity with a forced save.

The actual save-delay can be changed from '60' to another number (in seconds)
or a variable or anything like that.  This entire functionality can be easily
wrapped inside a nice script which enables/disables this on a per-buffer basis
(maybe with maps etc.).  If desired, I can provide that also.

</pre></tip> </html> <Tip category="KVim"> <html><center>Quickly
insert #if 0 - #endif around block of code</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=249">http://vim.sf.net/tip_view.php?tip_id=249</A><BR>

One of my favorite macros that I use in vim (and vi) inserts a #if 0 #endif
sandwich around a block of code.  I always map this to the 2 key sequence ;'
which is the semi-colon followed by the single quote.  Look at your keyboard,
you will notice these keys are adjacent to one another.  I like this mapping
because it's very fast, my fingers easily roll from one key to the next,
obviously YMMV.

To use this mapping, go to the line of code that you want the '#if 0' to be
on, type ma to mark this line with the marker a, then move to the line that
should be last line just above the '#endif' and press ;'

    " insert #if 0 - #endif around block of code map ;' mz'aO&lt;Esc&gt;i#if
    0&lt;Esc&gt;'zo&lt;Esc&gt;i#endif&lt;Esc&gt;

-- David Thompson dat1965@yahoo.com

</pre></tip> </html> <Tip category="KVim">
<html><center>One big window</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=250">http://vim.sf.net/tip_view.php?tip_id=250</A><BR>

If you like to see your files in fullscreen, and you have to edit more files,
you can do the following.  * Use only one window * Open further files with :e *
type :nm &lt;A-Up&gt; :bp!&lt;CR&gt; * type :nm &lt;A-Down&gt; :bn!&lt;CR&gt;
* type :nm &lt;C-F4&gt; :bd!&lt;CR&gt; You can of course change the keys.
Now to switch between windows, you can press Alt-Up, and Alt-Down (Just in
the GUI, if you use console, don't use Alt key) Another idea is to map them
to Ctrl-Tab, and Ctrl-Shift-Tab To close the current file you can press Ctrl-F4

</pre></tip> </html> <Tip category="KVim"> <html><center>align
#endif with corresponding #if/#ifdef</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=251">http://vim.sf.net/tip_view.php?tip_id=251</A><BR>

If you try to impose any sort of alignment on your preprocessor directives,
rather than just starting them on column 0, this mapping will align the #endif
'correctly' when you type '#en', start a new line, and bring you back to
the correct alignment to edit code.

inoremap &lt;buffer&gt; #en
X&lt;BS&gt;&lt;Esc&gt;?#if&lt;CR&gt;"zy0^Og0"zpDa#endif&lt;CR&gt;X&lt;BS&gt;&lt;Esc&gt;?#end?-1&lt;CR&gt;^"zy0^O0"zpDa

I am reasonably sure this is insensitive to vim options...

</pre></tip> </html> <Tip category="KVim"> <html><center>python
script to align statements</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=252">http://vim.sf.net/tip_view.php?tip_id=252</A><BR>

i know there's some awk scripts out there that do the same thing, and if i
were a real trooper i would have written this in vims internal language but...

i wrote a python script to align statements.

i put this in my .vimrc: map L :!lineUp.py&lt;cr&gt;   " of course lineUp.py
is somewhere in my path

and i have this python file somewhere in my path: <A
HREF="http://ophinity.com/res/dotFiles/lineUp.py">http://ophinity.com/res/dotFiles/lineUp.py</A><BR>

so now i can just pipe the offending lines thru my code: :5, 10 !lineUp.py
or using the mapping above, visually select the lines and press 'L'

</pre></tip> </html> <Tip category="KVim"> <html><center>The
power of | (v75|r- actually...)</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=253">http://vim.sf.net/tip_view.php?tip_id=253</A><BR>

'|' as you may well be aware is the goto column motion, and that "75|"
will place your cursor on column 75 of the current line.

That in itself is pretty handy at times, but some true power arises when
used in conjuction with visual mode and replace. Or you could just say a
sneaky trick :)

v75|r- will repace from the cursor to the end of line with '-' *breakdown*
v to turn on visual mode 75 for the count | *bar* to goto column r to enter
repace - to specify the char to replace.

A handy and quick way to make a noticable section of your code (or whatever).

A handy way to use this (formated to just drop into DrChip's CStubs): "//
-[Feral]---------------------------------------------------------------
"// &lt;cursor&gt;
	elseif wrd == "//"
		exe "norm! a
		-[AuthorId]\&lt;esc&gt;$lv75|r-$a\&lt;cr&gt;\&lt;esc&gt;$a "

"// -[Feral:146/02@08:31]--------------------------------------------------
"// &lt;cursor&gt;
	elseif wrd == "///"
		exe "norm! s
		-[AuthorId:\&lt;C-R&gt;=strftime('%j/%y@%H:%M')\&lt;CR&gt;]\&lt;esc&gt;$lv75|r-$a\&lt;cr&gt;\&lt;esc&gt;$a
		"

"/* -[Feral:146/02@08:31]--------------------------------------------------
" * &lt;cursor&gt; " *
-------------------------------------------------------------------- */
	elseif wrd == "/*"
		exe "norm! a
		-[AuthorId:\&lt;C-R&gt;=strftime('%j/%y@%H:%M')\&lt;CR&gt;]\&lt;esc&gt;$lv75|r-$a\&lt;cr&gt;\&lt;cr&gt;\&lt;esc&gt;2lv72|r-$a
		*/\&lt;esc&gt;k$a "

Have to love VIM!

</pre></tip> </html> <Tip category="KVim"> <html><center>Using
\%[] to easily match parts of a word.</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=254">http://vim.sf.net/tip_view.php?tip_id=254</A><BR>

This code fragment is suitable to drop into DrChip's CStubs.
After much searching I was unable to find a tip nor script
number to referance, I believe where I found Dr. Chip's CStubs originally : <A
HREF="http://users.erols.com/astronaut/vim/vimscript/drcstubs.vim">http://users.erols.com/astronaut/vim/vimscript/drcstubs.vim</A><BR>
Thank you Dr. Chip! (=

If you have ever wanted to match parts of a word you may have considered
something like: if wrd == "re" || wrd == "ret" || wrd == "retu" || wrd ==
"retur"
   "do something

Althought the above works well enough it is a pain to maintain and add new
words (not to mention its just a touch messy ;) )

A more elegant (and easier to use I believe) method would be to use \%[]
as part of a pattern.

For instance, "\\&lt;re\\%[tur]\\&gt;" will match "re", "ret", "retu" or
"retur"

*breakdown* \\&lt; = start of word re = first letters of word we want to
require to match \\%[tur] = optionally match chars bewteen the braces,
i.e. 't', 'tu' or 'tur' \\&gt; = end of word

So, we can use this as a pattern for match like so (In DrChip's CStubs)

elseif match(wrd, "\\&lt;re\\%[tur]\\&gt;") &gt; -1
    exe "norm! bdWireturn\&lt;Esc&gt;"

Which, I think, is a little better than the longer alternative: "  vs elseif
wrd == "re" || wrd == "ret" || wrd == "retu" || wrd == "retur"
    exe "norm! bdWireturn\&lt;Esc&gt;"

Just another one of those VIM things that made me smile :)

</pre></tip> </html> <Tip category="KVim">
<html><center>arbitrary tags for file names</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=255">http://vim.sf.net/tip_view.php?tip_id=255</A><BR>

This definitely work on linux and there is probably some windows equivalent.
I've started working with tomcat and many many .jsp files.  I find this
trick to be very helpful.

find -name '*.jsp' -printf '%f\t%P\t1\n' |sort &gt; jsp.tags

This will create a file called jsp.tags with tag entries for each .jsp file.
Within Vim I use

:set tags+=jsp.tags

Now I can to simple :tag file.jsp to quickly switch b/w the many, many
.jsp files.

One important note.  The utility sort will use the value of LC_COLLATE to sort
according to your locale.  This will give Vim issues.  So try "LC_COLLATE=C
sort" instead of plain "sort"

</pre></tip> </html> <Tip category="KVim"> <html><center>Opening
current Vim file in your Windows browser</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=256">http://vim.sf.net/tip_view.php?tip_id=256</A><BR>

Hi Vimmers

open current file in browser

map ,f	 :update&lt;CR&gt;:silent !start c:\progra~1\intern~1\iexplore.exe
file://%:p&lt;CR&gt;

open http link under cursor in your browser

map ,i	 :update&lt;CR&gt;: !start c:\progra~1\intern~1\iexplore.exe
&lt;cWORD&gt;&lt;CR&gt;

Note use of cWORD (not cword) meaning OUTER Word

Works for me in XP & 98 (Original came from a posting by Ralf Arens)

zzapper

</pre></tip> </html> <Tip category="KVim">
<html><center>fast page up/down.</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=257">http://vim.sf.net/tip_view.php?tip_id=257</A><BR>

i discovered a cool way to move between pages of the same document in vim
6.1. press a number in -normal mode- and the page up/down. the document
will move with that number of pages up/down.if the number is greater that
the nr of pages, document will move to begin/end of file.  i didn't test it
on other version.

</pre></tip> </html> <Tip category="KVim"> <html><center>how
long is the current word?</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=258">http://vim.sf.net/tip_view.php?tip_id=258</A><BR>

ever wondered how long the current word is?  this can be quite useful when
editing data files.  simply add the following to your .vimrc

nmap &lt;C-_&gt; :echo 'word' expand("&lt;cword&gt;") '  wordlen ='
strlen(expand("&lt;cword&gt;"))&lt;CR&gt;

and it will tell you the word under the cursor, and how long it is.

and for things that arent words, this addition to your .vimrc works on
sections of a line that have been hightligted in visual mode

vmap &lt;C-_&gt; "-y:echo 'word' @- '  wordlen =' strlen(@-)&lt;CR&gt;

again you see the "word", and its length this may also work on vim 5.x,
but i havent checked to make sure.

</pre></tip> </html> <Tip category="KVim"> <html><center>removing
the toolbar (icons) from gvim</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=259">http://vim.sf.net/tip_view.php?tip_id=259</A><BR>

Change good or bad usually  encounters interia from people in excepting it.
gvim 6.0 is the first version that introduced the icons shortcut in shape
of a toolbar under the menu.  when we upgraded to the new and improved vim
6.1 from vim 5.7 some of people in our company encountered some problems
with their syntax highlighting and some of them objected on the new toolbar
which displayed icons for some common tasks for people more used to GUI.

I finally figured out how to remove this new feature since I also didn't
see much use for it

Here is for all those who haven't figured it out yet

In your .gvimrc include the following two lines

unmenu ToolBar unmenu! ToolBar

Doing this from an open gvim does not remove them but grays them out but
doing from gvimrc does the job

I was also trying to remove the menus at the top and almost succeeded with
a similar technique but somehow the Buffer menu item stays there no matter
what. IMHO it is a bug but it could very well be a feature ;)

I tried this

unmenu * unmenu! *

even added this line after the above two but didn't help unmenu Buffers

I hope this benefits you all as much as I have benefitted from all your tips

</pre></tip> </html> <Tip category="KVim">
<html><center>gvim--&gt;mouse--&gt;popup menu</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=260">http://vim.sf.net/tip_view.php?tip_id=260</A><BR>

This tip is for those who prefer to do some of the common operations like
cut/copy/paste etc using mouse. All u have to do is

 :set mousemodel=popup

by this u get a popup menu on right click of your mouse and u can do all
the common operations like undo, cut, copy, paste, select etc using mouse.

u can also customise your popup menu by editing $VIMRUNTIME/menu.vim

</pre></tip> </html> <Tip category="KVim"> <html><center>Close
windows from  Gvim poup menu</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=261">http://vim.sf.net/tip_view.php?tip_id=261</A><BR>

To close windows from the popup menu add these lines to your .gvimrc

:amenu PopUp.Close.\ Window :confirm close&lt;CR&gt; :amenu PopUp.Close.\
Other  :confirm only&lt;CR&gt;

You obviously need ':set mousemodel=popup' in your .gvimrc as well :=)

</pre></tip> </html> <Tip category="KVim"> <html><center>Bored
of ur arrow shapped mouseptr?</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=262">http://vim.sf.net/tip_view.php?tip_id=262</A><BR>

here is how u can change the shape of ur mouseptr in gvim.

:set mouseshape=n:pencil

this will change the shape of the mouseptr to pencil in normal mode.  u can
choose different shapes for different modes. see :h mouseshape

Want more shapes?

Then look for the file cursorfont.h in ur X11/ directory.  This file contains
lots of cursor shape #define definitions, like .  #define XC_heart 62 .
now :set mouseshape=n:62 will set the shape of the mouseptr to heart in
normal mode.

-ncr

</pre></tip> </html> <Tip category="KVim">
<html><center>color active line</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=263">http://vim.sf.net/tip_view.php?tip_id=263</A><BR>

This tip shows how to color the active line, the line in which the cursor
is, for better reading.  You should try possibility 2 before 1, IMHO it is
mostly usable.

possibility 1:
     :au! CursorHold * let @/ = '\%' . line('.') . 'l.*' :set ut=500

explanation:
     After 500 ms of waiting for you to hit a key, vim sets the search
     register to a pattern that matches the current line.

problem:
     Register / holds the search pattern, so you cannot have color the active
     line and search.  Therefore another solution:

possibility 2:
     :highlight CurrentLine guibg=darkgrey guifg=white	   (or whatever
     colors you want) :au! Cursorhold * exe 'match CurrentLine /\%'
     . line('.') . 'l.*/' :set ut=100

explanation:
     This solution uses 'match' to highlight a string, it does not interface
     with the current search pattern.

addition:
     Turning the highlighning off:
	  :au! Cursorhold :match none
     The order of these commands are important. If :match none is executed
     first, the autocommand would almost immediately execute another match
     command.

references to vim help:
     :help Cursorhold :help 'ut' :help /\%l :help "/ :help \%

</pre></tip> </html> <Tip category="KVim"> <html><center>F5
Compile and Run, F8 Compile (ala Visual Studio)</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=264">http://vim.sf.net/tip_view.php?tip_id=264</A><BR>

I love vim, it's my default editor on my Sun, Windows, Linux and *BSD boxen.
That said, I hate having to flip windows to compile while doing the
write-&gt;compile-&gt;debug loop.

If you're used to Visual Studio and the ability it has to just hit F5 to
compile and run the current file or F8 to compile or step through the code
you'll appreciate this...

This is my Windows version of this scriplet/tiplet.  For other platforms,
you'll want to change the IF ELSE loops.  You should actually never see
the "Unsuccessful" message from the compile/run loop unless the compiler
completely bombs out.	This is from my _vimrc...

map &lt;F5&gt; :call CompileRunGcc()&lt;CR&gt;

map &lt;F8&gt; : call CompileGcc()&lt;CR&gt;

func! CompileRunGcc()
		exec "w"   "Save the file exec "!gcc % -o %&lt; && cr 10 && IF
		EXIST %&lt;.exe (%&lt;) ELSE banner -c = Compile Unsuccessful
		" exec "i" "jump back where we were


endfunc

func! CompileGcc()
		exec "w" exec "!gcc % -o %&lt;	&& IF EXIST %&lt;.exe (cr 5 &&
		banner -c # Success) ELSE banner -c # Compile Unsuccessful
		" exec "i"

endfunc

</pre></tip> </html> <Tip category="KVim">
<html><center>Fast help in full window</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=265">http://vim.sf.net/tip_view.php?tip_id=265</A><BR>

You can get fast access to help by writing small script

#!/bin/bash vim -c "help $1" -c only

now name it eg. vih and from cl

$ vih makeprg

</pre></tip> </html> <Tip category="KVim">
<html><center>use -S command line switch</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=266">http://vim.sf.net/tip_view.php?tip_id=266</A><BR>

The -S switch could be used to simplify common idiom: start Vim and source
a script file: gvim -c ":so foobar.vim" got translated into gvim -S foobar.vim

Yes, this tip is trivial but I still see the -c ":so x" way too often. Time
to update your mind!

</pre></tip> </html> <Tip category="KVim">
<html><center>selectively displaying abbreviations</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=267">http://vim.sf.net/tip_view.php?tip_id=267</A><BR>

Hi Vimmers, abbreviations have always been one of the most useful parts of
vi(m), trouble is when you've got too many you forgot what you called them.

You can of course list the whole lot with

:ab&lt;cr&gt;

But did you know that you can type the first few letters of your abbreviations
and get a list of just thos abs eg

:ab php&lt;cr&gt; gives me all my php abs & :ab perl&lt;cr&gt; gives me all
my perls

also try control-D instrad of &lt;cr&gt;

zzapper

</pre></tip> </html> <Tip category="KVim"> <html><center>Get cursor
position as byte percentage instead of line percentage</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=268">http://vim.sf.net/tip_view.php?tip_id=268</A><BR>

On line 300 of a thousand line file, Vim will show you that you're 30%
through the file.  But what if most of the lines have one character in them,
and some of them have twenty thousand?	Sometimes it comes in handy to know
your percentage through the file in terms of current-byte / total-bytes.
I looked through the Vim docs and couldn't find a way to do this, so I wrote
a Vim function to show it.

Put this in your .vimrc:

function! Percent()
    let byte = line2byte( line( "." ) ) + col( "." ) - 1 let size = (line2byte(
    line( "$" ) + 1 ) - 1) " return byte . " " . size . " " . (byte * 100)
    / size return (byte * 100) / size
endfunction

(Uncomment the first return to see intermediate values.)

And put this somewhere in your "set statusline=...":

    %{Percent()}%%

See "help statusline", "help eval".

</pre></tip> </html> <Tip category="KVim"> <html><center>Syntax highlighting
is "out of sync", seems to correct itself with refresh ??</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=269">http://vim.sf.net/tip_view.php?tip_id=269</A><BR>

This one has come across the 'vim' users mailing list many times, and probably
comp.editors as well...

Summary: see :help :syn-sync and search for 'sync' in your favorite syntax
file in $VIMRUNTIME/syntax

Long Version: The syntax highlight code utilizes a certain synchronization
method to efficiently figure out syntax highlighting, specifically if you
aren't at the very beginning or end of a file.	The specific setting is 'syntax
sync'.	For various file types the method is set by default in this is setup
in the syntax file and one can vary the degree of trouble which VIM goes to to
try and figure this out.  As an example for C, from $VIMRUNTIME/syntax/c.vim:

if exists("c_minlines")
  let b:c_minlines = c_minlines
else
  if !exists("c_no_if0")
    let b:c_minlines = 50	" #if 0 constructs can be long
  else
    let b:c_minlines = 15	" mostly for () constructs
  endif
endif exec "syn sync ccomment cComment minlines=" . b:c_minlines

Where c_minlines is the minimum number of lines that VIM goes backward to try
to find the start of a comment for syntax highlighting.  If that line which
starts a comment is outside of that range, highlighting will appear wrong.

You can easily set up something like this in your .vimrc: let c_minlines=500
or even bigger, but realize that it is a performance trade-off and that
syntax highlighting will slow things down.

</pre></tip> </html> <Tip category="KVim">
<html><center>Insert a single character</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=270">http://vim.sf.net/tip_view.php?tip_id=270</A><BR>

Using Insert mode to insert a single character feels clumsy (you need 3
keypresses for one character), so here's a slightly easier way:

:nmap &lt;space&gt; i_&lt;esc&gt;r

Now, when in Normal mode, just press space followed by what it is you want
to insert.

BUG: Repeating the insertion with . doesn't work.

</pre></tip> </html> <Tip category="KVim"> <html><center>easy
(un)commenting out of source code</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=271">http://vim.sf.net/tip_view.php?tip_id=271</A><BR>

Something that I do quite alot is comment out blocks of text, only to uncomment
that same block later. The following mappings have proven useful to me. They
can be applied using visually selected blocks, or with motion keys.

" lhs comments map ,# :s/^/#/&lt;CR&gt; map ,/ :s/^/\/\//&lt;CR&gt; map ,&gt;
:s/^/&gt; /&lt;CR&gt; map ," :s/^/\"/&lt;CR&gt; map ,% :s/^/%/&lt;CR&gt;
map ,! :s/^/!/&lt;CR&gt; map ,; :s/^/;/&lt;CR&gt; map ,- :s/^/--/&lt;CR&gt;
map ,c :s/^\/\/\\|^--\\|^&gt; \\|^[#"%!;]//&lt;CR&gt;

" wrapping comments map ,* :s/^\(.*\)$/\/\* \1 \*\//&lt;CR&gt; map ,(
:s/^\(.*\)$/\(\* \1 \*\)/&lt;CR&gt; map ,&lt; :s/^\(.*\)$/&lt;!--
\1 --&gt;/&lt;CR&gt; map ,d :s/^\([/(]\*\\|&lt;!--\) \(.*\)
\(\*[/)]\\|--&gt;\)$/\2/&lt;CR&gt;

The commands to comment a selection of text are as follows, begining with
begining-of-line comments:

    ,#	  shell, perl, etc ,/	  c++ ,&gt;    email quote ,"	  vim ,%
    latex, prolog ,!	  assembly?... add single !  ,;      scheme ,-
    don't remember this one... add -- ,c     clears any of the previous
    comments

Here are the wrapping comments, each line wrapped individually:

    ,*	    c ,(       Standard ML ,&lt;      html ,d	   clears any of
    the wrapping comments

</pre></tip> </html> <Tip category="KVim"> <html><center>automaticaly
formating pasted text (p=`])</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=272">http://vim.sf.net/tip_view.php?tip_id=272</A><BR>

In times past I used a nice editor that had the neat feature of automatically
setting pasted text to the proper indent level. Recently I've begun to miss
this so I went looking in the help and camp up with....

=`]

which will format to the end of the pasted text... Perfect to call right
after you past something as the cursor ends up at the top of the pasted text,
thus the mapping:

:map &lt;c-p&gt; =`]

" by the by the above may should be nmap and I am pretty sure c-p is unused,
your mileage will vary no doubt.

However I wanted the formatting to automatically be done so it was two simple
(once I figured out how!) nnoremap:

" [Feral:185/02@14:27] map c-p to what p was (past with no formatting), map
p to p and = to end of pasted text.  :nnoremap p p=`] :nnoremap &lt;c-p&gt; p

This simply (as the comment hints at) maps normal mode p to what p did (paste)
then = to `] (last character in the previously changed text). While ctrl+p
just does what p did. (just in case you find you don't want a bit of text
auto formatted.).

reference: :h :nnoremap :h p :h = :h `]

Whatever the name of this idea is, tis something I find handy :)

Happy VIMing

</pre></tip> </html> <Tip category="KVim"> <html><center>Fast
fixing of email quotations (too long lines)</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=273">http://vim.sf.net/tip_view.php?tip_id=273</A><BR>

When using VIM as your editor of choice, even for email processing - as I
do - it is often unpleasing how some MUA's quote the email body produced by
mailers such as Outlook. The lines often span across multiple visual lines
and its difficult to reply on certain parts of it.

With VIM, you can quickly fix those quotations to maintain a proper 75 char
break. For example, when using Mutt, put this line in your .muttrc, or use
a custom .vimrc_mail for it:

set editor="vim -c 'set fo=tcrq' -c 'set tw=76'"

For other MUA's this has to be fitted. However, now, when your quoted email
is displayed, you can use this VIM sequence to fix it:

1. move cursor to first line of broken paragraph 2. press 'V' and move to the
last line of the paragraph you want to fix 3. press 'g' and then 'q'. The
marked text will wrap around to your specified textwidth (76 in our case)
and the quotations will be preserved across the lines

</pre></tip> </html> <Tip category="KVim">
<html><center>Some useful mappings for TeX</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=274">http://vim.sf.net/tip_view.php?tip_id=274</A><BR>

You know, TeX requires a lot of additional formatting code. I'm tired of
opening and closing braces, brakets,
 \beginning and \ending etc. I particularly hate typing \begin and \end.
To help myself and to save a few(not a few) keystrokes I naturaly came up to
some solutions, which I wish to share with other TeXnicians and TeXperts whhich
use Vim.  "===============================cut here=========================
"=============== you can put it in ~/.vim/after/ftplugin/tex.vim
=============== " " Note: i_&lt;C-L&gt; " This constructs a skeleton of a TeX
environment.  " You write a line like this: " floatingfigure:ht&lt;C-L&gt;
" and after you press &lt;C-L&gt;, you get: " " \begin[ht]{floatingfigure}
" " \end{floatingfigure} " -- INSERT -- " " where floatingfigure is the
desired environment " ht are options " : is delimiter; in fact, you can
use whatever delimiter you want " as long it is not in &iskeyword option.
inoremap &lt;buffer&gt; &lt;C-L&gt; 
			\:s/[^][:alnum:]&lt;bar&gt;]\+/,/eg
			\I\begin{ea}[A]%d%%P \:s/\[,/[/e \:s/,]/]/e
			\:s/\[]//e \0f{y%o\endpO
inoremap &lt;buffer&gt; { {}i inoremap &lt;buffer&gt; [ []i inoremap
&lt;buffer&gt; ^ ^{}i inoremap &lt;buffer&gt; _ _{}i inoremap &lt;buffer&gt;
\( \(\)hi inoremap &lt;buffer&gt; \[ \[\]hi

" Note: v_&lt;C-L&gt; " For this to work, you have to write on a blank
line the name of " the desired environment and options (see i_&lt;C-L&gt;)
and visual select " (from top to bottom) this and following lines.  " After
pressing &lt;C-L&gt; the selected lines will be surrounded " with begin/end
skeleton of the environment.  vnoremap &lt;buffer&gt; &lt;C-L&gt; o
			\:s/[^][:alnum:]&lt;bar&gt;]\+/,/eg
			\I\begin{ea}[A]%d%%P \:s/\[,/[/e \:s/,]/]/e
			\:s/\[]//e \0f{y%gvoo\endp
"	vnoremap &lt;buffer&gt; { di{}P "	 vnoremap &lt;buffer&gt;
[ di[]P vnoremap &lt;buffer&gt;  di^{}P vnoremap &lt;buffer&gt;  di_{}P
vnoremap &lt;buffer&gt; \( di\(\)hP vnoremap &lt;buffer&gt; \[ di\[\]hP

" This makes "two spaces after a comma" before every :write au BufWritePre
*.tex %s/,\(\S\)/, \1/ge

"==================== You can put this in your ~/.vimrc
======================== " If cursor is inside braces and not before comma,
blank or opening brace, " exit the brace block and stay in insert mode.  "
If cursor is outside braces, it inserts a space or perform an abbreviation
" as normal.  function! CleverSpace()
	let CharOnCursor = strpart( getline('.'), col('.')-2, 1) let
	CharAfterCursor = strpart( getline('.'), col('.'), 1) if CharOnCursor
	!~ ',\|\s\|(' && CharAfterCursor =~ ')\|]\|}'
		normal x
	endif
endfunction inoremap &lt;Space&gt; &lt;Space&gt;:call CleverSpace()&lt;LF&gt;a

" I use the last function not only for LaTeX but also in C sources.

</pre></tip> </html> <Tip category="KVim">
<html><center>Some useful mappings for TeX</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=275">http://vim.sf.net/tip_view.php?tip_id=275</A><BR>

You know, TeX requires a lot of additional formatting code. I'm tired of
opening and closing braces, brakets,
 \beginning and \ending etc. I particularly hate typing \begin and \end.
To help myself and to save a few(not a few) keystrokes I naturaly came up to
some solutions, which I wish to share with other TeXnicians and TeXperts whhich
use Vim.  "===============================cut here=========================
"=============== you can put it in ~/.vim/after/ftplugin/tex.vim
=============== " " Note: i_&lt;C-L&gt; " This constructs a skeleton of a TeX
environment.  " You write a line like this: " floatingfigure:ht&lt;C-L&gt;
" and after you press &lt;C-L&gt;, you get: " " \begin[ht]{floatingfigure}
" " \end{floatingfigure} " -- INSERT -- " " where floatingfigure is the
desired environment " ht are options " : is delimiter; in fact, you can
use whatever delimiter you want " as long it is not in &iskeyword option.
inoremap &lt;buffer&gt; &lt;C-L&gt; 
			\:s/[^][:alnum:]&lt;bar&gt;]\+/,/eg
			\I\begin{ea}[A]%d%%P \:s/\[,/[/e \:s/,]/]/e
			\:s/\[]//e \0f{y%o\endpO
inoremap &lt;buffer&gt; { {}i inoremap &lt;buffer&gt; [ []i inoremap
&lt;buffer&gt; ^ ^{}i inoremap &lt;buffer&gt; _ _{}i inoremap &lt;buffer&gt;
\( \(\)hi inoremap &lt;buffer&gt; \[ \[\]hi

" Note: v_&lt;C-L&gt; " For this to work, you have to write on a blank
line the name of " the desired environment and options (see i_&lt;C-L&gt;)
and visual select " (from top to bottom) this and following lines.  " After
pressing &lt;C-L&gt; the selected lines will be surrounded " with begin/end
skeleton of the environment.  vnoremap &lt;buffer&gt; &lt;C-L&gt; o
			\:s/[^][:alnum:]&lt;bar&gt;]\+/,/eg
			\I\begin{ea}[A]%d%%P \:s/\[,/[/e \:s/,]/]/e
			\:s/\[]//e \0f{y%gvoo\endp
"	vnoremap &lt;buffer&gt; { di{}P "	 vnoremap &lt;buffer&gt;
[ di[]P vnoremap &lt;buffer&gt;  di^{}P vnoremap &lt;buffer&gt;  di_{}P
vnoremap &lt;buffer&gt; \( di\(\)hP vnoremap &lt;buffer&gt; \[ di\[\]hP

" This makes "two spaces after a comma" before every :write au BufWritePre
*.tex %s/,\(\S\)/, \1/ge

"==================== You can put this in your ~/.vimrc
======================== " If cursor is inside braces and not before comma,
blank or opening brace, " exit the brace block and stay in insert mode.  "
If cursor is outside braces, it inserts a space or perform an abbreviation
" as normal.  function! CleverSpace()
	let CharOnCursor = strpart( getline('.'), col('.')-2, 1) let
	CharAfterCursor = strpart( getline('.'), col('.'), 1) if CharOnCursor
	!~ ',\|\s\|(' && CharAfterCursor =~ ')\|]\|}'
		normal x
	endif
endfunction inoremap &lt;Space&gt; &lt;Space&gt;:call CleverSpace()&lt;LF&gt;a

" I use the last function not only for LaTeX but also in C sources.

</pre></tip> </html> <Tip category="KVim">
<html><center>Function signature previewer</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=276">http://vim.sf.net/tip_view.php?tip_id=276</A><BR>

Have you ever tried to call a function which parameters you have forgotten?
Especially those long named and with long parameter list GTK+ functions
like gtk_menu_item_image_from_stock_new(..........) !!!  By accident I saw a
function in Vim help. It's name was PreviewWord and it allowed one to jump
in the preview window to the tag for the word cursor is on.  I _slightly_
modified this function not to need tags file, but to search included files
instead.  I wrote another function, which uses the above said one, which
triggers PreviewWord when you open the parenthesis after a function name.
Here it is: " Note: " This is literally stolen from Vim help. The only
changes are: " (1) if w != ""		    becomes	  if w =~ "\k" "
(2) exe "silent! ptag " . w  becomes	   exe "silent! psearch " . w " *
The first change prevents PreviewWord of searching while cursor is on some "
non-keyword characters, e.g. braces, asterisks, etc.  function! PreviewWord()
	if &previewwindow			" don't do this in the
	preview window
		return
	endif let w = expand("&lt;cword&gt;")	      " get the word under
	cursor if w =~ "\k"			       " if there is one
	":ptag" to it

		" Delete any existing highlight before showing another tag
		silent! wincmd P			" jump to preview
		window if &previewwindow		       " if we really
		get there...
			match none			" delete existing
			highlight wincmd p			  " back to
			old window
		endif

		" Try displaying a matching tag for the word under the cursor
		let v:errmsg = "" exe "silent! psearch " . w if v:errmsg =~
		"tag not found"
			return
		endif

		silent! wincmd P			" jump to preview
		window if &previewwindow	       " if we really get
		there...
			if has("folding")
				silent! .foldopen		" don't want
				a closed fold
			endif call search("$", "b")	      " to end of
			previous line let w = substitute(w, '\\', '\\\\',
			"") call search('\&lt;\V' . w . '\&gt;')    "
			position cursor on match " Add a match highlight to
			the word at this position hi previewWord term=bold
			ctermbg=green guibg=green exe 'match previewWord "\%'
			. line(".") . 'l\%' . col(".") . 'c\k*"' wincmd p
			" back to old window
		endif
	endif
endfunction au! CursorHold *.[ch] nested call PreviewWord()

" Note: " When you open a parenthesis after a function name, and
at the " line end, that function's definition is previewed through
PreviewWord().	" This is inspired from Delphi's CodeInsight technology.
" Something similar (PreviewClassMembers) could be written for " the C++
users, for previewing the class members when you type " a dot after an
object name.  " If somebody decides to write it, please, mail it to me.
function! PreviewFunctionSignature()
	let CharOnCursor = strpart( getline('.'), col('.')-2, 1) if col(".") ==
	col("$")
		call PreviewWord()
	endif return "("
endfunction inoremap &lt;buffer&gt; (
&lt;C-R&gt;=PreviewFunctionSignature()&lt;LF&gt;

</pre></tip> </html> <Tip category="KVim">
<html><center>Function signature previewer</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=277">http://vim.sf.net/tip_view.php?tip_id=277</A><BR>

Have you ever tried to call a function which parameters you have forgotten?
Especially those long named and with long parameter list GTK+ functions
like gtk_menu_item_image_from_stock_new(..........) !!!  By accident I saw a
function in Vim help. It's name was PreviewWord and it allowed one to jump
in the preview window to the tag for the word cursor is on.  I _slightly_
modified this function not to need tags file, but to search included files
instead.  I wrote another function, which uses the above said one, which
triggers PreviewWord when you open the parenthesis after a function name.
Here it is: " Note: " This is literally stolen from Vim help. The only
changes are: " (1) if w != ""		    becomes	  if w =~ "\k" "
(2) exe "silent! ptag " . w  becomes	   exe "silent! psearch " . w " *
The first change prevents PreviewWord of searching while cursor is on some "
non-keyword characters, e.g. braces, asterisks, etc.  function! PreviewWord()
	if &previewwindow			" don't do this in the
	preview window
		return
	endif let w = expand("&lt;cword&gt;")	      " get the word under
	cursor if w =~ "\k"			       " if there is one
	":ptag" to it

		" Delete any existing highlight before showing another tag
		silent! wincmd P			" jump to preview
		window if &previewwindow		       " if we really
		get there...
			match none			" delete existing
			highlight wincmd p			  " back to
			old window
		endif

		" Try displaying a matching tag for the word under the cursor
		let v:errmsg = "" exe "silent! psearch " . w if v:errmsg =~
		"tag not found"
			return
		endif

		silent! wincmd P			" jump to preview
		window if &previewwindow	       " if we really get
		there...
			if has("folding")
				silent! .foldopen		" don't want
				a closed fold
			endif call search("$", "b")	      " to end of
			previous line let w = substitute(w, '\\', '\\\\',
			"") call search('\&lt;\V' . w . '\&gt;')    "
			position cursor on match " Add a match highlight to
			the word at this position hi previewWord term=bold
			ctermbg=green guibg=green exe 'match previewWord "\%'
			. line(".") . 'l\%' . col(".") . 'c\k*"' wincmd p
			" back to old window
		endif
	endif
endfunction au! CursorHold *.[ch] nested call PreviewWord()

" Note: " When you open a parenthesis after a function name, and
at the " line end, that function's definition is previewed through
PreviewWord().	" This is inspired from Delphi's CodeInsight technology.
" Something similar (PreviewClassMembers) could be written for " the C++
users, for previewing the class members when you type " a dot after an
object name.  " If somebody decides to write it, please, mail it to me.
function! PreviewFunctionSignature()
	let CharOnCursor = strpart( getline('.'), col('.')-2, 1) if col(".") ==
	col("$")
		call PreviewWord()
	endif return "("
endfunction inoremap &lt;buffer&gt; (
&lt;C-R&gt;=PreviewFunctionSignature()&lt;LF&gt;

</pre></tip> </html> <Tip category="KVim">
<html><center>all the right moves</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=278">http://vim.sf.net/tip_view.php?tip_id=278</A><BR>

One of the principles of effective text editing is moving around very
efficiently.  Following are some pointers which may help u do that.

    h	   move one character left j	   move one row down
   k	   move one row up l	     move one char. right.  w	    move
   to begining of next word b	    move to begining of previous word
   e	   move to end of word W     move to begining of next word after a
   whitespace B      move to begining of pervious word before a whitespace
   E	  move to end of word before a whitespace.

(All the above movements can be preceeded by a numeric value . i.e  '4j'
will move 4 rows down )

   ^	    move to first non blank char of the line.  g_      move to last non
   blank char of the line.  0	     moev to begining of line $        move
   to end of line.  gg	    move to first line.  G	  move to last line.
   nG	   move to "n"th line.	H	 top of screen.
  M	    middle of screen
   L	    bottom of screen
    Ctrl-D   move half page down Ctrl-U   move half page up.  Ctrl-B   page-up
    Ctrl-F   page down.

     Ctrl-o  last cursor position.  '[a-z,0-9,A-Z]    jump to the marker. (u
     can set a marker on line by :-   m[a-zA-Z,0-9] and then jump back to
     it by '[a-z,A-Z0-9]

      n   next matching search pattern N  previous matching search pattern *
      next word under cursor
     #	  previous word under cursor.  g*   next matching search pattern
     under cursor.  g#	previous matching search pattern under cursor.

</pre></tip> </html> <Tip category="KVim"> <html><center>On Windows, make GVim
the default action for double-click with "unknown file types"</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=279">http://vim.sf.net/tip_view.php?tip_id=279</A><BR>

I find myself installing the following registry modification for all my
PC's now (even other people's PC's).  It applies to Microsoft Windows
machines only.	The following is also for Windows 9x...  NT or XP or 2000
may require modifications (which I don't care to understand!).

The problem: You double-click on a file that doesn't have a 'registered type'
and that pesky "What program should I use?" dialog pops up.  Even worse,
depending on the installation, the GVim icon may not be listed, and one has
to browse to the executable...	and then the type becomes forever bonded
to being editted with GVim (if that box is checked).  The standard Vim 6.1
installation does include a "right click to edit" menu item for all files,
but a double-click is so much faster!

The solution: What if unregistered types would just automatically open up
in GVim?  Well, they can..  with a little registry trickery.

How to Install it:

Step 1. Create a text file called "vimalways.reg" and paste the below text
into it.

Step 2.  Important NOTE: You will have to edit the pathname to correspond
to the pathname of your GVim.exe.  The text below works fine for a GVim 6.1
default installation.

Step 3: Save the file.

Step 4: Right-click on the file and select "install".  Then you are done!

------ vimalways.reg  ------- cut here ------snip---snip--- REGEDIT4

[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\*\shell]

[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\*\shell\Open with &GVim] @="Open
with &GVim"

[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\*\shell\Open with &GVim\command]
@="\"C:\\vim\\vim61\\gvim.exe\" \"%1\""

----end of file---- cut here----- snip---snip----

Note 1.  This can't be de-installed automatically, and if you want to remove
it, you'll have to edit the registry by hand (annoying, but easy).

Note 2.  Keep this file around, so when you upgrade your GVim, all you have
to do is modify the pathname (to say, for example, vim62) and then install
it again.

Ok, thanks for playing!  And thanks to the author(s) of Vim and GVim.
If it weren't for them, I'd still be using elvis or stevie!


</pre></tip> </html> <Tip category="KVim"> <html><center>Integration
with PyUnit testing framework</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=280">http://vim.sf.net/tip_view.php?tip_id=280</A><BR>

Vim has a wonderful ability to integrate with external tools, like compilers,
make, ctags etc.  That's one of the reasons we love it.

PyUnit can be seen as a "compiler" for the Python test code.  To understand
it, Vim should be told about the language the PyUnit speaks. This could be
done with 'errorformat' option:

setlocal efm=%C\ %.%#,%A\ \ File\ \"%f\"\\,\ line\ %l%.%#,%Z%[%^\ ]%\\@=%m

This magic spell enables Vim to parse unittest.TextRunner's output and to
enter quick-fix mode.  To run all your unit tests at once you'll need to setup
'makeprg' option and provide a runner.	I'm using this setup:

setlocal makeprg=./alltests.py

And contents of the alltests.py (for the sake of completeness):

#!/usr/bin/env python2

import unittest import sys sys.path.append('unittests')

modules_to_test = (
	'fooTest', 'barTest', 'bazTest',
)

def suite():
    alltests = unittest.TestSuite() for module in map(__import__,
    modules_to_test):
	alltests.addTest(unittest.findTestCases(module))
    return alltests

if __name__ == '__main__':
    unittest.main(defaultTest='suite')

============== end of the alltests.py file ========================

While talking about it, I'd also suggest to add a couple of mappings.
In the end, my vim/files/ftplugin/python.vim looks like this:

setlocal makeprg=./alltests.py\ -q setlocal efm=%C\ %.%#,%A\ \ File\ \"%f\"\\,\
line\ %l%.%#,%Z%[%^\ ]%\\@=%m iabbr &lt;buffer&gt; sae self.assertEquals
iabbr &lt;buffer&gt; sar self.assertRaises

For details see :help quick-fix,  :help
'efm' and  :help 'makeprg'.  See also:	<A
HREF="http://c2.com/cgi/wiki?PythonUnit">http://c2.com/cgi/wiki?PythonUnit</A><BR>

Many thanks to Stefan Roemer who patiently spent quite some time to build
'efm' for me.

</pre></tip> </html> <Tip category="KVim">
<html><center>Stateful zz</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=281">http://vim.sf.net/tip_view.php?tip_id=281</A><BR>

Do you find yourself hitting 'zz' all the time in order to see some context of
what you're currently working on? If so, then this tip might be for you. If
you add the following line in your vimrc, you can toggle zz mode by pressing
&lt;Leader&gt;zz.

" maintain a constant zz state, second call will toggle it back off map
&lt;Leader&gt;zz    :let &scrolloff=999-&scrolloff&lt;CR&gt;

</pre></tip> </html> <Tip category="KVim">
<html><center>Folding with Regular Expression</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=282">http://vim.sf.net/tip_view.php?tip_id=282</A><BR>

Well, I've tried to understand some of the folding scripts, but life's too
short. Instead, I added the following lines to my vimrc file.

set
foldexpr=(getline(v:lnum)=~@/)?0:(getline(v:lnum-1)=~@/)\|\|(getline(v:lnum+1)=~@/)?1:2
map \z :set foldmethod=expr foldlevel=0 foldcolumn=2&lt;CR&gt;

The first line is an extension of foldexpr=(getline(v:lnum)=~@/)?0:1 The
second line (re)sets the foldmethod to expr(ession) plus.

First search for /regexp/, then fold everything else with \z Use zr to reveal
more context (before/after) lines.

You could add (getline(v:lnum-2)=~@/)\|\|(getline(v:lnum+2)=~@/)?2:3 but it
will take longer as folded lines (the majority) evaluate the full expression.

What could be easier?

</pre></tip> </html> <Tip category="KVim"> <html><center>Turn
on syntax coloring in Mac OS X</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=283">http://vim.sf.net/tip_view.php?tip_id=283</A><BR>

This tip is actually for vim 6.1. To turn on syntax coloring in Mac OS X
enter the following commands, or place them in your $HOME/.vimrc file.

:set term=builtin_beos-ansi :syntax on

</pre></tip> </html> <Tip category="KVim"> <html><center>Mapping
to print syntax highlighted buffer in B&W</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=284">http://vim.sf.net/tip_view.php?tip_id=284</A><BR>

I use this mapping to print syntax highlighted C++ code in B&W This tip
needs vimscript #233 print_bw.

The mapping is as follows map &lt;C-p&gt; :color
print_bw&lt;CR&gt;:hardcopy&lt;CR&gt;:color sean&lt;CR&gt;:syn on&lt;CR&gt;

Change ":color sean" to whatever is your chosen color scheme.  Need to
change line 7 of print_bw from "syntax reset" to "syntax off" &lt;C-p&gt;
on a syntax highlighted buffer turns off syntax highlighting , sets the
colors to B&W, prints the buffer, resets the color scheme and turns on syntax
highlighting again.

</pre></tip> </html> <Tip category="KVim">
<html><center>Don't use the escape key!</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=285">http://vim.sf.net/tip_view.php?tip_id=285</A><BR>

Vim (any vi really) is a dream for touch typists... Until you want to switch
from insert mode to normal mode.  Then you've got to reach way up to whack
the escape key.

Or at least that's what I was doing until I realized that (drum roll please)

		    Esc is exactly equivalent to control-[  (that's the
		    control key plus the left square bracket key)

That little bit of knowledge, plus mapping my caps lock to another control
key, was what turned my fascination with Vim into true love.  You never have
to lose track of the home row again!

For Xfree86 users - you can make the capslock key another control key by adding

Option "XkbOptions" "ctrl:nocaps"

to the InputDevice section of your XF86Config file.

For Windows NT/2000 users  - use the following .reg file to do the same thing:

REGEDIT4

[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layout]
"Scancode Map"=hex:00,00,00,00,00,00,00,00,02,00,00,00,1d,00,3a,00,00,00,00,00

</pre></tip> </html> <Tip category="KVim"> <html><center>Recover
after doing something... ugly.</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=286">http://vim.sf.net/tip_view.php?tip_id=286</A><BR>

I was once editing a file and wanted to test something. The test was meant
to add a line at the end of the file, from outside vim. All was fine, but
instead of &gt;&gt;, I wrote &gt;. You can imagine what happened... :)

If you happen to do something like that, the solution is:

:recover

</pre></tip> </html> <Tip category="KVim">
<html><center>Cool trick to change numbers</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=287">http://vim.sf.net/tip_view.php?tip_id=287</A><BR>

In the gvim if you want to decrement any number just put ur curcor on that
number in Esc mode and pres &lt;CTRL&gt; X

</pre></tip> </html> <Tip category="KVim"> <html><center>A keymapping
to generate Java setters and getters automatically</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=288">http://vim.sf.net/tip_view.php?tip_id=288</A><BR>

This mapping makes it much simpler to write new java classes by simplifying
some of the dull repetative coding (ie setters and getters).

To use, first write a basic class with the following format:

public class MyClass {

     private &lt;type&gt; &lt;varname&gt; = &lt;initvalue&gt;; private
     &lt;type&gt; &lt;varname&gt; = initvalue&gt;;

     // getters

     // setters

}

Note the getters/setters comment -- they are important as they are used to
place the getters and setters.

The mapping is:

map jgs mawv/ &lt;Enter&gt;"ty/
&lt;Enter&gt;wvwh"ny/getters&lt;Enter&gt;$a&lt;Enter&gt;&lt;Enter&gt;public
&lt;Esc&gt;"tpa&lt;Esc&gt;"npbiget&lt;Esc&gt;l~ea()&lt;Enter&gt;{&lt;Enter&gt;&lt;Tab&gt;return
&lt;Esc&gt;"npa;&lt;Enter&gt;}&lt;Esc&gt;=&lt;Enter&gt;&lt;Esc&gt;/setters&lt;Enter&gt;$a&lt;Enter&gt;&lt;Enter&gt;public
void &lt;Esc&gt;"npbiset&lt;Esc&gt;l~ea(&lt;Esc&gt;"tpa
&lt;Esc&gt;"npa)&lt;Enter&gt;{&lt;Enter&gt;&lt;Tab&gt;this.&lt;Esc&gt;"npa=&lt;Esc&gt;"npa;&lt;Enter&gt;}&lt;Esc&gt;=&lt;Enter&gt;`ak

(the above should be one long line with no spaces between the end of the
lines above).

To use this to generate a class go to the variable that should have a
setter/getter and place the curser at the beginning of the 'private':

   private &lt;type&gt; &lt;variable&gt; = &lt;initvalue&gt;' ^

Then type:

jgs

this will create the first getter/setter and then move up to the next
variable.  You can just keep typing jgs until all the  getters/setters have
been generated.

This should mapping isn't perfect and someone could probably make it a little
cleaner.  It could also relatively easily be adapted to C++.  Please feel free
to send me any feedback/enhancements as I am trying to compile a list of these.

</pre></tip> </html> <Tip category="KVim"> <html><center>Alternative
&lt;escape&gt; that allows you to do a "quick and dirty
insert" and get out into normal mode</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=289">http://vim.sf.net/tip_view.php?tip_id=289</A><BR>

This is an alternative key combo for the escape key from the one mentioned
by David A. Rogers in vimtip #285.

I do a lot of editting in Vim, and I've always found myself in situations where
I had to "do a quick insert" - basically (from normal mode), change into insert
mode, type in one quick word, then &lt;esc&gt; out, then navigate elsewhere.

As has been rightly observed by a lot of people, the &lt;esc&gt; key can
sometimes be a little bit out of the way. But that's no problem for ViM, is it?

At first, I thought of editting the ViM source code itself, in order to come
up with a command that could do things like say "let me jump into insert
mode, type a few quick words, then escape out into normal mode when i press
something like double &lt;space&gt;".

It was only later when reading through the section in
Jesse Goerz's "Beginner's Guide to ViM" on remapping (<A
HREF="http://newbiedoc.sourceforge.net/tutorials/vim/mapping-vim.html)
that I got inspired to retake a look at using remapping as an alternative
instead.">http://newbiedoc.sourceforge.net/tutorials/vim/mapping-vim.html)
that I got inspired to retake a look at using remapping as an alternative
instead.</A><BR>

This is what I came up with.. Use whatever is comfortable for you - single
or double &lt;Shift-space&gt;

:map! &lt;S-space&gt; &lt;esc&gt; :map! &lt;S-space&gt;&lt;S-space&gt;
&lt;esc&gt;

With this quick combo ("Shift", + &lt;space&gt;), one can easily (and might
I add, intuitively) "do a quick insert" and exit quickly out into normal
mode. I guess I always thought the &lt;space&gt; would be a good way to
do this sort of thing, since it is after all, so intuitive in the typing
process. So why not make it such that it can "escape" you out into normal
mode as well? Just type 'i', to go into insert mode, type in your stuff,
and once you're done, hit Shift-space!

</pre></tip> </html> <Tip category="KVim"> <html><center>Text
Processing With Integrated Spell Checking</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=290">http://vim.sf.net/tip_view.php?tip_id=290</A><BR>

I have written an HTML document to help others use Vim as a basic text
processing application. It discusses how to integrate spell checking,
dictionary, and thesaurus applications. It also talks about wrapping lines,
indentation, justification, and the vim settings that effect the behavior
of these operations. The document can be found at:
   <A
   HREF="http://www.highley-recommended.com/text-processing.html">http://www.highley-recommended.com/text-processing.html</A><BR>

Everything has been tested with UNIX, Linux, Windows, and Windows with
Cygwin patforms.

</pre></tip> </html> <Tip category="KVim"> <html><center>^P
& auto filling of variables and text</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=291">http://vim.sf.net/tip_view.php?tip_id=291</A><BR>

Do you know you can auto fill the variable and names as you type your code
? This will help most of the programmers, who always try hard to remember the
variable names and browse through all the files to find out the variable name.
   Use Ctrl+P and Ctrl+N to autofill the variables names etc. Just practice,
   you will feel the ease of using vim

</pre></tip> </html> <Tip category="KVim">
<html><center>vim + cscope + cygwin</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=292">http://vim.sf.net/tip_view.php?tip_id=292</A><BR>

I've found that vim + cscope + cygwin does not work. The problem seems to
be that in

sprintf(cmd, "exec %s -dl -f %s", prog, csinfo[i].fname);

vim execs cscope with the "-dl" options, causing it to fail. It is probably
a cscope bug, but a simple workaround is top build vim without thad "d":

sprintf(cmd, "exec %s -l -f %s", prog, csinfo[i].fname);

seems to work for me!

</pre></tip> </html> <Tip category="KVim"> <html><center>remember
where you had ended reading help</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=293">http://vim.sf.net/tip_view.php?tip_id=293</A><BR>

You could jump to the last place you had been while reading Vim help files
if you add this to your .vimrc file:

au BufLeave * if &ft == "help" | mark H | endif

Then use 'H to go to the mark H.

To work between Vim runs 'viminfo' option should be setup to save file marks.
See :help 'viminfo' and :help file-marks for more information.

</pre></tip> </html> <Tip category="KVim"> <html><center>Use
Ctrl-S to save current or new files.</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=294">http://vim.sf.net/tip_view.php?tip_id=294</A><BR>

I wanted to have a single key stroke that would save existing files, or call
the file browser.  Here's a key map for Ctrl-S to accomplish that (place in
vimrc file):

if has("gui_running")
  " If the current buffer has never been saved, it will have no name,
  " call the file browser to save it, otherwise just save it.  :map
  &lt;silent&gt; &lt;C-S&gt; :if expand("%") == ""&lt;CR&gt;:browse confirm
  w&lt;CR&gt;:else&lt;CR&gt;:confirm w&lt;CR&gt;:endif&lt;CR&gt;
endif

Tom Kimpton

</pre></tip> </html> <Tip category="KVim">
<html><center>Line/word/file/whatever completion</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=295">http://vim.sf.net/tip_view.php?tip_id=295</A><BR>

In addition to vimtip #291 you can use whole &lt;C-x&gt; completion mode. It
can complete whole lines (&lt;C-x&gt;l, then &lt;C-p&gt;, &lt;C-n&gt;),
filenames (&lt;C-f&gt;), keywords, words from custom dictionary and many,
many others. During coding it usually saves a LOT of key strokes ;) This
mode has many other powerful features, for example when completing word (by
&lt;C-x&gt;&lt;C-p&gt; or just by &lt;C-p&gt;) you can continue completion
with another &lt;C-x&gt;&lt;C-p&gt;. For example, after writing such text:

this is first line second line is here

Placing cursor at third line and pressing &lt;C-x&gt;l will double last
line - &lt;C-n&gt;, &lt;C-p&gt; in this moment can be used to manipulate
completed line. Or, instead of completing whole line you can press 'f' and
then complete by &lt;C-p&gt; which will result in 'first' word. After that
you can &lt;C-x&gt;&lt;C-p&gt; to get 'line' word (since this is next word
after 'first'). Try yourself for other powerful combinations.

</pre></tip> </html> <Tip category="KVim"> <html><center>Attach
the currently open file to email</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=296">http://vim.sf.net/tip_view.php?tip_id=296</A><BR>

This is very simple, but most people don't seem to take advantage of
this. Often you have some file (source code or other text file) already open
in an existing vim session and you need to attach it with an email. It is
very simple.
    - First copy the filename into clipboard. For this I put the following
    mapping in vimrc and press &lt;F2&gt;:
	 nnoremap &lt;F2&gt; :let @*=expand("%:p")&lt;cr&gt;
    - Go to your email compose window and use your regular file attachment
    menu (Insert-&gt;File in outlook) and press ^V (or whatever key to paste
    clipboard) and press Enter.

That is all there to it. If you are on windows and your email client doesn't
accept forward-slashes, then you might want to change the map to:

	 nnoremap &lt;F2&gt; :let @*=substitute(expand("%:p"), "/", "\\",
	 "g")&lt;cr&gt;

HTH, Hari

</pre></tip> </html> <Tip category="KVim"> <html><center>Start
in insert mode without loosing your escape key</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=297">http://vim.sf.net/tip_view.php?tip_id=297</A><BR>

There are two parts to this, each is fairly simple.

First, I want to start in insert mode.	Well "set im!" in my vimrc did the
job, but I lost the escape key.  Second, I have found that often times,
when I'm in command mode, I hit escape trying to get back into insert mode.
I am always rewarded with a beep, telling me once again I made that mistake.

So I mapped esc in command mode to set insert mode (":set im") and I mapped
esc in insert mode to unset insert mode (&lt;c-o&gt;:set im)  Well then I
realized if you hit "i" in command mode, escape woulding work the first time.
So here's the code to add to your vimrc:

set im!			     " start in insert mode map &lt;esc&gt; :set
im!&lt;cr&gt;	    " escape in command mode goes to insert mode map
i :set im!&lt;cr&gt;	       " i in command mode goes to insert mode
map! &lt;esc&gt; &lt;c-o&gt;:set im!&lt;cr&gt; " escape in insert mode goes
to command mode

see :help insert

</pre></tip> </html> <Tip category="KVim"> <html><center>Changing
case with regular expressions</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=298">http://vim.sf.net/tip_view.php?tip_id=298</A><BR>

I stumbled across this factoid on a website about vi. I haven't been able to
locate it in the Vim documentation, but it works in Vim, and it's very handy.

There are times that you might like to go through a file and change the case
of characters that match some arbitrary criteria. If you understand regular
expressions well, you can actually do this fairly easily.

It's as simple as placing \U or \L in front of any backreferences in your
regular expressions. Vim will make the text in the backreference uppercase
or lowercase (respectively).

(A "backreference" is a part of a regular expression that refers to a previous
part of a regular expression. The most common backrefernces are &, \1, \2,
\3, ... , \9).

Some examples that demonstrate the power of this technique:

Lowercase the entire file - :%s/.*/\L&/g

(& is a handy backreference that refers to the complete text of the match.)

Uppercase all words that are preceded by a &lt; (i.e. opening HTML tag names):
:%s/&lt;\(\w*\)/&lt;\U\1/g

Please add a note if you know where this is in the documentation. I have
done Ctrl-D searches on upper, lower, \U, and \L with no luck.

</pre></tip> </html> <Tip category="KVim">
<html><center>Open file under cursor.</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=299">http://vim.sf.net/tip_view.php?tip_id=299</A><BR>

A little thing that I did and found quite useful:

function! OpenFileUnderCursor()
	let FileName = expand("&lt;cfile&gt;") let OldPath = getcwd() silent cd
	%:p:h execute "silent sp +e " . FileName execute "silent cd " . OldPath
endfunction

map! silent &lt;M-e&gt; :call OpenFileUnderCursor()&lt;CR&gt;

Then use Alt+E on a filename to open it (relative to the directory the
current file resides in).

</pre></tip> </html> <Tip category="KVim"> <html><center>Making
a tags file for IDL (Interactive Data Language)</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=300">http://vim.sf.net/tip_view.php?tip_id=300</A><BR>

I have recently began using the tags features of vim (:help tags) with my
fortran codes and come to appreciate their power.  I also do a lot of coding
in IDL (Interactive Data Language), but found that ctags did not have native
support for IDL.  If you take the time you can learn how to get ctags to
support IDL, but I found, after a search of usenet, that someone else has
already done this and written a perl script called idltags.  It is part
of an emacs package (is anyone still reading?) that you need to download,
called idlwave, which is located at:
		      <A HREF="http://idlwave.org/">http://idlwave.org/</A><BR>
and currently (I don't know if this will change) the direct download link is
		      <A
		      HREF="http://idlwave.org/download/idlwave.tar.gz">http://idlwave.org/download/idlwave.tar.gz</A><BR>
In the usenet pages the maintainer, JD Smith, was suggesting that idlwave
had outgrown idltags and was not sure it was still needed, so I don't know
how long it will be available.

</pre></tip> </html> <Tip category="KVim"> <html><center>Edit
files in path, or related.</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=301">http://vim.sf.net/tip_view.php?tip_id=301</A><BR>

You can write a little shell function that will let you easily edit any file
that is in the path, or which's location can be retrieved with the whereis
tool. This is something similar to what I have in /etc/profile:

function vvim() { vim `whereis $1|cut -d: -f2` } function ggvim() { gvim
`whereis $1|cut -d: -f2` }

Then just type, for example, "vvim ls", and you'll start vim with /bin/ls
and /usr/share/man/ls.1.gz loaded :) (it's not very useful to edit /bin/ls,
but you get the ideea ;)

</pre></tip> </html> <Tip category="KVim">
<html><center>Use gvim in kmail</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=302">http://vim.sf.net/tip_view.php?tip_id=302</A><BR>

To automatically open gvim to edit in kmail, "-f" command line option must
be used .  In kmail configuration go to the composer settings , and write
in the "use external editor" field the following command : "gvim -f %f"
Without -f option gvim would work in background and editing would not have
any effect on kmail.

</pre></tip> </html> <Tip category="KVim"> <html><center>Statusline
Tab Level Function Ruler TVIM</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=303">http://vim.sf.net/tip_view.php?tip_id=303</A><BR>

I use this function to let me know if my cursor is on a TAB column.  The t*
on the ruler means I am not. But t3 means the cursor is on tablevel 3 ~vimrc
----------------------- My Ruler ------------------------ r4,c13,t3 ~vimrc
----------------------- My Ruler ------------------------ r4,c14,t* If you
want to change a tab level you can drag or push the first character of a line
to a desired tab level. (more on that later) This ruler replacement will let
you know where you are, whether you like to use space tabs (see vimtip #12 )
or regular tabs.  My function is set to four space tabs stops and only goes
9 levels but can be easily modified.

Actually I just wanted to learn how to use a function in my _vimrc and this
was my first attempt.  Add this to your _vimrc

"--------------------cut------------------ set laststatus=2 "This makes sure
the ruler shows.  See	 help laststatus set statusline=%f\ ---------\ My\
Ruler\ ----------\ r%l,c%c,t%{ShowTab()} "See help statusline  (I toggle
between 12 helpful rulers -- more on that later) fu ShowTab()
    let TabLev='*' let Col=(col("."))  if Col == 1 | let TabLev='0' |
    en if Col == 5 | let TabLev='1' | en if Col == 9 | let TabLev='2' |
    en if Col ==13 | let TabLev='3' | en if Col ==17 | let TabLev='4' |
    en if Col ==21 | let TabLev='5' | en if Col ==25 | let TabLev='6' |
    en if Col ==29 | let TabLev='7' | en if Col ==33 | let TabLev='8' |
    en if Col ==37 | let TabLev='9' | en
return TabLev endf "The ruler (statusline) shows a t* unless you are on
col 1,5,9,13,...  "-------------------cut-------------------

This function ShowTab() gets called and updates the ruler with every cursor
move but it does not slow things down as I type.  Perhaps a speed typist
may complain :-) In case I write something else you may search on the key
word TVIM Best Wishes	     TVIM Tamed Vim	   paradocs@frontiernet.net

</pre></tip> </html> <Tip category="KVim">
<html><center>fold braces and javadoc</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=304">http://vim.sf.net/tip_view.php?tip_id=304</A><BR>

If you'd like to have javadoc folded together with areas in braces try that
&lt;pre&gt; set foldmethod=syntax set foldenable syn region foldBraces
start=/{/ end=/}/ transparent fold syn region foldJavadoc start=,/\*\*,
end=,\*/, transparent fold keepend &lt;/pre&gt; and play a bit with:
&lt;pre&gt; set foldlevel=0 set foldnestmax=10 &lt;/pre&gt; parameters

</pre></tip> </html> <Tip category="KVim"> <html><center>Best
of VIM Tips (VIM's best Features)</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=305">http://vim.sf.net/tip_view.php?tip_id=305</A><BR>

Here's a necessarily cryptic list of "MY" Best Vim Tips
that I've gleaned from <A HREF="http://vim.sf.net/  &
comp.editors  ">http://vim.sf.net/  & comp.editors  </A><BR> <A
HREF="http://groups.google.com/groups?safe=off&group=comp.editors">http://groups.google.com/groups?safe=off&group=comp.editors</A><BR>

updated version at <A
HREF="http://www.rayninfo.co.uk/vimtips.html">http://www.rayninfo.co.uk/vimtips.html</A><BR>
------------------------------------------------------------------------------
# Absolutely essential
------------------------------------------------------------------------------
vim.sf.net	   : Visit frequently comp.editors    : "VIM" dominated
newsgroup * # g* g#	     : find word under cursor (forwards/backwards)
%		    : match brackets {}[]() matchit.vim      : % now matches
tags &lt;tr&gt;&lt;td&gt;&lt;script&gt; etc &lt;C-N&gt; &lt;C-P&gt;   : word
completion in insert mode &lt;C-X&gt;&lt;C-L&gt;    : Line complete SUPER
USEFUL /&lt;C-R&gt;&lt;C-W&gt;	 : Pull &lt;cword&gt; onto search/command
line :set ignorecase # you nearly always want this :syntax on	 : colour
syntax in Perl,HTML,PHP etc :h slash&lt;C-D&gt; : type control-D and get a
list all help topics containing
		   slash (plus use TAB for Help completion)
------------------------------------------------------------------------------
# MAKE IT EASY TO UPDATE/RELOAD_vimrc :nmap
,s :source $VIM/_vimrc :nmap ,v :e $VIM/_vimrc
------------------------------------------------------------------------------
#VISUAL MODE Mappings :vmap sb "zdi&lt;b&gt;&lt;C-R&gt;z&lt;/b&gt;&lt;ESC&gt;
: wrap &lt;b&gt;&lt;/b&gt; around VISUALLY selected
Text :vmap st "zdi&lt;?= &lt;C-R&gt;z ?&gt;&lt;ESC&gt;
: wrap &lt;?=	?&gt; around VISUALLY selected Text
------------------------------------------------------------------------------
# Exploring :Ex				    : file explorer note capital Ex \be
: builtin buffer explorer :ls				  : list of buffers(eg
following) :cd ..			   : move to parent directory
------------------------------------------------------------------------------
# Great guu				: lowercase line gUU
: uppercase line gf				 : open file name under
cursor (SUPER) ga			       : display hex,ascii value of
character under cursor ggVGg?			       : rot13 whole file
CTRL-A,CTRL-X			: increment,decerement number under cursor
				  win32 users must remap CNTRL-A
CTRL-R=5*5			: insert 25 into text
------------------------------------------------------------------------------
# Makes all other tips superfluous :h 42 :h holy-grail :help!
------------------------------------------------------------------------------
# Markers & moving about '.		  : jump to last modification
line (SUPER) `.		      : jump to exact spot in last modification
line &lt;C-O&gt;	    : retrace your movements in file
(old) &lt;C-I&gt;	     : retrace your movements in file (new)
:ju(mps) :help jump-motions :history	      : list of all your commands
------------------------------------------------------------------------------
# Abbreviations & maps :map   &lt;f7&gt;   :'a,'bw! c:/aaa/x :map   &lt;f8&gt;
:r c:/aaa/x :map   &lt;f9&gt;	:w&lt;CR&gt;:!c:/php/php.exe %&lt;CR&gt;
:map   &lt;f11&gt;  :.w! c:/aaa/xr&lt;CR&gt; :map   &lt;f12&gt;  :r
c:/aaa/xr&lt;CR&gt; :ab php	      : list of abbreviations beginning
php :map ,	      : list of maps beginning , # For use in Maps
&lt;CR&gt;	       : carriage Return for maps &lt;ESC&gt;		 :
Escape &lt;LEADER&gt;	      : normally \ &lt;BAR&gt;		  : | pipe
------------------------------------------------------------------------------
# List your Registers :reg	       : display contents
of all registers "1p....	  : retrieve numeric buffers
------------------------------------------------------------------------------
# Useful trick "ayy@a		 : execute "Vim command" in a
text file yy@"		    : same thing using unnamed register
------------------------------------------------------------------------------
# Get output from other commands :r!ls.exe	  :
reads in output of ls !!date	       : same thing
:%!sort -u	 : use an external program to filter content
------------------------------------------------------------------------------
# Multiple Files Management :wn		     : write file and move to
next (SUPER) :bd	      : remove file from buffer list (SUPER)
:sav php.html	 : Save current file as php.html and "move" to php.html
:sp fred.txt	 : open fred.txt into a split :e!	       : return to
unmodified file :w c:/aaa/%	 : save file elsewhere :e #		    :
edit alternative file :e % :rew		       : rewwind to first file in
ARGS :bn		 : next file :bp		 : next file :brew
------------------------------------------------------------------------------
# Recording (BEST TIP of ALL) qq  # record to q your commands
q @q to execute @@ to Repeat # editing a register/recording "ap
&lt;you can now see register contents, edit as required&gt; "add @a
------------------------------------------------------------------------------
# _vimrc essentials :set incsearch : jumps to search word as you type (annoying
but excellent) :set wildignore=*.o,*.obj,*.bak,*.exe :set shiftwidth=3
------------------------------------------------------------------------------
# launching Win IE :nmap ,f :update&lt;CR&gt;:silent
!start c:\progra~1\intern~1\iexplore.exe
file://%:p&lt;CR&gt; :nmap ,i :update&lt;CR&gt;: !start
c:\progra~1\intern~1\iexplore.exe &lt;cWORD&gt;&lt;CR&gt;
------------------------------------------------------------------------------
# FTPing from VIM cmap ,r  :Nread <A
HREF="ftp://209.51.134.122/public_html/index.html
">ftp://209.51.134.122/public_html/index.html </A><BR> cmap ,w	:Nwrite <A
HREF="ftp://209.51.134.122/public_html/index.html">ftp://209.51.134.122/public_html/index.html</A><BR>
gvim <A
HREF="ftp://209.51.134.122/public_html/index.html">ftp://209.51.134.122/public_html/index.html</A><BR>
------------------------------------------------------------------------------
# appending to registers (use CAPITAL) # yank
5 lines into "a" then add a further 5 "a5yy 10j "A5yy
------------------------------------------------------------------------------
[I     : show lines matching word under cursor &lt;cword&gt;
------------------------------------------------------------------------------
#Conventional Shifting :'a,'b&gt;&gt; # visual shifting
(builtin-repeat) :vnoremap &lt; &lt;gv :vnoremap &gt; &gt;gv
------------------------------------------------------------------------------
# searching /^joe.*fred.*bill/ : normal /^[A-J]\+/	   : search
for lines beginning A-J followed by at leat 1 A-J /forum\(\_.\)*pent
search over possible multiple lines /fred\_s*joe/i    : any
whitespace including newline /fred\|joe        : Search for FRED OR JOE
------------------------------------------------------------------------------
#substitution :%s/fred/joe/igc		  : general substitute command
:%s/\r//g		    : Delete DOS returns ^M :'a,'bg/fred/s/dick/joe/gc
: VERY USEFUL :s/\(.*\):\(.*\)/\2 :  \1/  : reverse fields separated
by : :%s/^.\{-}pdf/new.pdf/  non greedy matching (ie to first pdf)
:s/fred/&lt;c-r&gt;a/g substitute "fred" with contents of register "a"
:%s/^\(.*\)\n\1/\1$/  delete duplicate lines # non-greedy matching
\{-} :%s/^.\{-}pdf/new.pdf/ :help /\{-} :s/fred/&lt;c-r&gt;a/g
substitute "fred" with contents of register "a" # multiple commands
:%s/\f\+\.gif\&gt;/\r&\r/g | v/\.gif$/d | %s/gif/jpg/ :%s/suck\|buck/loopy/gc
: ORing :s/__date__/\=strftime("%c")/ : insert datestring
------------------------------------------------------------------------------
# global command :g/^\s*$/d	  :delete all blank lines :g!/^dd/d	   :
delete lines not containing string :v/^dd/d	    : delete lines not
containing string :g/fred/,/joe/d  : not line based :v/./.,/./-1join : compress
empty lines :'a,'b g/^Error/ . w &gt;&gt; errors.txt :g/cmap\|form/p  : ORing
------------------------------------------------------------------------------
# Paste register * :redir @*   : redirect commands to paste :redir
END "*yy	: yank to paste "*p	    : insert paste buffer
------------------------------------------------------------------------------
# Formatting text gq&lt;CR&gt; gqap  (a is motion p paragraph (visual mode))
------------------------------------------------------------------------------
# Operate command over multiple files :argdo
%s/foo/bar/ :bufdo %s/foo/bar/ :windo %s/foo/bar/
------------------------------------------------------------------------------
# Command line tricks gvim -h ls | gvim -   : edit a PIPE!!  #
vg.ksh (shell script) # vi all files in directory containing
keyword $1 and jump to $1 gvim.exe -c "/$1"  $(grep -isl "$1" *) &
------------------------------------------------------------------------------

</pre></tip> </html> <Tip category="KVim"> <html><center>Open a
web-browser with the URL in the current line</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=306">http://vim.sf.net/tip_view.php?tip_id=306</A><BR>

function! Browser ()
    let line = getline (".")  let line = matchstr (line, "http[^ ]*") exec
    "!netscape ".line
endfunction

map &lt;Leader&gt;w :call Browser ()&lt;CR&gt;

</pre></tip> </html> <Tip category="KVim"> <html><center>annoying
"Hit any key to close this window..."</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=307">http://vim.sf.net/tip_view.php?tip_id=307</A><BR>

i use gvim and bash heavily under win98.  i have

let $HOME = substitute($HOME, '\\', '/', 'g') set shell=bash\ --rcfile\
\"$HOME\"_bashrc\ -i

in my _vimrc, and something like

function br() { if [ $1 ]; then
	explorer.exe ${1//\//\\}
    else
	explorer.exe ${PWD//\//\\}
    fi
}

in my _bashrc. when i finish editing one html file, i simply type :!br %

everything works fine now. but when :!br % executes, one console window will
bump out and wait me to press some key to contiue. i consider this quiet
annoying. i want the console window to disappear automatically if no fault
has happened.  does anyone know how to achieve this?  thanks.

</pre></tip> </html> <Tip category="KVim">
<html><center>Move through wrapped lines.</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=308">http://vim.sf.net/tip_view.php?tip_id=308</A><BR>

If you don't like the fact that when you press Up and Down on a wrapped line,
you get to the next phisical line instead of the next line on the screen,
you can do something like this:

imap &lt;silent&gt; &lt;Down&gt; &lt;C-o&gt;gj imap &lt;silent&gt; &lt;Up&gt;
&lt;C-o&gt;gk

nmap &lt;silent&gt; &lt;Down&gt; gj nmap &lt;silent&gt; &lt;Up&gt; gk

</pre></tip> </html> <Tip category="KVim"> <html><center>close
vim you left open remotely</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=309">http://vim.sf.net/tip_view.php?tip_id=309</A><BR>

Vim 6 has this cool client-server protocol. I use it all the time to edit
a file in an existing gvim, like so $ gvim --remote [filename]

Today I left myself logged in at the console at work, and when I got home
I realized I had left vim running with files  unsaved. I think I even left
it in insert mode. I wanted to edit these files at home. So I ssh'd to the
machine and started playing with the --remote commands.

:help was a bit cryptic
   --remote-send {keys}		Send {keys} to server and exit.

After a lot of failed attempts, I finally succeeded in getting the remote
vim to save its buffers and quit.

$ DISPLAY=:0 vim --servername GVIM --remote-send '&lt;ESC&gt;:wqa&lt;CR&gt;'

A couple of notable things. Then environment variable DISPLAY has to be the
display of the remote vim, and you have to be able to open that display. The
client-server stuff is done through X.

The &lt;CR&gt; is important. This part eluded me for a long time. The {keys}
are just like keys you would press if you were editing at the console,
and you have to press enter, or vim won't do anything.

Check your .swp files to make sure vim really closed the files it was
editing. Vim provides little feedback as to the success or failure of what
you're trying to do remotely. Nonetheless, it's clearly a useful feature to
have available.

</pre></tip> </html> <Tip category="KVim"> <html><center>showing ascii
value of the current character in decimal, hex, and octal</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=310">http://vim.sf.net/tip_view.php?tip_id=310</A><BR>

dont know if you guys know this or not, but i was trying to make the word
"hello" to upper case by trying "gaUw" (= which didnt work but it showed
the decimal, hex, and octal of the char under the cursor... ncie to know.

</pre></tip> </html> <Tip category="KVim"> <html><center>Open
the folder containing the currently open file</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=311">http://vim.sf.net/tip_view.php?tip_id=311</A><BR>

Occasionally, on windows, I have files open in gvim, that the folder for that
file is not open. This key map opens the folder that contains the currently
open file. The expand() is so that we don't try to open the folder of an
anonymous buffer, we would get an explorer error dialog in that case.

if has("gui_running")
 if has("win32")
    " Open the folder containing the currently open file. Double &lt;CR&gt; at
    end " is so you don't have to hit return after command. Double quotes are
    " not necessary in the 'explorer.exe %:p:h' section.  :map &lt;silent&gt;
    &lt;C-F5&gt; :if expand("%:p:h") != ""&lt;CR&gt;:!start explorer.exe
    %:p:h&lt;CR&gt;:endif&lt;CR&gt;&lt;CR&gt;
  endif
endif

Tom.

</pre></tip> </html> <Tip category="KVim">
<html><center>Copy, Cut, and Paste</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=312">http://vim.sf.net/tip_view.php?tip_id=312</A><BR>

PS: copy, cut, and paste are the words from (usually) gui editor.

Ever try to cut (or copy) some lines and paste to another place?  If you
need to count the lines first, then try these to eliminate counting task.

Cut and Paste:

1. Place the cursor at the beginning of the block you want to CUT.  2. Mark
it with md 3. Go to the end of the block.  4. Cut it with d'd 5. Go to the
new location that you want to PASTE those text.  6. Press P.

Copy and Paste:

1. Place the cursor at the beginning of the block you want to COPY.  2. Mark
it with my 3. Go to the end of the block.  4. Cut it with y'y 5. Go to the
new location that you want to PASTE those text.  6. Press P.

The name of the mark used is related to the operation (d:delete or y:yank).
I found that those mark names requires minimal movement of my finger. ;)

</pre></tip> </html> <Tip category="KVim"> <html><center>printing
using kprinter (unix + kde)</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=313">http://vim.sf.net/tip_view.php?tip_id=313</A><BR>

just add set printexpr=system('kprinter'\ .\ '\ '\ .\ v:fname_in)\ .\
delete(v:fname_in)\ +\ v:shell_error to your ~/.vimrc; further on all your
printing will be piped through the nice and consistent print-dialog of kde.

lg, tomte

</pre></tip> </html> <Tip category="KVim">
<html><center>Insert and back...</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=314">http://vim.sf.net/tip_view.php?tip_id=314</A><BR>

this is related to vimtip #289 in terms of programmers (like I) too lazy to
move their hands to reach the far far away &lt;esc&gt; key.... joking! :)
  actually the less your hands move around the faster you type, and the fester
  you type the more time you have on your hands to think of "what" you type...

here is a small snippet from my mappings file, ready to speed things up: //
the key overloading might be a somewhat confusing at first....

--cut--- imap &lt;S-Space&gt; &lt;esc&gt;l imap &lt;C-CR&gt; &lt;esc&gt;o
imap &lt;S-CR&gt; &lt;esc&gt;O

nmap &lt;S-Space&gt; i nmap &lt;space&gt;&lt;space&gt; i nnoremap &lt;CR&gt;
o nmap &lt;S-CR&gt; O

---uncut---

Good luck!!

</pre></tip> </html> <Tip category="KVim">
<html><center>"Smart &lt;home&gt;"</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=315">http://vim.sf.net/tip_view.php?tip_id=315</A><BR>

to make it faster to navigate through indented code here is a common way to
"go home"...

---cut--- fun! s:SmartHome()
    if col('.') != match(getline('.'), '\S')+1
	norm ^
    else
	:call cursor(line('.'),2) norm h
    endif
endfun inoremap &lt;silent&gt;&lt;home&gt; &lt;C-O&gt;:call
&lt;SID&gt;SmartHome()&lt;CR&gt; nnoremap &lt;silent&gt;&lt;home&gt; :call
&lt;SID&gt;SmartHome()&lt;CR&gt; vnoremap &lt;silent&gt;&lt;home&gt; :call
&lt;SID&gt;SmartHome()&lt;CR&gt;

---uncut---

what this snippet does is make the &lt;home&gt; key behave as it does in
such IDEs as PythonWin or MSVisualStudio, and that is first go to the first
non whitespace, and then to the first char on the line.

</pre></tip> </html> <Tip category="KVim"> <html><center>Using
/pattern/ search in a script</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=316">http://vim.sf.net/tip_view.php?tip_id=316</A><BR>

There are a number of ways you can search for a pattern in a script.
The search function is the typical way to search for a pattern.  But, it
has limited options.  In particular, there are no options to control the
position of the cursor after it matches the pattern.

Instead you can use :normal command.  The secret is to add a &lt;CR&gt;
(^M) on the end of the command.   For example, to search for "pattern"
and move the cursor to the end of the matching pattern issue the command:

:normal /pattern/e+1^M

where ^M is a real carriage return.  It can be entered with
&lt;c-v&gt;&lt;c-m&gt;.

Another use is when you want to enter a bunch of normal commands together.
For example, if you were looking to find a '{' to highlight and delete
a C block.  The '{' may not be on the same line so you can't use the "f"
normal command.

:normal V/{/^M%d

A drawback to using the normal command is that if the pattern does not
match then it is difficult to detect.  Also, you can get in trouble with
the wrapscan setting.

For more information about these commands look at

:help / :help normal :help search()

</pre></tip> </html> <Tip category="KVim">
<html><center>Mozilla Vim Keybindings</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=317">http://vim.sf.net/tip_view.php?tip_id=317</A><BR>

If you use VIM you like the h, j, k, and l movement keys.  I found myself
annoyed at not having these movement keys available when browsing web pages.
Moving to the arrow keys on a laptop is annoying to just scroll the page.

Locate your mozilla/res/builtin directory (varies by platform). You could
search for htmlBindings.xml to find it. (ie. locate htmlBindings.xml.

On Mac OS X it's inside the Mozilla application bundle.
/Applications/Mozilla/Mozilla.app/Contents/MacOS/res/builtin.

Create a new XML file called userHTMLBindings.xml, making it executable for
all users and making sure the CRLF format is the same as htmlBindings.xml.
i.e. on Mac OS X most files use \r but Vim writes \n instead. You can either
save the file with Vim as a Mac formatted file or use tr '\n' '\r' &lt;
input.xml &gt; output.xml to convert the file.

Place the following XML into the userHTMLBindings.xml file.

&lt;?xml version="1.0"?&gt;

&lt;bindings id="htmlBindings"
   xmlns="<A
   HREF="http://www.mozilla.org/xbl"">http://www.mozilla.org/xbl"</A><BR>
   xmlns:xul="<A
   HREF="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"&gt;">http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"&gt;</A><BR>

  &lt;binding id="browserUser"&gt;
    &lt;handlers&gt;
      &lt;handler event="keypress" key="h" command="cmd_scrollLeft"/&gt;
      &lt;handler event="keypress" key="j" command="cmd_scrollLineDown"/&gt;
      &lt;handler event="keypress" key="k" command="cmd_scrollLineUp"/&gt;
      &lt;handler event="keypress" key="l" command="cmd_scrollRight"/&gt;
    &lt;/handlers&gt;
  &lt;/binding&gt;
    &lt;/bindings&gt;

There are many more bindings one could configure to get Vim like keybindings.
You can read <A HREF="http://www.mozilla.org/unix/customizing.html#keys for
more information.">http://www.mozilla.org/unix/customizing.html#keys for
more information.</A><BR>

PS.  I love the keymaster/gatekeeper xul reference in the xul URL above.
It's from the original GhostBusters movie.  ;-)



</pre></tip> </html> <Tip category="KVim"> <html><center>Extended
Bracket and Parenthesis + extras for perl</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=318">http://vim.sf.net/tip_view.php?tip_id=318</A><BR>

This is an extension of vimtip #153 I found this tip useful, but the jump
seemed out of place for me, I couldn't enter just one ' or ", and so I created
an improvement Basically, I set it up so that when you're in perl and have
a non keyword charcter, (except for @, $ and % for perl) and you type a {
you get: {
       | &lt;- cursor
} Where as, when I have a keyword I get: word{} With the cursor in the middle,
for hashes in perl.  I can jump out of any block, except the "" or '' blocks,
by typing their closing charcter.  So } jumps me out past the next } in
the file.

Warning, this search may wrap around.

Finally, I made it so that, using the alt key, &lt;Alt-'&gt; inserts a '
&lt;Alt-/&gt; inserts a " &lt;Alt-[&gt; inserts a [ &lt;Alt-]&gt; inserts a
] &lt;Alt--&gt; inserts a { &lt;Alt-=&gt; inserts a } &lt;Alt-,&gt; inserts
a &lt; &lt;Alt-.&gt; inserts a &gt;

"######################################## " File -
matchMe.vim " Date -		    Wednesday, August 21, 2002
"########################################

" This code fixes my problem with " does the one format for perl and still
keeps hashes function! InsertBrackets()
	let fileType = &ft

	if fileType == 'perl'
		let col = col('.') - 1 if !col || getline('.')[col - 1] !~
		'\k' && getline('.')[col - 1] !~ '\$' && getline('.')[col - 1]
		!~ '@' && getline('.')[col - 1] !~ '%'	&& getline('.')[col -
		1] !~ '#'
			return "{\&lt;cr&gt;\&lt;bs&gt;}\&lt;esc&gt;ko"
		else
			return "{}\&lt;esc&gt;i\&lt;c-o&gt;:echo \&lt;cr&gt;"
		endif
	else
		return "{\&lt;cr&gt;\&lt;bs&gt;}\&lt;esc&gt;ko"
	endif
endfunction

" This code jumps out of the brackets function! JumpNext(normChar)
	let ret =
	"\&lt;space&gt;\&lt;esc&gt;ma\&lt;left&gt;/\\".a:normChar."\&lt;cr&gt;mb`ai\&lt;del&gt;\&lt;esc&gt;`bi\&lt;right&gt;"
	return ret
endfunction

" mappings inoremap " ""&lt;esc&gt;i&lt;c-o&gt;:echo
&lt;cr&gt; inoremap ' ''&lt;esc&gt;i&lt;c-o&gt;:echo &lt;cr&gt;
inoremap &lt; &lt;&gt;&lt;esc&gt;i&lt;c-o&gt;:echo &lt;cr&gt;
inoremap ( ()&lt;esc&gt;i&lt;c-o&gt;:echo &lt;cr&gt; inoremap [
[]&lt;esc&gt;i&lt;c-o&gt;:echo &lt;cr&gt; inoremap { &lt;c-r&gt;=InsertBrackets
()&lt;cr&gt; inoremap &gt; &lt;c-r&gt;=JumpNext("&gt;")&lt;cr&gt;
inoremap ) &lt;c-r&gt;=JumpNext(")")&lt;cr&gt;
inoremap ] &lt;c-r&gt;=JumpNext("]")&lt;cr&gt; inoremap }
&lt;c-r&gt;=JumpNext("}")&lt;cr&gt; inoremap &lt;m-[&gt; [ inoremap &lt;m-]&gt;
] inoremap &lt;m-/&gt; " inoremap &lt;m--&gt; { inoremap &lt;m-=&gt; }
inoremap &lt;m-,&gt; &lt; inoremap &lt;m-.&gt; &gt; inoremap &lt;m-'&gt; '

"######################################## " End Of File
"########################################

If you have any other suggestions, drop a note...

</pre></tip> </html> <Tip category="KVim"> <html><center>text
formatting (lining up ='s,('s etc))</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=319">http://vim.sf.net/tip_view.php?tip_id=319</A><BR>

some time onw would like to reformat text like a=1; foo=2; longstring=1; c=2

to

a	       =1; foo		 =2; longstring  =1; c		    =2;

Note I am not sure wether the code above is displayed properly in your browsers
what  is basically shows is all the ='s are lined up in a single column
and this  is how we achive it 0f=20i&lt;space&gt;&lt;esc&gt;020lvf=hx and
this is what it does 0				   goes to first column f=
finds next occurance of = on current line 20i&lt;space&gt;&lt;esc&gt;
inserts 20 spaces before = 0				   goesback to
first column 20l			     forward 20 column vf=hx
deletes everything up to the = sign

</pre></tip> </html> <Tip category="KVim">
<html><center>Borland pageup/down behavier</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=320">http://vim.sf.net/tip_view.php?tip_id=320</A><BR>

borlandbehavier = the cursor keeps the same xy position during pageup/down

Im new to VIM scripting, im sure it can be done smarter?  I read vimtip #105
and it gave me a clue of how BorlandPageUp/Down could be done.

" i could'nt find any get_number_of_visible_lines function, so i made my own.
function GetNumberOfVisibleLines()
    let cur_line = line(".")  let cur_col = virtcol(".")  normal H let
    top_line = line(".")  normal L let bot_line = line(".")

    execute "normal " . cur_line . "G" execute "normal " . cur_col . "|"
    return bot_line - top_line
endfunc

" noremap &lt;PageUp&gt; 39&lt;C-U&gt;:set scroll=0&lt;CR&gt;
function! MyPageUp()
    let visible_lines = GetNumberOfVisibleLines() execute "normal "
    . visible_lines . "\&lt;C-U&gt;:set scroll=0\r"
endfunction

" noremap &lt;PageDown&gt; 39&lt;C-D&gt;:set scroll=0&lt;CR&gt;
function! MyPageDown()
    let visible_lines = GetNumberOfVisibleLines() execute "normal "
    . visible_lines . "\&lt;C-D&gt;:set scroll=0\r"
endfunction

" BorlandPascal pageup/down behavier!  " todo: when hitting top/bottom of file,
then restore Y to lastY noremap &lt;PageUp&gt; :call MyPageUp()&lt;CR&gt;
noremap &lt;PageDown&gt; :call MyPageDown()&lt;CR&gt;

</pre></tip> </html> <Tip category="KVim"> <html><center>Centura
swap with upper/lower line behavier</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=321">http://vim.sf.net/tip_view.php?tip_id=321</A><BR>

I was once forced to use a windows development suite called "Centura".
The only good thing i remember was its swap current_line with upper/lower line.

function! MySwapUp()
    let cur_col = virtcol(".")	normal ddkkp execute "normal " . cur_col . "|"
endfunction

function! MySwapDown()
    let cur_col = virtcol(".")	normal ddp execute "normal " . cur_col . "|"
endfunction

" swap lines and preserve cursorx " todo: in visual mode, perform swap with
line before/after the selection noremap &lt;S-Up&gt; :call MySwapUp()&lt;CR&gt;
noremap &lt;S-Down&gt; :call MySwapDown()&lt;CR&gt;

</pre></tip> </html> <Tip category="KVim"> <html><center>text
template with placeholders</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=322">http://vim.sf.net/tip_view.php?tip_id=322</A><BR>

Many scripts/ftplugin provide text or code templates. Sadly none of the
marks the places where you are supposed to "fill in the form".	My own code
templates for C/C++ insert a triple percent (%%%) where you are supposed to
enter something. I mapped ;; to find the next %%% and change them.  All the
template mappings are insert-mode only, while the "skip to next placeholder"
is both insert and normal mode enabled.

A complete for-loop template for C++ looks like:

:imap &lt;buffer&gt; ;fo &lt;C-O&gt;mzfor( %%%; %%%; %%%)&lt;CR&gt;{ //
%%%&lt;CR&gt;%%%&lt;CR&gt;}&lt;CR&gt;&lt;C-O&gt;'z;;

The command to go to the next placeholder is this:

:imap &lt;buffer&gt; ;; &lt;C-O&gt;/%%%&lt;CR&gt;&lt;C-O&gt;c3l :nmap
&lt;buffer&gt; ;; /%%%&lt;CR&gt;c3l

Every time I need a for-loop ;fo produces this ( _ is the cursor position)
: for( _; %%% ; %%%) { // %%%
  %%%
}

Now I enter starting value (i=0): for( i=0_; %%% ; %%%) { // %%%
  %%%
}

and go to the condition using ;; for( i=0; _ ; %%%) { // %%%
  %%%
}

and so forth.

The choice of %%% proved to be almost universal, it even works in MATLAB or
LaTeX where % is the comment character.

Even if you forget to replace one %%%, that's not a problem as the compiler
flags is as a syntax error (except MATLAB and LaTeX, of course).

It made my life easier, maybe it works for you.

</pre></tip> </html> <Tip category="KVim">
<html><center>using folders with latex</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=323">http://vim.sf.net/tip_view.php?tip_id=323</A><BR>

set foldmarker=\\begin,\\end set foldmethod=marker

this is useful with big latex document

</pre></tip> </html> <Tip category="KVim"> <html><center>Search
and replace in files named NAME</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=324">http://vim.sf.net/tip_view.php?tip_id=324</A><BR>

I'm not sure if there is a simple way to do this from within Vim, but,
I wrote this simple script that does it. It basically searches for files
named NAMED (whatever name pass) for a given string and replaces that with
a given string: find_replace.sh NAMED "string_to_find" "string_to_replace"

This is all done from the command line without opening Vim.

Of course one could do things like:
		    :let n = 1 :while n &lt;= argc()	  " loop over all
		    files in arglist :	exe "argument " . n :  " start at
		    the last char in the file and wrap for the :  " first
		    search to find match at start of file :  normal G$ :
		    let flags = "w" :  while search("foo", flags) &gt; 0 :
		    s/foo/bar/g :    let flags = "W" :	endwhile :  update
		    " write the file if modified :  let n = n + 1 :endwhile

As suggested in the Vim help files :-) but, I wanted to go and find only
these files... here is the script:
      1 #!/bin/sh 2 # Luis Mondesi &lt; lemsx1@hotmail.com &gt; 3 #
      DESCRIPTION: 4 #	 it uses vim to replace a given string for 5 #
      another in a  number of files 6 # 7 # usage: 8 #	 find_replace.sh file
      "string" "replace" 9 #
     10 if [ $1 -a $2 -a $3 ]; then 11	   for i in `find . -name "$1"
     -type f | xargs grep -l $2`; do 12		# how do search and replace
     13		# the screen might flicker... vim opening and closing...
     14		vim -c ":%s/$2/$3/g" -c ":wq" $i 15	done 16     exit 0
     17 fi 18 # I should never reach here 19 echo -e "USAGE: find_replace.sh
     file 'string' 'replace' \n\n" 20 exit 1

</pre></tip> </html> <Tip category="KVim"> <html><center>Errorformat
for java/ant/junit/cygwin/bash</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=325">http://vim.sf.net/tip_view.php?tip_id=325</A><BR>

If you program in Java and use Jakarta ant for builds *and* if you have the
bash shell, this tip will make your development experience a little smoother.

This tip will result in a working compile/edit/debug system (in Win32 vim/gvim
and in Cygwin vim) that takes you to the exact lines where the build fails,
whether the failure is a compilation error or a junit test failure.  If you
use bash on a linux box, you shouldn't have to change very much to get
everything to work.

There are 6 sections: 1. set up your build script 2. set up makeprg 3. set
up shell options 4. set up path formatting options 5. set up your errorformat
6. set up key mappings

Set up build script ------------------- Add the following script to your path
(I use /usr/local/bin/):

mymake: #!/bin/bash cd /work/ ant -emacs $* 2&gt;&1 | tr '\\' / | tr ^M '
' | sed -u -n -f /usr/local/bin/testerrors.sed | tee /tmp/errors

Comment: sed -u is non-standard, use the code at: <A
HREF="http://mail.gnu.org/pipermail/bug-gnu-utils/2002-May/000192.html to
get">http://mail.gnu.org/pipermail/bug-gnu-utils/2002-May/000192.html to
get</A><BR> the -u option for sed (this avoids waiting for the build output
to get to the screen)

testerrors.sed: # This assumes that all your junit test cases are in a com.*
package /^Running com\./ {
    # duplicate the line s!\(.*\)!\1\
\1!
    P

    # turn the test package into a directory path for %D errorformat
    s!.*\(com\..*\)\.[A-Za-z_][A-Za-z0-9_]*!\1!  s!\.!/!g s!.*!Entering:
    /work/src/&!

    # print the line and go on p n
}

# just pass any unmatched lines through p

Set up makeprg -------------- Add the following lines to your vimrc:
  autocmd BufNewFile,BufRead /work/*.java set makeprg=mymake autocmd
  BufNewFile,BufRead ?:/work/*.java set makeprg=mymake

Set up shell options -------------------- Add the following lines to your
vimrc:
  " in order to have bash as the shell for win32 vi.exe and gvim.exe,
  you have " to set these options, and also build vimrun.exe in the cygwin
  environment " so that the system() call is executed via bash, not cmd.exe
  -- the command " to build vimrun.exe is "make -f Make_cyg.mak vimrun.exe"
  set shell=bash.exe set shellcmdflag=-c set shellslash

Also to use this environment in Win32 gvim, you must recompile vimrun so
that gvim invokes the shell via bash, not via cmd.exe.

Set up path formatting options ------------------------------ Add the
following lines to your vimrc:
  " allows DOS file names from UNIX (Cygwin) vim set isfname+=\

Set up your errorformat ----------------------- Add the following lines to
your vimrc:
  " the "\%DEntering:\ %f," rule relies on a sed script which generates "
  "Entering: " messages for each test class run (the directory name is "
  generated from the test class package and a hard-coded src root)

  " the "%\\C" at the start of the exception matching line tells to match
  " case-exact (the exception mathching lines rely on the %D rule that sets
  " up the correct directory from the package structure)

  " ant/junit/javac errorformat set errorformat=
      \%-G%.%#build.xml:%.%#, \%-G%.%#warning:\ %.%#, \%-G%\\C%.%#EXPECTED%.%#,
      \%f:%l:\ %#%m, \C:%f:%l:\ %m, \%DEntering:\ %f\ %\\=, \%ECaused\
      by:%[%^:]%#:%\\=\ %\\=%m, \%ERoot\ cause:%[%^:]%#:%\\=\ %\\=%m,
      \%Ecom.%[%^:]%#:%\\=\ %\\=%m, \%Eorg.%[%^:]%#:%\\=\ %\\=%m,
      \%Ejava.%[%^:]%#:%\\=\ %\\=%m, \%Ejunit.%[%^:]%#:%\\=\ %\\=%m,
      \%-Z%\\C\ at\ com.mypkg.%.%#.test%[A-Z]%.%#(%f:%l)\ %\\=,
      \%-Z%\\C\ at\ com.mypkg.%.%#.setUp(%f:%l)\ %\\=, \%-Z%\\C\ at\
      com.mypkg.%.%#.tearDown(%f:%l)\ %\\=, \%-Z%^\ %#%$, \%-C%.%#, \%-G%.%#

NOTE: Make sure that the character before "at" is an actual Tab character
in the three long -Z lines above

Here is an annotated version:
  set errorformat=
      " don't treat the build.xml diagnostic as an error
      \%-G%.%#build.xml:%.%#,

      " don't treat warning lines as errors \%-G%.%#warning:\ %.%#,

      " don't treat lines containing "EXPECTED" as errors
      \%-G%\\C%.%#EXPECTED%.%#,

      " look for this standard error format \%f:%l:\ %#%m,

      " look for this standard error format (with C: on front) \C:%f:%l:\ %m,

      " look for special sed-generated "Entering" lines while running tests
      \%DEntering:\ %f\ %\\=,

      " look for exceptions that were thrown in the tests, use the exception
      " description as the error message (don't know how to also include the
      " exception name in the error message) \%ECaused\ by:%[%^:]%#:%\\=\
      %\\=%m, \%ERoot\ cause:%[%^:]%#:%\\=\ %\\=%m, \%Ecom.%[%^:]%#:%\\=\
      %\\=%m, \%Eorg.%[%^:]%#:%\\=\ %\\=%m, \%Ejava.%[%^:]%#:%\\=\ %\\=%m,
      \%Ejunit.%[%^:]%#:%\\=\ %\\=%m,

      " using the "Entering" directory and the filename/line number provided
      " in the exception trace, go to the test method where the exception
      " was thrown \%-Z%\\C\ at\ com.mypkg.%.%#.test%[A-Z]%.%#(%f:%l)\
      %\\=, \%-Z%\\C\ at\ com.mypkg.%.%#.setUp(%f:%l)\ %\\=, \%-Z%\\C\ at\
      com.mypkg.%.%#.tearDown(%f:%l)\ %\\=,

      " empty lines terminate searching for further exception lines \%-Z%^\
      %#%$,

      " any line can intervene between the start of an exception printout
      " and the line where it ends (last in list so that it is matched if
      " none of the other exception trace patterns match) \%-C%.%#,

      " all other lines are not errors \%-G%.%#

Set up key mappings ------------------- Add the following lines to your vimrc:
  nmap &lt;F10&gt; :clist&lt;CR&gt; nmap &lt;F11&gt; :cprev&lt;CR&gt; nmap
  &lt;F12&gt; :cnext&lt;CR&gt;

This allows for quick error navigation.

NOTES ----- Vim treats the "Entering: /work/src/..." messages in a weird way.
If there are any actual errors, then these error lines are ignored by the
:cnext and :cprev commands, but if there are no real errors, then :cnext and
:cprev roll through these "Entering:" messages as if they were errors, but
since they don't include any line numbers, the cursor position is never moved.

I thought that this was strange, but even stranger, it is programmed directly
into the vim error handling code to function exactly this way.	There were
no comments, and nobody responded on the vim mailing list, so I just decided
to live with it.

The upshot of it all is that if you see an error like "Entering:", chances
are that your build succeeded and all the tests ran without a problem.

Hope this helps...

Mail me with bugs at jdsumsion at earthlink.net.

</pre></tip> </html> <Tip category="KVim"> <html><center>Help
for VIM Help (VIM QuickRef)</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=326">http://vim.sf.net/tip_view.php?tip_id=326</A><BR>

Type :help quickref or :h quic

And get a VIM Command Quick Reference Page brilliant for beginners &
oldtimers alike

type :h help to learn how to use help

Other Help Tips

# help for help :h visual&lt;C-D&gt;&lt;tab&gt;     : obtain  list of all
visual help topics
			: Then use tab to step thru them
:h ctrl&lt;C-D&gt;	      : list help of all control keys :h :r
: help for :ex command :h CTRL-R	       : normal mode :h \r
: what's \r in a regexp :h i_CTRL-R		: help for say &lt;C-R&gt;
in insert mode :h c_CTRL-R	       : help for say &lt;C-R&gt; in command
mode :h v_CTRL-V	     : visual mode :h tutor		 : VIM Tutor

These are also listed in my Best Of VIM Tips vimtip #305

</pre></tip> </html> <Tip category="KVim">
<html><center>key mappings</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=327">http://vim.sf.net/tip_view.php?tip_id=327</A><BR>

I use my left thumb for the alt key and right for the space. Using this
combo, you can get some useful key maps for which you don't have to move
your hands. I find I have to turn my hand a little to press the left ctrl key.

These are some maps i use for C programming.

map ' ` map &lt;C-f&gt; :w&lt;C-m&gt;:!make&lt;C-m&gt; map &lt;M-]&gt;
&lt;C-]&gt;					    Tags map &lt;M-[&gt;
&lt;C-t&gt;					     Tags map &lt;M-u&gt;
:!ctags -R *&lt;C-m&gt;						 Build
Tags map &lt;M-c&gt; I/*&lt;Esc&gt;A*/&lt;Esc&gt;
Comment current line map &lt;M-d&gt; ^xx$xx
Delete comment for a single line map &lt;M-l&gt;
[{zf%					       Fold upto the enclosing brace
level map &lt;M-o&gt; zo					   open fold
map &lt;M-i&gt; zc					    close fold map
&lt;M-.&gt; :cn&lt;C-m&gt;					    Go
to next error in list map &lt;M-,&gt; :cp&lt;C-m&gt;
previous error in list

imap &lt;Tab&gt; &lt;C-p&gt;
Complete word inoremap &lt;S-Tab&gt; &lt;Tab&gt;
Tab inoremap { &lt;CR&gt;{&lt;CR&gt;
Brace and line inoremap } &lt;CR&gt;}
brace and line. saves one enter stroke

imap &lt;M-j&gt; &lt;Esc&gt;
Escape. Don't want to move my hand to esc key.	imap &lt;M-k&gt; &lt;C-y&gt;
Copy line from above.  imap &lt;M-q&gt; /*  */&lt;Esc&gt;hhi
Comment selected lines

noremap &lt;M-r&gt; ddko{&lt;C-m&gt;}&lt;Esc&gt;kpko		 Convert a
simple statement to a compound statement. And place cursor above prev line.
noremap &lt;M-k&gt; ddko{&lt;C-m&gt;}&lt;Esc&gt;kpo		Same as
above but place cursor below old line.

vnoremap &lt;M-j&gt; &lt;Esc&gt; vnoremap &lt;M-c&gt;
di/*&lt;C-m&gt;/&lt;C-m&gt;&lt;Esc&gt;kkp	    Commented selected text

nmap &lt;M-n&gt; :noh&lt;CR&gt;			      No hilight

Bye,
    Nithin.

</pre></tip> </html> <Tip category="KVim"> <html><center>Vim
in Microsoft Visual Foxpro</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=328">http://vim.sf.net/tip_view.php?tip_id=328</A><BR>

You can tell MS VFP to use an external editor for editing project files.
To tell MS VFP to use Vim:

start regedit locate [HKEY_CURRENT_USER
 \Software
  \Microsoft
   \VisualFoxPro
    \5.0
     \Options]

and create a new item TEDIT with string content "/N
C:\Progra~1\vim\vim61\gvim.exe" (or whatever your path to Vim happens to be.)

This will not replace the internal VFP editor for such things as modifying the
"click method" for a button (unfortunately), but when you modify a program,
VFP will fire up gvim.

Start MS VFP, start Help and look for TEDIT. ;-)

</pre></tip> </html> <Tip category="KVim">
<html><center>A map for swapping words</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=329">http://vim.sf.net/tip_view.php?tip_id=329</A><BR>

Put the following map into your &lt;.vimrc&gt;:

  nmap &lt;silent&gt; gw
  "_yiw:s/\(\%#\w\+\)\(\W\+\)\(\w\+\)/\3\2\1/&lt;cr&gt;&lt;c-o&gt;&lt;c-l&gt;

Then when you put the cursor on or in a word, press "gw", and the word will
be swapped with the next word.	The words may even be separated by punctuation
(such as "abc = def").

While we're talking swapping, here's a map for swapping characters:

  nmap &lt;silent&gt; gc    xph

This hint was formed in a collaboration between Chip Campbell - Arun Easi -
Benji Fisher

</pre></tip> </html> <Tip category="KVim">
<html><center>how to stop auto indenting</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=330">http://vim.sf.net/tip_view.php?tip_id=330</A><BR>

Since VIM 6.0 the indent has been improved so much.  But sometimes when
we are pasting formated text (source code or HTML etc) into a buffer, VIM
indents again so that lines will be padded with too much spaces.

Setting nocindent, noautoindent, nosmartindent still cannot stop this.	All you
need to do is "set paste", then paste your stuff, and then "set nopaste" again.

Ref: indentexpr

</pre></tip> </html> <Tip category="KVim">
<html><center>modline magic...</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=331">http://vim.sf.net/tip_view.php?tip_id=331</A><BR>

  One  of the  things about  vim that  are both  quite simple  yet very
useful is that you can store  by-file settings... that is each file can
contain settings specific to it. this  thing is called a modline (:help
modline). though this  is limited to only the  'set' command arguments, you
can do allot of local to  file things like the indent type, folding method
and so on.

the syntax is as follows:

// vim:set ts=4 sw=4 nowrap:

or

/* vim:noai:ts=2:sw=4: */

  The modlines can be contained in comments so as to not interfere with
the file  syntax (shown here  for C/C++). these  lines are read  by vim when
it loads the  file, and they can either be in the  first or last 5 lines
(by default).

refer to ':help modline'

//and a happy 20th birthday to the good old smiley!! :-)

</pre></tip> </html> <Tip category="KVim">
<html><center>make footnotes in vim</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=332">http://vim.sf.net/tip_view.php?tip_id=332</A><BR>

I found at <A
HREF="http://groups.google.com/groups?q=vim+changing+shell+to+zsh&hl=en&lr=&ie=UTF-8&selm=S_Rh9.716%24a5.124150%40news.uchicago.edu&rnum=4">http://groups.google.com/groups?q=vim+changing+shell+to+zsh&hl=en&lr=&ie=UTF-8&selm=S_Rh9.716%24a5.124150%40news.uchicago.edu&rnum=4</A><BR>
a macro to insert footnotes in vim, but it doesn't work as of vim6.0.  so i
wrote my own; this macro requires two differents shortcuts, one for entering
the first footnote, the other one for all subsequent footnotes.

when you hit "K0" (first footnote) or "KK" (all other footnotes) in normal
mode, your cursor is positionned at the end of the document, in the footnote &
in insert mode. The "a" bookmark is set to the place where you entered the
footnote in the text. so a "`a" will bring you back to the location of the
footnote in the text.

" for now requires entering K0 for the first footnote and then KK
nmap K0 i[0]&lt;esc&gt;maG$i&lt;end&gt;&lt;enter&gt;[0] nmap KK
maG$?\[[0-9]*\]&lt;enter&gt;yt]G$i&lt;end&gt;&lt;enter&gt;&lt;esc&gt;p&lt;C-a&gt;i&lt;end&gt;]&lt;esc&gt;`aP&lt;C-a&gt;&lt;right&gt;i]&lt;esc&gt;maG$i&lt;end&gt;&lt;end&gt;

</pre></tip> </html> <Tip category="KVim">
<html><center>Syntax-based folding for c/c++/java</center> <pre> <A
HREF="http://vim.sf.net/tip_view.php?tip_id=333">http://vim.sf.net/tip_view.php?tip_id=333</A><BR>

Here's a function to toggle the use of syntax-based folding for a c/c++/java
file. It also handles folding markers.

function! OutlineToggle()
    if (! exists ("b:outline_mode"))
	let b:outline_mode = 0
    endif

    if (b:outline_mode == 0)
	syn region myFold start="{" end="}" transparent fold syn sync
	fromstart set foldmethod=syntax

	silent! exec "%s/{{{/&lt;&lt;&lt;/" silent! exec "%s/}}}/&gt;&gt;&gt;/"

	let b:outline_mode = 1
    else
	set foldmethod=marker

	silent! exec "%s/&lt;&lt;&lt;/{{{/" silent! exec "%s/&gt;&gt;&gt;/}}}/"

	let b:outline_mode = 0
    endif
endfunction

</html></tip>
