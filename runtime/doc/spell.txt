*spell.txt*	For Vim version 7.0aa.  Last change: 2005 Dec 29


		  VIM REFERENCE MANUAL	  by Bram Moolenaar


Spell checking						*spell*

1. Quick start			|spell-quickstart|
2. Remarks on spell checking	|spell-remarks|
3. Generating a spell file	|spell-mkspell|
4. Spell file format		|spell-file-format|

{Vi does not have any of these commands}

Spell checking is not available when the |+syntax| feature has been disabled
at compile time.

==============================================================================
1. Quick start						*spell-quickstart*

This command switches on spell checking: >

	:setlocal spell spelllang=en_us

This switches on the 'spell' option and specifies to check for US English.

The words that are not recognized are highlighted with one of these:
	SpellBad	word not recognized			|hl-SpellBad|
	SpellCap	word not capitalised			|hl-SpellCap|
	SpellRare	rare word				|hl-SpellRare|
	SpellLocal	wrong spelling for selected region	|hl-SpellLocal|

Vim only checks words for spelling, there is no grammar check.

If the 'mousemodel' option is set to "popup" and the cursor is on a badly
spelled word or it is "popup_setpos" and the mouse pointer is on a badly
spelled word, then the popup menu will contain a submenu to replace the bad
word.  Note: this slows down the appearance of the popup menu.

To search for the next misspelled word:

							*]s* *E756*
]s			Move to next misspelled word after the cursor.
			A count before the command can be used to repeat.
			'wrapscan' applies.

							*[s*
[s			Like "]s" but search backwards, find the misspelled
			word before the cursor.  Doesn't recognize words
			split over two lines, thus may stop at words that are
			not highlighted as bad.  Does not stop at word with
			missing capital at the start of a line.

							*]S*
]S			Like "]s" but only stop at bad words, not at rare
			words or words for another region.

							*[S*
[S			Like "]S" but search backwards.


To add words to your own word list:

							*zg*
zg			Add word under the cursor as a good word to the first
			name in 'spellfile'.  A count may precede the command
			to indicate the entry in 'spellfile' to be used.  A
			count of two uses the second entry.

			In Visual mode the selected characters are added as a
			word (including white space!).
			When the cursor is on text that is marked as badly
			spelled then the marked text is used.
			Otherwise the word under the cursor, separated by
			non-word characters, is used.

			If the word is explicitly marked as bad word in
			another spell file the result is unpredictable.

							*zG*
zG			Like "zg" but add the word to the internal word list
			|internal-wordlist|.

							*zw*
zw			Like "zg" but mark the word as a wrong (bad) word.

							*zW*
zW			Like "zw" but add the word to the internal word list
			|internal-wordlist|.

							*:spe* *:spellgood*
:[count]spe[llgood] {word}
			Add {word} as a good word to 'spellfile', like with
			"zg".  Without count the first name is used, with a
			count of two the second entry, etc.

:spe[llgood]! {word}	Add {word} as a good word to the internal word list,
			like with "zG".

							*:spellw* *:spellwrong*
:[count]spellw[rong] {word}
			Add {word} as a wrong (bad) word to 'spellfile', as
			with "zw".  Without count the first name is used, with
			a count of two the second entry, etc.

:spellw[rong]! {word}	Add {word} as a wrong (bad) word to the internal word
			list.

After adding a word to 'spellfile' with the above commands its associated
".spl" file will automatically be updated and reloaded.  If you change
'spellfile' manually you need to use the |:mkspell| command.  This sequence of
commands mostly works well: >
	:edit <file in 'spellfile'>
<	(make changes to the spell file) >
	:mkspell! %

More details about the 'spellfile' format below |spell-wordlist-format|.

							*internal-wordlist*
The internal word list is used for all buffers where 'spell' is set.  It is
not stored, it is lost when you exit Vim.  It is also cleared when 'encoding'
is set.


Finding suggestions for bad words:
							*z=*
z=			For the word under/after the cursor suggest correctly
			spelled words.  This also works to find alternatives
			for a word that is not highlighted as a bad word,
			e.g., when the word after it is bad.
			The results are sorted on similarity to the word
			under/after the cursor.
			This may take a long time.  Hit CTRL-C when you get
			bored.

			If the command is used without a count the
			alternatives are listed and you can enter the number
			of your choice or press <Enter> if you don't want to
			replace.  You can also use the mouse to click on your
			choice (only works if the mouse can be used in Normal
			mode and when there are no line wraps).  Click on the
			first line (the header) to cancel.

			If a count is used that suggestion is used, without
			prompting.  For example, "1z=" always takes the first
			suggestion.

			If 'verbose' is non-zero a score will be displayed
			with the suggestions to indicate the likeliness to the
			badly spelled word (the higher the score the more
			different).
			When a word was replaced the redo command "." will
			repeat the word replacement.  This works like "ciw",
			the good word and <Esc>.  This does NOT work for Thai
			and other languages without spaces between words.

					*:spellr* *:spellrepall* *E752* *E753*
:spellr[epall]		Repeat the replacement done by |z=| for all matches
			with the replaced word in the current window.

In Insert mode, when the cursor is after a badly spelled word, you can use
CTRL-X s to find suggestions.  This works like Insert mode completion.  Use
CTRL-N to use the next suggestion, CTRL-P to go back. |i_CTRL-X_s|

The 'spellsuggest' option influences how the list of suggestions is generated
and sorted.  See |'spellsuggest'|.

The 'spellcapcheck' option is used to check the first word of a sentence
starts with a capital.  This doesn't work for the first word in the file.
When there is a line break right after a sentence the highlighting of the next
line may be postponed.  Use |CTRL-L| when needed.  Also see |set-spc-auto| for
how it can be set automatically when 'spelllang' is set.

==============================================================================
2. Remarks on spell checking				*spell-remarks*

PERFORMANCE

Vim does on-the-fly spell checking.  To make this work fast the word list is
loaded in memory.  Thus this uses a lot of memory (1 Mbyte or more).  There
might also be a noticeable delay when the word list is loaded, which happens
when 'spell' is set and when 'spelllang' is set while 'spell' was already set.
To minimize the delay each word list is only loaded once, it is not deleted
when 'spelllang' is made empty or 'spell' is reset.  When 'encoding' is set
all the word lists are reloaded, thus you may notice a delay then too.


REGIONS

A word may be spelled differently in various regions.  For example, English
comes in (at least) these variants:

	en		all regions
	en_au		Australia
	en_ca		Canada
	en_gb		Great Britain
	en_nz		New Zealand
	en_us		USA

Words that are not used in one region but are used in another region are
highlighted with SpellLocal |hl-SpellLocal|.

Always use lowercase letters for the language and region names.

When adding a word with |zg| or another command it's always added for all
regions.  You can change that by manually editing the 'spellfile'.  See
|spell-wordlist-format|.  Note that the regions as specified in the files in
'spellfile' are only used when all entries in 'spelllang' specify the same
region (not counting files specified by their .spl name).

							*spell-german*
Specific exception: For German these special regions are used:
	de		all German words accepted
	de_de		old and new spelling
	de_19		old spelling
	de_20		new spelling
	de_at		Austria
	de_ch		Switzerland

							*spell-russian*
Specific exception: For Russian these special regions are used:
	ru		all Russian words accepted
	ru_ru		"IE" letter spelling
	ru_yo		"YO" letter spelling

							*spell-yiddish*
Yiddish requires using "utf-8" encoding, because of the special characters
used.  If you are using latin1 Vim will use transliterated (romanized) Yiddish
instead.  If you want to use transliterated Yiddish with utf-8 use "yi-tr".
In a table:
	'encoding'	'spelllang'
	utf-8		yi		Yiddish
	latin1		yi		transliterated Yiddish
	utf-8		yi-tr		transliterated Yiddish


SPELL FILES						*spell-load*

Vim searches for spell files in the "spell" subdirectory of the directories in
'runtimepath'.  The name is: LL.EEE.spl, where:
	LL	the language name
	EEE	the value of 'encoding'

The value for "LL" comes from 'spelllang', but excludes the region name.
Examples:
	'spelllang'	LL ~
	en_us		en
	en-rare		en-rare
	medical_ca	medical

Only the first file is loaded, the one that is first in 'runtimepath'.  If
this succeeds then additionally files with the name LL.EEE.add.spl are loaded.
All the ones that are found are used.

Additionally, the files related to the names in 'spellfile' are loaded.  These
are the files that |zg| and |zw| add good and wrong words to.

Exceptions:
- Vim uses "latin1" when 'encoding' is "iso-8859-15".  The euro sign doesn't
  matter for spelling.
- When no spell file for 'encoding' is found "ascii" is tried.  This only
  works for languages where nearly all words are ASCII, such as English.  It
  helps when 'encoding' is not "latin1", such as iso-8859-2, and English text
  is being edited.  For the ".add" files the same name as the found main
  spell file is used.

For example, with these values:
	'runtimepath' is "~/.vim,/usr/share/vim70,~/.vim/after"
	'encoding'    is "iso-8859-2"
	'spelllang'   is "pl"

Vim will look for:
1. ~/.vim/spell/pl.iso-8859-2.spl
2. /usr/share/vim70/spell/pl.iso-8859-2.spl
3. ~/.vim/spell/pl.iso-8859-2.add.spl
4. /usr/share/vim70/spell/pl.iso-8859-2.add.spl
5. ~/.vim/after/spell/pl.iso-8859-2.add.spl

This assumes 1. is not found and 2. is found.

If 'encoding' is "latin1" Vim will look for:
1. ~/.vim/spell/pl.latin1.spl
2. /usr/share/vim70/spell/pl.latin1.spl
3. ~/.vim/after/spell/pl.latin1.spl
4. ~/.vim/spell/pl.ascii.spl
5. /usr/share/vim70/spell/pl.ascii.spl
6. ~/.vim/after/spell/pl.ascii.spl

This assumes none of them are found (Polish doesn't make sense when leaving
out the non-ASCII characters).

Spelling for EBCDIC is currently not supported.

A spell file might not be available in the current 'encoding'.  See
|spell-mkspell| about how to create a spell file.  Converting a spell file
with "iconv" will NOT work!

							*E758* *E759*
When loading a spell file Vim checks that it is properly formatted.  If you
get an error the file may be truncated, modified or intended for another Vim
version.


WORDS

Vim uses a fixed method to recognize a word.  This is independent of
'iskeyword', so that it also works in help files and for languages that
include characters like '-' in 'iskeyword'.  The word characters do depend on
'encoding'.

The table with word characters is stored in the main .spl file.  Therefore it
matters what the current locale is when generating it!  A .add.spl file does
not contain a word table though.

A word that starts with a digit is always ignored.  That includes hex numbers
in the form 0xff and 0XFF.


WORD COMBINATIONS

It is possible to spell-check words that include a space.  This is used to
recognize words that are invalid when used by themselves, e.g. for "et al.".
It can also be used to recognize "the the" and highlight it.

The number of spaces is irrelevant.  In most cases a line break may also
appear.  However, this makes it difficult to find out where to start checking
for spelling mistakes.  When you make a change to one line and only that line
is redrawn Vim won't look in the previous line, thus when "et" is at the end
of the previous line "al." will be flagged as an error.  And when you type
"the<CR>the" the highlighting doesn't appear until the first line is redrawn.
Use |CTRL-L| to redraw right away.  "[s" will also stop at a word combination
with a line break.

When encountering a line break Vim skips characters such as '*', '>' and '"',
so that comments in C, shell and Vim code can be spell checked.


SYNTAX HIGHLIGHTING					*spell-syntax*

Files that use syntax highlighting can specify where spell checking should be
done:

1.  everywhere			   default
2.  in specific items		   use "contains=@Spell"
3.  everywhere but specific items  use "contains=@NoSpell"

For the second method adding the @NoSpell cluster will disable spell checking
again.  This can be used, for example, to add @Spell to the comments of a
program, and add @NoSpell for items that shouldn't be checked.


VIM SCRIPTS

If you want to write a Vim script that does something with spelling, you may
find these functions useful:

    spellbadword()	find badly spelled word at the cursor
    spellsuggest()	get list of spelling suggestions
    soundfold()		get the sound-a-like version of a word


SETTING 'spellcapcheck' AUTOMATICALLY			*set-spc-auto*

After the 'spelllang' option has been set successfully, Vim will source the
files "spell/LANG.vim" in 'runtimepath'.  "LANG" is the value of 'spelllang'
up to the first comma, dot or underscore.  This can be used to set options
specifically for the language, especially 'spellcapcheck'.

The distribution includes a few of these files.  Use this command to see what
they do: >
	:next $VIMRUNTIME/spell/*.vim

Note that the default scripts don't set 'spellcapcheck' if it was changed from
the default value.  This assumes the user prefers another value then.


DOUBLE SCORING						*spell-double-scoring*

The 'spellsuggest' option can be used to select "double" scoring.  This
mechanism is based on the principle that there are two kinds of spelling
mistakes:

1. You know how to spell the word, but mistype something.  This results in a
   small editing distance (character swapped/omitted/inserted) and possibly a
   word that sounds completely different.

2. You don't know how to spell the word and type something that sounds right.
   The edit distance can be big but the word is similar after sound-folding.

Since scores for these two mistakes will be very different we use a list
for each and mix them.

The sound-folding is slow and people that know the language won't make the
second kind of mistakes.  Therefore 'spellsuggest' can be set to select the
preferred method for scoring the suggestions.

==============================================================================
3. Generating a spell file				*spell-mkspell*

Vim uses a binary file format for spelling.  This greatly speeds up loading
the word list and keeps it small.
						    *.aff* *.dic* *Myspell*
You can create a Vim spell file from the .aff and .dic files that Myspell
uses.  Myspell is used by OpenOffice.org and Mozilla.  You should be able to
find them here:
	http://lingucomponent.openoffice.org/spell_dic.html
You can also use a plain word list.  The results are the same, the choice
depends on what word lists you can find.

If you install Aap (from www.a-a-p.org) you can use the recipes in the
runtime/spell/??/ directories.  Aap will take care of downloading the files,
apply patches needed for Vim and build the .spl file.

Make sure your current locale is set properly, otherwise Vim doesn't know what
characters are upper/lower case letters.  If the locale isn't available (e.g.,
when using an MS-Windows codepage on Unix) add tables to the .aff file
|spell-affix-chars|.  If the .aff file doesn't define a table then the word
table of the currently active spelling is used.  If spelling is not active
then Vim will try to guess.

							*:mksp* *:mkspell*
:mksp[ell][!] [-ascii] {outname} {inname} ...
			Generate a Vim spell file from word lists.  Example: >
		:mkspell /tmp/nl nl_NL.words
<								*E751*
			When {outname} ends in ".spl" it is used as the output
			file name.  Otherwise it should be a language name,
			such as "en", without the region name.  The file
			written will be "{outname}.{encoding}.spl", where
			{encoding} is the value of the 'encoding' option.

			When the output file already exists [!] must be used
			to overwrite it.

			When the [-ascii] argument is present, words with
			non-ascii characters are skipped.  The resulting file
			ends in "ascii.spl".

			The input can be the Myspell format files {inname}.aff
			and {inname}.dic.  If {inname}.aff does not exist then
			{inname} is used as the file name of a plain word
			list.

			Multiple {inname} arguments can be given to combine
			regions into one Vim spell file.  Example: >
		:mkspell ~/.vim/spell/en /tmp/en_US /tmp/en_CA /tmp/en_AU
<			This combines the English word lists for US, CA and AU
			into one en.spl file.
			Up to eight regions can be combined. *E754* *755*
			The REP and SAL items of the first .aff file where
			they appear are used. |spell-REP| |spell-SAL|

			This command uses a lot of memory, required to find
			the optimal word tree (Polish, Italian and Hungarian
			require several hundred Mbyte).  The final result will
			be much smaller, because compression is used.  To
			avoid running out of memory compression will be done
			now and then.  This can be tuned with the 'mkspellmem'
			option.

			After the spell file was written and it was being used
			in a buffer it will be reloaded automatically.

:mksp[ell] [-ascii] {name}.{enc}.add
			Like ":mkspell" above, using {name}.{enc}.add as the
			input file and producing an output file in the same
			directory that has ".spl" appended.

:mksp[ell] [-ascii] {name}
			Like ":mkspell" above, using {name} as the input file
			and producing an output file in the same directory
			that has ".{enc}.spl" appended.

Vim will report the number of duplicate words.  This might be a mistake in the
list of words.  But sometimes it is used to have different prefixes and
suffixes for the same basic word to avoid them combining (e.g. Czech uses
this).  If you want Vim to report all duplicate words set the 'verbose'
option.

Since you might want to change a Myspell word list for use with Vim the
following procedure is recommended:

1. Obtain the xx_YY.aff and xx_YY.dic files from Myspell.
2. Make a copy of these files to xx_YY.orig.aff and xx_YY.orig.dic.
3. Change the xx_YY.aff and xx_YY.dic files to remove bad words, add missing
   words, define word characters with FOL/LOW/UPP, etc.  The distributed
   "src/spell/*.diff" files can be used.
4. Start Vim with the right locale and use |:mkspell| to generate the Vim
   spell file.
5. Try out the spell file with ":set spell spelllang=xx" if you wrote it in
   a spell directory in 'runtimepath', or ":set spelllang=xx.enc.spl" if you
   wrote it somewhere else.

When the Myspell files are updated you can merge the differences:
1. Obtain the new Myspell files as xx_YY.new.aff and xx_UU.new.dic.
2. Use Vimdiff to see what changed: >
	vimdiff xx_YY.orig.dic xx_YY.new.dic
3. Take over the changes you like in xx_YY.dic.
   You may also need to change xx_YY.aff.
4. Rename xx_YY.new.dic to xx_YY.orig.dic and xx_YY.new.aff to xx_YY.new.aff.


SPELL FILE VERSIONS					*E770* *E771* *E772*

Spell checking is a relatively new feature in Vim, thus it's possible that the
.spl file format will be changed to support more languages.  Vim will check
the validity of the spell file and report anything wrong.

	E771: Old spell file, needs to be updated ~
This spell file is older than your Vim.  You need to update the .spl file.

	E772: Spell file is for newer version of Vim ~
This means the spell file was made for a later version of Vim.  You need to
update Vim.

	E770: Unsupported section in spell file ~
This means the spell file was made for a later version of Vim and contains a
section that is required for the spell file to work.  In this case it's
probably a good idea to upgrade your Vim.


SPELL FILE DUMP

If for some reason you want to check what words are supported by the currently
used spelling files, use this command:

							*:spelldump* *:spelld*
:spelld[ump]		Open a new window and fill it with all currently valid
			words.  Compound words are not included.
			Note: For some languages the result may be enormous,
			causing Vim to run out of memory.

The format of the word list is used |spell-wordlist-format|.  You should be
able to read it with ":mkspell" to generate one .spl file that includes all
the words.

When all entries to 'spelllang' use the same regions or no regions at all then
the region information is included in the dumped words.  Otherwise only words
for the current region are included and no "/regions" line is generated.

Comment lines with the name of the .spl file are used as a header above the
words that were generated from that .spl file.

==============================================================================
4. Spell file format					*spell-file-format*

This is the format of the files that are used by the person who creates and
maintains a word list.

Note that we avoid the word "dictionary" here.  That is because the goal of
spell checking differs from writing a dictionary (as in the book).  For
spelling we need a list of words that are OK, thus should not be highlighted.
Person and company names will not appear in a dictionary, but do appear in a
word list.  And some old words are rarely used while they are common
misspellings.  These do appear in a dictionary but not in a word list.

There are two formats: A straight list of words and a list using affix
compression.  The files with affix compression are used by Myspell (Mozilla
and OpenOffice.org).  This requires two files, one with .aff and one with .dic
extension.


FORMAT OF STRAIGHT WORD LIST				*spell-wordlist-format*

The words must appear one per line.  That is all that is required.

Additionally the following items are recognized:

- Empty and blank lines are ignored.

- Lines starting with a # are ignored (comment lines).

- A line starting with "/encoding=", before any word, specifies the encoding
  of the file.  After the second '=' comes an encoding name.  This tells Vim
  to setup conversion from the specified encoding to 'encoding'.  Thus you can
  use one word list for several target encodings.

- A line starting with "/regions=" specifies the region names that are
  supported.  Each region name must be two ASCII letters.  The first one is
  region 1.  Thus "/regions=usca" has region 1 "us" and region 2 "ca".
  In an addition word list the region names should be equal to the main word
  list!

- Other lines starting with '/' are reserved for future use.  The ones that
  are not recognized are ignored (but you do get a warning message).

- A "/" may follow the word with the following items:
    =   	Case must match exactly.
    ?		Rare word.
    !		Bad (wrong) word.
    digit	A region in which the word is valid.  If no regions are
    		specified the word is valid in all regions.

Example:

	# This is an example word list		comment
	/encoding=latin1			encoding of the file
	/regions=uscagb				regions "us", "ca" and "gb"
	example					word for all regions
	blah/12					word for regions "us" and "ca"
	vim/!					bad word
	Campbell/?3				rare word in region 3 "gb"
	's mornings/=				keep-case word

Note that when "/=" is used the same word with all upper-case letters is not
accepted.  This is different from a word with mixed case that is automatically
marked as keep-case, those words may appear in all upper-case letters.


FORMAT WITH AFFIX COMPRESSION

There are two files: the basic word list and an affix file.  The affixes are
used to modify the basic words to get the full word list.  This significantly
reduces the number of words, especially for a language like Polish.  This is
called affix compression.

The basic word list and the affix file are combined and turned into a binary
spell file.  All the preprocessing has been done, thus this file loads fast.
The binary spell file format is described in the source code (src/spell.c).
But only developers need to know about it.

The preprocessing also allows us to take the Myspell language files and modify
them before the Vim word list is made.  The tools for this can be found in the
"src/spell" directory.

The format for the affix and word list files is based on what Myspell uses
(the spell checker of Mozilla and OpenOffice.org).  A description can be found
here:
	http://lingucomponent.openoffice.org/affix.readme ~
Note that affixes are case sensitive, this isn't obvious from the description.

Vim does not use the TRY item, it is ignored.  For making suggestions the
possible characters in the words are used.

Vim supports quite a few extras.  They are described below |spell-affix-vim|.
Attempts have been made to keep this compatible with other spell checkers, so
that the same files can be used.


WORD LIST FORMAT				*spell-dic-format*

A very short example, with line numbers:

	1	1234
	2	aan
	3	Als
	4	Etten-Leur
	5	et al.
	6	's-Gravenhage
	7	's-Gravenhaags
	8	bedel/P
	9	kado/1
	10	cadeau/2
	11	TCP,IP

The first line contains the number of words.  Vim ignores it, but you do get
an error message if it's not there.  *E760*

What follows is one word per line.  There should be no white space before or
after the word.  After the word there is an optional slash and flags.  Most of
these flags are letters that indicate the affixes that can be used with this
word.  These are specified with SFX and PFX lines in the .aff file.  See the
Myspell documentation.  Vim allows using other flag types with the FLAG item
in the affix file |spell-FLAG|.

When the word only has lower-case letters it will also match with the word
starting with an upper-case letter.

When the word includes an upper-case letter, this means the upper-case letter
is required at this position.  The same word with a lower-case letter at this
position will not match. When some of the other letters are upper-case it will
not match either.

The word with all upper-case characters will always be OK.

	word list	matches			does not match ~
	als		als Als ALS		ALs AlS aLs aLS
	Als		Als  ALS		als ALs AlS aLs aLS
	ALS		ALS			als Als ALs AlS aLs aLS
	AlS		AlS ALS			als Als ALs aLs aLS

The KEEPCASE affix ID can be used to specifically match a word with identical
case only, see below |spell-KEEPCASE|.

Note in line 5 to 7 that non-word characters are used.  You can include
any character in a word.  When checking the text a word still only matches
when it appears with a non-word character before and after it.  For Myspell a
word starting with a non-word character probably won't work.

In line 12 the word "TCP/IP" is defined.  Since the slash has a special
meaning the comma is used instead.  This is defined with the SLASH item in the
affix file, see |spell-SLASH|.  Note that without this SLASH item the
word will be "TCP,IP".

							*spell-affix-vim*
A flag that Vim adds and is not in Myspell is the flag defined with KEEPCASE
in the affix file.  This has the meaning that case matters.  This can be used
if the word does not have the first letter in upper case at the start of a
sentence.  Example (assuming that = was used for KEEPCASE):

    word list	    matches		    does not match ~
    's morgens/=    's morgens		    'S morgens 's Morgens 'S MORGENS
    's Morgens	    's Morgens 'S MORGENS   'S morgens 's morgens

The flag can also be used to avoid that the word matches when it is in all
upper-case letters.

							*spell-affix-mbyte*
The basic word list is normally in an 8-bit encoding, which is mentioned in
the affix file.  The affix file must always be in the same encoding as the
word list.  This is compatible with Myspell.  For Vim the encoding may also be
something else, any encoding that "iconv" supports.  The "SET" line must
specify the name of the encoding.  When using a multi-byte encoding it's
possible to use more different affixes (but Myspell doesn't support that, thus
you may not want to use it anyway).


CHARACTER TABLES
							*spell-affix-chars*
When using an 8-bit encoding the affix file should define what characters are
word characters (as specified with ENC).  This is because the system where
":mkspell" is used may not support a locale with this encoding and isalpha()
won't work.  For example when using "cp1250" on Unix.

						*E761* *E762* *spell-FOL*
						*spell-LOW* *spell-UPP*
Three lines in the affix file are needed.  Simplistic example:

	FOL  áëñ ~
	LOW  áëñ ~
	UPP  ÁËÑ ~

All three lines must have exactly the same number of characters.

The "FOL" line specifies the case-folded characters.  These are used to
compare words while ignoring case.  For most encodings this is identical to
the lower case line.

The "LOW" line specifies the characters in lower-case.  Mostly it's equal to
the "FOL" line.

The "UPP" line specifies the characters with upper-case.  That is, a character
is upper-case where it's different from the character at the same position in
"FOL".

An exception is made for the German sharp s ß.  The upper-case version is
"SS".  In the FOL/LOW/UPP lines it should be included, so that it's recognized
as a word character, but use the ß character in all three.

ASCII characters should be omitted, Vim always handles these in the same way.
When the encoding is UTF-8 no word characters need to be specified.

							*E763*
Vim allows you to use spell checking for several languages in the same file.
You can list them in the 'spelllang' option.  As a consequence all spell files
for the same encoding must use the same word characters, otherwise they can't
be combined without errors.  If you get a warning that the word tables differ
you may need to generate the .spl file again with |:mkspell|.  Check the FOL,
LOW and UPP lines in the used .aff file.

The XX.ascii.spl spell file generated with the "-ascii" argument will not
contain the table with characters, so that it can be combine with spell files
for any encoding.  The .add.spl files also do not contain the table.


MID-WORD CHARACTERS
							*spell-midword*
Some characters are only to be considered word characters if they are used in
between two ordinary word characters.  An example is the single quote: It is
often used to put text in quotes, thus it can't be recognized as a word
character, but when it appears in between word characters it must be part of
the word.  This is needed to detect a spelling error such as they'are.  That
should be they're, but since "they" and "are" are words themselves that would
go unnoticed.

These characters are defined with MIDWORD in the .aff file:

	MIDWORD	'- ~


FLAG TYPES						*spell-FLAG*

Flags are used to specify the affixes that can be used with a word and for
other properties of the word.  Normally single-character flags are used.  This
limits the number of possible flags, especially for 8-bit encodings.  The FLAG
item can be used if more affixes are to be used.  Possible values:

	FLAG long	use two-character flags
	FLAG num	use numbers, from 1 up to 65000
	FLAG caplong	use one-character flags without A-Z and two-character
			flags that start with A-Z

With "FLAG num" the numbers in a list of affixes need to be separated with a
comma: "234,2143,1435".  This method is inefficient, but useful if the file is
generated with a program.

When using "caplong" the two-character flags all start with a capital: "Aa",
"B1", "BB", etc.  This is useful to use one-character flags for the most
common items and two-character flags for uncommon items.

Note: When using utf-8 only characters up to 65000 may be used for flags.


AFFIXES
					    *spell-PFX* *spell-SFX*
The usual PFX (prefix) and SFX (suffix) lines are supported (see the Myspell
documentation or the Aspell manual:
http://aspell.net/man-html/Affix-Compression.html).

Note that Myspell ignores any extra text after the relevant info.  Vim
requires this text to start with a "#" so that mistakes don't go unnoticed.
Example:

	SFX F 0 in   [^i]n      # Spion > Spionin  ~
	SFX F 0 nen  in         # Bauerin > Bauerinnen ~

Apparently Myspell allows an affix name to appear more than once.  Since this
might also be a mistake, Vim checks for an extra "S".  The affix files for
Myspell that use this feature apparently have this flag.  Example:

	SFX a Y 1 S ~
	SFX a 0 an . ~

	SFX a Y 2 S ~
	SFX a 0 en . ~
	SFX a 0 on . ~

							*spell-affix-rare*
An extra item for Vim is the "rare" flag.  It must come after the other
fields, before a comment.  When used then all words that use the affix will be
marked as rare words.  Example:

	PFX F 0 nene  .   rare ~
	SFX F 0 oin   n   rare   # hardly ever used ~

However, if the word also appears as a good word in another way it won't be
marked as rare.

							*spell-affix-nocomp*
Another extra item for Vim is the "nocomp" flag.  It must come after the other
fields, before a comment.  It can be either before or after "rare".  When
present then all words that use the affix will not be part of a compound word.
Example:
	affix file:
		COMPOUNDFLAG c ~
		SFX a Y 2 ~
		SFX a 0 s   . ~
		SFX a 0 ize . nocomp ~
	dictionary:
		word/c ~
		util/ac ~

This allows for "wordutil" and "wordutils" but not "wordutilize".

						    *spell-PFXPOSTPONE*
When an affix file has very many prefixes that apply to many words it's not
possible to build the whole word list in memory.  This applies to Hebrew (a
list with all words is over a Gbyte).  In that case applying prefixes must be
postponed.  This makes spell checking slower.  It is indicated by this keyword
in the .aff file:

	PFXPOSTPONE ~

Only prefixes without a chop string can be postponed, prefixes with a chop
string will still be included in the word list.  An exception if the chop
string is one character and equal to the last character of the added string,
but in lower case.  Thus when the chop string is used to allow the following
word to start with an upper case letter.


WORDS WITH A SLASH					*spell-SLASH*

The slash is used in the .dic file to separate the basic word from the affix
letters that can be used.  Unfortunately, this means you cannot use a slash in
a word.  Thus "TCP/IP" cannot be a word.  To work around that you can define a
replacement character for the slash.  Example:

	SLASH , ~

Now you can use "TCP,IP" to add the word "TCP/IP".

Of course, the letter used should itself not appear in any word!  The letter
must be ASCII, thus a single byte.


KEEP-CASE WORDS						*spell-KEEPCASE*

In the affix file a KEEPCASE line can be used to define the affix name used
for keep-case words.  Example:

	KEEPCASE = ~

See above for an example |spell-affix-vim|.


RARE WORDS						*spell-RARE*

In the affix file a RARE line can be used to define the affix name used for
rare words.  Example:

	RARE ? ~

Rare words are highlighted differently from bad words.  This is to be used for
words that are correct for the language, but are hardly ever used and could be
a typing mistake anyway.  When the same word is found as good it won't be
highlighted as rare.


BAD WORDS						*spell-BAD*

In the affix file a BAD line can be used to define the affix name used for
bad words.  Example:

	BAD ! ~

This can be used to exclude words that would otherwise be good.  For example
"the the" in the .dic file:

	the the/! ~

Once a word has been marked as bad it won't be undone by encountering the same
word as good.

							*spell-NEEDAFFIX*
The NEEDAFFIX flag is used to require that a word is used with an affix.  The
word itself is not a good word.  Example:

	NEEDAFFIX + ~

							*spell-NEEDCOMPOUND*
The NEEDCOMPOUND flag is used to require that a word is used as part of a
compound word The word itself is not a good word.  Example:

	NEEDCOMPOUND & ~


COMPOUND WORDS						*spell-compound*

A compound word is a longer word made by concatenating words that appear in
the .dic file.  To specify which words may be concatenated a character is
used.  This character is put in the list of affixes after the word.  We will
call this character a flag here.  Obviously these flags must be different from
any affix IDs used.

							*spell-COMPOUNDFLAG*
The Myspell compatible method uses one flag, specified with COMPOUNDFLAG.
All words with this flag combine in any order.  This means there is no control
over which word comes first.  Example:
	COMPOUNDFLAG c ~

							*spell-COMPOUNDFLAGS*
A more advanced method to specify how compound words can be formed uses
multiple items with multiple flags.  This is not compatible with Myspell 3.0.
Let's start with an example:
	COMPOUNDFLAGS c+ ~
	COMPOUNDFLAGS se ~

The first line defines that words with the "c" flag can be concatenated in any
order.  The second line defines compound words that are made of one word with
the "s" flag and one word with the "e" flag.  With this dictionary:
	bork/c ~
	onion/s ~
	soup/e ~

You can make these words:
	bork
	borkbork
	borkborkbork
	(etc.)
	onion
	soup
	onionsoup

The COMPOUNDFLAGS item may appear multiple times.  The argument is made out of
one or more groups, where each group can be:
	one flag			e.g., c
	alternate flags inside []	e.g., [abc]
Optionally this may be followed by:
	*	the group appears zero or more times, e.g., sm*e
	+	the group appears one or more times, e.g., c+

This is similar to the regexp pattern syntax (but not the same!).  A few
examples with the sequence of word flags they require:
    COMPOUNDFLAGS x+	    x xx xxx etc.
    COMPOUNDFLAGS yz	    yz
    COMPOUNDFLAGS x+z	    xz xxz xxxz etc.
    COMPOUNDFLAGS yx+	    yx yxx yxxx etc.

    COMPOUNDFLAGS [abc]z    az bz cz
    COMPOUNDFLAGS [abc]+z   az aaz abaz bz baz bcbz cz caz cbaz etc.
    COMPOUNDFLAGS a[xyz]+   ax axx axyz ay ayx ayzz az azy azxy etc.
    COMPOUNDFLAGS sm*e	    se sme smme smmme etc.
    COMPOUNDFLAGS s[xyz]*e  se sxe sxye sxyxe sye syze sze szye szyxe  etc.

A specific example: Allow a compound to be made of two words and a dash:
	In the .aff file:
	    COMPOUNDFLAGS sde ~
	    NEEDAFFIX x ~
	    COMPOUNDMAX 3 ~
	    COMPOUNDMIN 1 ~
	In the .dic file:
	    start/s ~
	    end/e ~
	    -/xd ~

This allows for the word "start-end", but not "startend".

							*spell-COMPOUNDMIN*
The minimal character length of a word used for compounding is specified with
COMPOUNDMIN.  Example:
	COMPOUNDMIN 5 ~

When omitted there is no minimal length.  Obviously you could just leave out
the compound flag from short words instead, this feature is present for
compatibility with Myspell.

							*spell-COMPOUNDMAX*
The maximum number of words that can be concatenated into a compound word is
specified with COMPOUNDMAX.  Example:
	COMPOUNDMAX 3 ~

When omitted there is no maximum.  It applies to all compound words.

To set a limit for words with specific flags make sure the items in
COMPOUNDFLAGS where they appear don't allow too many words.

							*spell-COMPOUNDSYLMAX*
The maximum number of syllables that a compound word may contain is specified
with COMPOUNDSYLMAX.  Example:
	COMPOUNDSYLMAX 6 ~

This has no effect if there is no SYLLABLE item.  Without COMPOUNDSYLMAX there
is no limit on the number of syllables.

If both COMPOUNDMAX and COMPOUNDSYLMAX are defined, a compound word is
accepted if it fits one of the criteria, thus is either made from up to
COMPOUNDMAX words or contains up to COMPOUNDSYLMAX syllables.

							*spell-SYLLABLE*
The SYLLABLE item defines characters or character sequences that are used to
count the number of syllables in a word.  Example:
	SYLLABLE aáeéiíoóöõuúüûy/aa/au/ea/ee/ei/ie/oa/oe/oo/ou/uu/ui ~

Before the first slash is the set of characters that are counted for one
syllable, also when repeated and mixed, until the next character that is not
in this set.  After the slash come sequences of characters that are counted
for one syllable.  These are preferred over using characters from the set.
With the example "ideeen" has three syllables, counted by "i", "ee" and "e".

Only case-folded letters need to be included.

Above another way to restrict compounding was mentioned above: adding "nocomp"
after an affix causes all words that are made with that affix not be be used
for compounding. |spell-affix-nocomp|


UNLIMITED COMPOUNDING					*spell-NOBREAK*

For some languages, such as Thai, there is no space in between words.  This
looks like all words are compounded.  To specify this use the NOBREAK item in
the affix file, without arguments:
	NOBREAK ~

Vim will try to figure out where one word ends and a next starts.  When there
are spelling mistakes this may not be quite right.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
NOTE: The following has not been implemented yet, because there are no word
lists that support this.
> 							*spell-CMP*
> Sometimes it is necessary to change a word when concatenating it to another,
> by removing a few letters, inserting something or both.  It can also be useful
> to restrict concatenation to words that match a pattern.  For this purpose CMP
> items can be used.  They look like this:
> 	CMP {flag} {flags} {strip} {strip2} {add} {cond} {cond2}
> 
> 	{flag}		the flag, as used in COMPOUNDFLAGS for the lead word
> 	{flags}		accepted flags for the following word ('.' to accept
> 			all)
> 	{strip}		text to remove from the end of the lead word (zero
> 			for no stripping)
> 	{strip2}	text to remove from the start of the following word
> 			(zero for no stripping)
> 	{add}		text to insert between the words (zero for no
> 			addition)
> 	{cond}		condition to match at the end of the lead word
> 	{cond2}		condition to match at the start of the following word
> 
> This is the same as what is used for SFX and PFX items, with the extra {flags}
> and {cond2} fields.  Example:
> 	CMP f mrt 0 - . . ~
> 
> When used with the food and dish word list above, this means that a dash is
> inserted after each food item.  Thus you get "onion-soup" and
> "onion-tomato-salat".
> 
> When there are CMP items for a compound flag the concatenation is only done
> when a CMP item matches.
> 
> When there are no CMP items for a compound flag, then all words will be
> concatenated, as if there was an item:
> 	CMP {flag} . 0 0 . .
>
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


REPLACEMENTS						*spell-REP*

In the affix file REP items can be used to define common mistakes.  This is
used to make spelling suggestions.  The items define the "from" text and the
"to" replacement.  Example:

	REP 4 ~
	REP f ph ~
	REP ph f ~
	REP k ch ~
	REP ch k ~

The first line specifies the number of REP lines following.  Vim ignores the
number, but it must be there.

Don't include simple one-character replacements or swaps.  Vim will try these
anyway.  You can include whole words if you want to, but you might want to use
the "file:" item in 'spellsuggest' instead.

You can include a space by using an underscore:

	REP the_the the ~


SIMILAR CHARACTERS					*spell-MAP*

In the affix file MAP items can be used to define letters that are very much
alike.  This is mostly used for a letter with different accents.  This is used
to prefer suggestions with these letters substituted.  Example:

	MAP 2 ~
	MAP eéëêè ~
	MAP uüùúû ~

The first line specifies the number of MAP lines following.  Vim ignores the
number, but the line must be there.

Each letter must appear in only one of the MAP items.  It's a bit more
efficient if the first letter is ASCII or at least one without accents.


SOUND-A-LIKE						*spell-SAL*

In the affix file SAL items can be used to define the sounds-a-like mechanism
to be used.  The main items define the "from" text and the "to" replacement.
Simplistic example:

	SAL CIA                  X ~
	SAL CH                   X ~
	SAL C                    K ~
	SAL K                    K ~

There are a few rules and this can become quite complicated.  An explanation
how it works can be found in the Aspell manual:
http://aspell.net/man-html/Phonetic-Code.html.

There are a few special items:

	SAL followup		true ~
	SAL collapse_result	true ~
	SAL remove_accents	true ~

"1" has the same meaning as "true".  Any other value means "false".


SIMPLE SOUNDFOLDING				*spell-SOFOFROM* *spell-SOFOTO*

The SAL mechanism is complex and slow.  A simpler mechanism is mapping all
characters to another character, mapping similar sounding characters to the
same character.  At the same time this does case folding.  You can not have
both SAL items and simple soundfolding.

There are two items required: one to specify the characters that are mapped
and one that specifies the characters they are mapped to.  They must have
exactly the same number of characters.  Example:

    SOFOFROM abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ~
    SOFOTO   ebctefghejklnnepkrstevvkesebctefghejklnnepkrstevvkes ~

In the example all vowels are mapped to the same character 'e'.  Another
method would be to leave out all vowels.  Some characters that sound nearly
the same and are often mixed up, such as 'm' and 'n', are mapped to the same
character.  Don't do this too much, all words will start looking alike.

Characters that do not appear in SOFOFROM will be left out, except that all
white space is replaced by one space.  Sequences of the same character in
SOFOFROM are replaced by one.

You can use the |soundfold()| function to try out the results.  Or set the
'verbose' option to see the score in the output of the |z=| command.


 vim:tw=78:sw=4:ts=8:ft=help:norl:
