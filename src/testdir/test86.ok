start:
[1, 'as''d', [1, 2, function('strlen'), {'a': 1}]]
[1, 2, function('strlen'), {'a': 1}]
Vim(put):E684:
[0, 'as''d', [1, 2, function('strlen'), {'a': 1}]]
[0, function('strlen'), [1, 2, function('strlen'), {'a': 1}]]
1
['-1', '0', '1', 'b', 'f']
['asd', -1L, <vim.Function '1'>, <vim.dictionary object at >, <vim.list object at >]
[('-1', <vim.dictionary object at >), ('0', -1L), ('1', 'asd'), ('b', <vim.list object at >), ('f', <vim.Function '1'>)]
'-1' : {'a': 1}
'0' : -1
'1' : 'asd'
'b' : [1, 2, function('strlen')]
'f' : function('1')
[0, function('strlen')]
[3]
[1, 2, function('strlen')]
[1, 2, function('strlen')]
1
'asd'
2
True
False
True
False
['0']
{'0': -1}
('0', -1L)
None
[]
[0, 1, 2, 3]
[0, 1, 2, 3]
[0, 1, 3]
[0, 1]
[0, 1]
[0, 1]
[0, 1, 2, 3]
[0, 1, 2, 3]
[0, 2, 3]
[2, 3]
[2, 3]
[2, 3]
[1, 3]
[0, 2]
[0, 1, 2, 3]
['a', 0, 1, 2, 3]
[0, 'b', 2, 3]
[0, 1, 'c']
[0, 1, 2, 3, 'd']
[0, 1, 2, 'e', 3]
['f', 2, 3]
[0, 1, 'g', 2, 3]
['h']
[0, 1, 10, 3, 20, 5, 6, 7]
[0, 1, 2, 3, 20, 5, 10, 7]
[0, 1, 2, 3, 4, 5, 6, 7]
[0, 1, 2, 3, 4, 5, 6, 7]
[0, 1, 2, 3, 4, 5, 6, 7]
l[2] threw vim.error: error:('list is locked',)
[0, 1, 2, 3]
[function('New'), function('DictNew'), 'NewStart', 1, 2, 3, 'NewEnd']
[function('New'), function('DictNew'), 'NewStart', 1, 2, 3, 'NewEnd', 'DictNewStart', 1, 2, 3, 'DictNewEnd', {'a': 'b'}]
[function('New'), function('DictNew'), 'NewStart', 1, 2, 3, 'NewEnd', 'DictNewStart', 1, 2, 3, 'DictNewEnd', {'a': 'b'}, 'New']
l[1](1, 2, 3):error:('Vim:E725: Calling dict function without Dictionary: DictNew',)
f(1, 2, 3):error:('Vim:E117: Unknown function: New',)
[0.0, 0.0]
KeyError
TypeError
TypeError
ValueError
TypeError
TypeError
KeyError
KeyError
d : locked:0;scope:0
dl : locked:1;scope:0
v: : locked:2;scope:1
g: : locked:0;scope:2
d:{'abc2': 1}
dl:{'def': 1}
l : locked:0
ll : locked:1
l:[0]
ll:[1]
[0, 1, 2]
['a', 'b']
['c', 1]
['d', ['e']]
pyeval("None") = v:none
0.0
"\0":	Vim(let):E859:
{"\0": 1}:	Vim(let):E859:
undefined_name:	Vim(let):Trace
vim:	Vim(let):E859:
[1]
[1, 10, 11, 10, 11, 10, 11, 10, 11, 10, 11, 10, 1]
[0, 1, 2, 3]
[2, 3, 4, 5]
[0, 1]
[4, 5]
[2, 3]
[]
[2, 3]
[]
[0, 1, 2, 3, 4, 5]
[0, 1, 2, 3, 4, 5]
[0, 1, 2, 3, 4, 5]
[4, 3]
[0, 2, 4]
[]
Abc
bac
def
bar
jkl
wopts iters equal: 1
bopts iters equal: 1
>>> paste
  g/w/b:1/0/0
  g/w/b (in):1/0/0
  p/gopts1: False
  p/wopts1! KeyError
  inv: 2! KeyError
  wopts1! KeyError
  wopts2! KeyError
  wopts3! KeyError
  p/bopts1! KeyError
  inv: 2! KeyError
  bopts1! KeyError
  bopts2! KeyError
  bopts3! KeyError
  G: 1
  W: 1:1 2:1 3:1 4:1
  B: 1:1 2:1 3:1 4:1
  del wopts3! KeyError
  del bopts3! KeyError
  G: 1
  W: 1:1 2:1 3:1 4:1
  B: 1:1 2:1 3:1 4:1
>>> previewheight
  g/w/b:1/0/0
  g/w/b (in):1/0/0
  p/gopts1: 12
  inv: 'a'! TypeError
  p/wopts1! KeyError
  inv: 'a'! KeyError
  wopts1! KeyError
  wopts2! KeyError
  wopts3! KeyError
  p/bopts1! KeyError
  inv: 'a'! KeyError
  bopts1! KeyError
  bopts2! KeyError
  bopts3! KeyError
  G: 5
  W: 1:5 2:5 3:5 4:5
  B: 1:5 2:5 3:5 4:5
  del wopts3! KeyError
  del bopts3! KeyError
  G: 5
  W: 1:5 2:5 3:5 4:5
  B: 1:5 2:5 3:5 4:5
>>> operatorfunc
  g/w/b:1/0/0
  g/w/b (in):1/0/0
  p/gopts1: ''
  inv: 2! TypeError
  p/wopts1! KeyError
  inv: 2! KeyError
  wopts1! KeyError
  wopts2! KeyError
  wopts3! KeyError
  p/bopts1! KeyError
  inv: 2! KeyError
  bopts1! KeyError
  bopts2! KeyError
  bopts3! KeyError
  G: 'A'
  W: 1:'A' 2:'A' 3:'A' 4:'A'
  B: 1:'A' 2:'A' 3:'A' 4:'A'
  del wopts3! KeyError
  del bopts3! KeyError
  G: 'A'
  W: 1:'A' 2:'A' 3:'A' 4:'A'
  B: 1:'A' 2:'A' 3:'A' 4:'A'
>>> number
  g/w/b:0/1/0
  g/w/b (in):0/1/0
  p/gopts1! KeyError
  inv: 0! KeyError
  gopts1! KeyError
  p/wopts1: False
  p/bopts1! KeyError
  inv: 0! KeyError
  bopts1! KeyError
  bopts2! KeyError
  bopts3! KeyError
  G: 0
  W: 1:1 2:1 3:0 4:0
  B: 1:1 2:1 3:0 4:0
  del wopts3! ValueError
  del bopts3! KeyError
  G: 0
  W: 1:1 2:1 3:0 4:0
  B: 1:1 2:1 3:0 4:0
>>> numberwidth
  g/w/b:0/1/0
  g/w/b (in):0/1/0
  p/gopts1! KeyError
  inv: -100! KeyError
  gopts1! KeyError
  p/wopts1: 8
  inv: -100! error
  p/bopts1! KeyError
  inv: -100! KeyError
  bopts1! KeyError
  bopts2! KeyError
  bopts3! KeyError
  G: 8
  W: 1:3 2:5 3:2 4:8
  B: 1:3 2:5 3:2 4:8
  del wopts3! ValueError
  del bopts3! KeyError
  G: 8
  W: 1:3 2:5 3:2 4:8
  B: 1:3 2:5 3:2 4:8
>>> colorcolumn
  g/w/b:0/1/0
  g/w/b (in):0/1/0
  p/gopts1! KeyError
  inv: 'abc4'! KeyError
  gopts1! KeyError
  p/wopts1: ''
  inv: 'abc4'! error
  p/bopts1! KeyError
  inv: 'abc4'! KeyError
  bopts1! KeyError
  bopts2! KeyError
  bopts3! KeyError
  G: ''
  W: 1:'+2' 2:'+3' 3:'+1' 4:''
  B: 1:'+2' 2:'+3' 3:'+1' 4:''
  del wopts3! ValueError
  del bopts3! KeyError
  G: ''
  W: 1:'+2' 2:'+3' 3:'+1' 4:''
  B: 1:'+2' 2:'+3' 3:'+1' 4:''
>>> statusline
  g/w/b:1/1/0
  g/w/b (in):1/1/0
  p/gopts1: ''
  inv: 0! TypeError
  p/wopts1: None
  inv: 0! TypeError
  p/bopts1! KeyError
  inv: 0! KeyError
  bopts1! KeyError
  bopts2! KeyError
  bopts3! KeyError
  G: '1'
  W: 1:'2' 2:'4' 3:'1' 4:'1'
  B: 1:'2' 2:'4' 3:'1' 4:'1'
  del bopts3! KeyError
  G: '1'
  W: 1:'2' 2:'1' 3:'1' 4:'1'
  B: 1:'2' 2:'1' 3:'1' 4:'1'
>>> autoindent
  g/w/b:0/0/1
  g/w/b (in):0/0/1
  p/gopts1! KeyError
  inv: 2! KeyError
  gopts1! KeyError
  p/wopts1! KeyError
  inv: 2! KeyError
  wopts1! KeyError
  wopts2! KeyError
  wopts3! KeyError
  p/bopts1: False
  G: 0
  W: 1:0 2:1 3:0 4:1
  B: 1:0 2:1 3:0 4:1
  del wopts3! KeyError
  del bopts3! ValueError
  G: 0
  W: 1:0 2:1 3:0 4:1
  B: 1:0 2:1 3:0 4:1
>>> shiftwidth
  g/w/b:0/0/1
  g/w/b (in):0/0/1
  p/gopts1! KeyError
  inv: 3! KeyError
  gopts1! KeyError
  p/wopts1! KeyError
  inv: 3! KeyError
  wopts1! KeyError
  wopts2! KeyError
  wopts3! KeyError
  p/bopts1: 8
  G: 8
  W: 1:0 2:2 3:8 4:1
  B: 1:0 2:2 3:8 4:1
  del wopts3! KeyError
  del bopts3! ValueError
  G: 8
  W: 1:0 2:2 3:8 4:1
  B: 1:0 2:2 3:8 4:1
>>> omnifunc
  g/w/b:0/0/1
  g/w/b (in):0/0/1
  p/gopts1! KeyError
  inv: 1! KeyError
  gopts1! KeyError
  p/wopts1! KeyError
  inv: 1! KeyError
  wopts1! KeyError
  wopts2! KeyError
  wopts3! KeyError
  p/bopts1: ''
  inv: 1! TypeError
  G: ''
  W: 1:'A' 2:'B' 3:'' 4:'C'
  B: 1:'A' 2:'B' 3:'' 4:'C'
  del wopts3! KeyError
  del bopts3! ValueError
  G: ''
  W: 1:'A' 2:'B' 3:'' 4:'C'
  B: 1:'A' 2:'B' 3:'' 4:'C'
>>> preserveindent
  g/w/b:0/0/1
  g/w/b (in):0/0/1
  p/gopts1! KeyError
  inv: 2! KeyError
  gopts1! KeyError
  p/wopts1! KeyError
  inv: 2! KeyError
  wopts1! KeyError
  wopts2! KeyError
  wopts3! KeyError
  p/bopts1: False
  G: 0
  W: 1:0 2:1 3:0 4:1
  B: 1:0 2:1 3:0 4:1
  del wopts3! KeyError
  del bopts3! ValueError
  G: 0
  W: 1:0 2:1 3:0 4:1
  B: 1:0 2:1 3:0 4:1
>>> path
  g/w/b:1/0/1
  g/w/b (in):1/0/1
  p/gopts1: '.,..,,'
  inv: 0! TypeError
  p/wopts1! KeyError
  inv: 0! KeyError
  wopts1! KeyError
  wopts2! KeyError
  wopts3! KeyError
  p/bopts1: None
  inv: 0! TypeError
  G: '.,,'
  W: 1:'.,,' 2:',,' 3:'.,,' 4:'.'
  B: 1:'.,,' 2:',,' 3:'.,,' 4:'.'
  del wopts3! KeyError
  G: '.,,'
  W: 1:'.,,' 2:',,' 3:'.,,' 4:'.,,'
  B: 1:'.,,' 2:',,' 3:'.,,' 4:'.,,'
First line
First line
def
First line
Second line
Third line
(7, 2)
<buffer test86.in><buffer >
baz
bar
Second line
Third line
foo
1:BufFilePre:1
1:BufFilePost:1
testdir/foo
5:BufFilePre:5
5:BufFilePost:5
testdir/bar
1:BufFilePre:1
1:BufFilePost:1
testdir/test86.in
valid: b:False, cb:True
i:<buffer test86.in>
i2:<buffer test86.in>
i:<buffer a>
i3:<buffer test86.in>
1:<buffer test86.in>=<buffer test86.in>
8:<buffer a>=<buffer a>
9:<buffer b>=<buffer b>
10:<buffer c>=<buffer c>
4
i4:<buffer test86.in>
i4:<buffer test86.in>
StopIteration
Number of tabs: 4
Current tab pages:
  <tabpage 0>(1): 1 windows, current is <window object (unknown)>
  Windows:
    <window object (unknown)>(1): displays buffer <buffer test86.in>; cursor is at (37, 0)
  <tabpage 1>(2): 1 windows, current is <window object (unknown)>
  Windows:
    <window object (unknown)>(1): displays buffer <buffer 0>; cursor is at (1, 0)
  <tabpage 2>(3): 2 windows, current is <window object (unknown)>
  Windows:
    <window object (unknown)>(1): displays buffer <buffer a.1>; cursor is at (1, 0)
    <window object (unknown)>(2): displays buffer <buffer 1>; cursor is at (1, 0)
  <tabpage 3>(4): 4 windows, current is <window 0>
  Windows:
    <window 0>(1): displays buffer <buffer c.2>; cursor is at (1, 0)
    <window 1>(2): displays buffer <buffer b.2>; cursor is at (1, 0)
    <window 2>(3): displays buffer <buffer a.2>; cursor is at (1, 0)
    <window 3>(4): displays buffer <buffer 2>; cursor is at (1, 0)
Number of windows in current tab page: 4
Current tab page: <tabpage 3>
Current window: <window 0>: <window 0> is <window 0>
Current buffer: <buffer c.2>: <buffer c.2> is <buffer c.2> is <buffer c.2>
ValueError at assigning foreign tab window
Type error at assigning None to vim.current.window
Type error at assigning None to vim.current.tabpage
Type error at assigning None to vim.current.buffer
Current tab page: <tabpage 2>
Current window: <window 0>
Current buffer: <buffer test86.in>
Current line: 'Type error at assigning None to vim.current.buffer'
w.valid: [True, False]
t.valid: [True, False, True, False]
vim.vars:Dictionary:True
vim.options:Options:True
vim.bindeval("{}"):Dictionary:True
vim.bindeval("[]"):List:True
vim.bindeval("function('tr')"):Function:True
vim.current.buffer:Buffer:True
vim.current.range:Range:True
vim.current.window:Window:True
vim.current.tabpage:TabPage:True
current:__dir__,__members__,buffer,line,range,tabpage,window
buffer:__dir__,__members__,append,mark,name,number,options,range,valid,vars
window:__dir__,__members__,buffer,col,cursor,height,number,options,row,tabpage,valid,vars,width
tabpage:__dir__,__members__,number,valid,vars,window,windows
range:__dir__,__members__,append,end,start
dictionary:__dir__,__members__,get,has_key,items,keys,locked,pop,popitem,scope,update,values
list:__dir__,__members__,extend,locked
function:__dir__,__members__,args,auto_rebind,self,softspace
output:__dir__,__members__,close,closed,flush,isatty,readable,seekable,softspace,writable,write,writelines
{}
{'a': 1}
{'a': 1}
[]
['a', 'b', 'c', '7']
function('tr')
function('tr', [123, 3, 4])
function('tr')
function('tr', {})
function('tr', [123, 3, 4], {})
auto_rebind
function('tr')
function('tr', [123, 3, 4])
function('tr')
function('tr', {})
function('tr', [123, 3, 4], {})
a: <vim.Function 'Args'>
pa1: <vim.Function 'Args', args=['abcArgsPA1']>
pa2: <vim.Function 'Args'>
pa3: <vim.Function 'Args', args=['abcArgsPA3'], self={'abcSelfPA3': 'abcSelfPA3Val'}>
pa4: <vim.Function 'Args', self={'abcSelfPA4': 'abcSelfPA4Val'}>
sa: <vim.Function 'SelfArgs'>
psa1: <vim.Function 'SelfArgs', args=['abcArgsPSA1']>
psa2: <vim.Function 'SelfArgs'>
psa3: <vim.Function 'SelfArgs', args=['abcArgsPSA3'], self={'abcSelfPSA3': 'abcSelfPSA3Val'}>
psa4: <vim.Function 'SelfArgs', self={'abcSelfPSA4': 'abcSelfPSA4Val'}>
psa5: <vim.Function 'SelfArgs', self={'abcSelfPSA5': 'abcSelfPSA5Val'}>
psa6: <vim.Function 'SelfArgs', args=['abcArgsPSA6'], self={'abcSelfPSA6': 'abcSelfPSA6Val'}>
psa7: <vim.Function 'SelfArgs', args=['abcArgsPSA7']>
psa8: <vim.Function 'SelfArgs'>
psa9: <vim.Function 'SelfArgs', self={'abcSelfPSA9': 'abcSelfPSA9Val'}, auto_rebind=True>
psaA: <vim.Function 'SelfArgs', args=['abcArgsPSAA'], self={'abcSelfPSAA': 'abcSelfPSAAVal'}, auto_rebind=True>
psaB: <vim.Function 'SelfArgs', args=['abcArgsPSAB']>
psaC: <vim.Function 'SelfArgs'>
psar: <vim.Function 'SelfArgs', args=[{'abcArgsPSAr2': [{'rec': function('SelfArgs', [{...}], {...}), 'self': {...}, 'abcSelfPSAr': 'abcSelfPSArVal', 'args': [{...}]}, {...}], 'abcArgsPSAr': 'abcArgsPSArVal'}], self={'rec': function('SelfArgs', [{'abcArgsPSAr2': [{...}, {...}], 'abcArgsPSAr': 'abcArgsPSArVal'}], {...}), 'self': {...}, 'abcSelfPSAr': 'abcSelfPSArVal', 'args': [{'abcArgsPSAr2': [{...}, {...}], 'abcArgsPSAr': 'abcArgsPSArVal'}]}>
s(a): function('Args')
s(pa1): function('Args', ['abcArgsPA1'])
s(pa2): function('Args')
s(pa3): function('Args', ['abcArgsPA3'], {'abcSelfPA3': 'abcSelfPA3Val'})
s(pa4): function('Args', {'abcSelfPA4': 'abcSelfPA4Val'})
s(sa): function('SelfArgs')
s(psa1): function('SelfArgs', ['abcArgsPSA1'])
s(psa2): function('SelfArgs')
s(psa3): function('SelfArgs', ['abcArgsPSA3'], {'abcSelfPSA3': 'abcSelfPSA3Val'})
s(psa4): function('SelfArgs', {'abcSelfPSA4': 'abcSelfPSA4Val'})
s(psa5): function('SelfArgs', {'abcSelfPSA5': 'abcSelfPSA5Val'})
s(psa6): function('SelfArgs', ['abcArgsPSA6'], {'abcSelfPSA6': 'abcSelfPSA6Val'})
s(psa7): function('SelfArgs', ['abcArgsPSA7'])
s(psa8): function('SelfArgs')
s(psa9): function('SelfArgs', {'abcSelfPSA9': 'abcSelfPSA9Val'})
s(psaA): function('SelfArgs', ['abcArgsPSAA'], {'abcSelfPSAA': 'abcSelfPSAAVal'})
s(psaB): function('SelfArgs', ['abcArgsPSAB'])
s(psaC): function('SelfArgs')
d.sa(): [[], {'f': function('SelfArgs')}]
d.psa1(): [['abcArgsPSA1'], {'f': function('SelfArgs', ['abcArgsPSA1'])}]
d.psa2(): [[], {'f': function('SelfArgs')}]
d.psa3(): [['abcArgsPSA3'], {'abcSelfPSA3': 'abcSelfPSA3Val'}]
d.psa4(): [[], {'abcSelfPSA4': 'abcSelfPSA4Val'}]
d.psa5(): [[], {'abcSelfPSA5': 'abcSelfPSA5Val'}]
d.psa6(): [['abcArgsPSA6'], {'abcSelfPSA6': 'abcSelfPSA6Val'}]
d.psa7(): [['abcArgsPSA7'], {'f': function('SelfArgs', ['abcArgsPSA7'])}]
d.psa8(): [[], {'f': function('SelfArgs')}]
d.psa9(): [[], {'f': function('SelfArgs', {'abcSelfPSA9': 'abcSelfPSA9Val'})}]
d.psaA(): [['abcArgsPSAA'], {'f': function('SelfArgs', ['abcArgsPSAA'], {'abcSelfPSAA': 'abcSelfPSAAVal'})}]
d.psaB(): [['abcArgsPSAB'], {'f': function('SelfArgs', ['abcArgsPSAB'])}]
d.psaC(): [[], {'f': function('SelfArgs')}]
a(): !result: []
pa1(): !result: ['abcArgsPA1']
pa2(): !result: []
pa3(): !result: ['abcArgsPA3']
pa4(): !result: []
sa(): !exception: error:('Vim:E725: Calling dict function without Dictionary: SelfArgs',)
psa1(): !exception: error:('Vim:E725: Calling dict function without Dictionary: SelfArgs',)
psa2(): !exception: error:('Vim:E725: Calling dict function without Dictionary: SelfArgs',)
psa3(): !result: [['abcArgsPSA3'], {'abcSelfPSA3': 'abcSelfPSA3Val'}]
psa4(): !result: [[], {'abcSelfPSA4': 'abcSelfPSA4Val'}]
a(42, 43): !result: [42, 43]
pa1(42, 43): !result: ['abcArgsPA1', 42, 43]
pa2(42, 43): !result: [42, 43]
pa3(42, 43): !result: ['abcArgsPA3', 42, 43]
pa4(42, 43): !result: [42, 43]
sa(42, 43): !exception: error:('Vim:E725: Calling dict function without Dictionary: SelfArgs',)
psa1(42, 43): !exception: error:('Vim:E725: Calling dict function without Dictionary: SelfArgs',)
psa2(42, 43): !exception: error:('Vim:E725: Calling dict function without Dictionary: SelfArgs',)
psa3(42, 43): !result: [['abcArgsPSA3', 42, 43], {'abcSelfPSA3': 'abcSelfPSA3Val'}]
psa4(42, 43): !result: [[42, 43], {'abcSelfPSA4': 'abcSelfPSA4Val'}]
a(42, self={"20": 1}): !result: [42]
pa1(42, self={"20": 1}): !result: ['abcArgsPA1', 42]
pa2(42, self={"20": 1}): !result: [42]
pa3(42, self={"20": 1}): !result: ['abcArgsPA3', 42]
pa4(42, self={"20": 1}): !result: [42]
sa(42, self={"20": 1}): !result: [[42], {'20': 1}]
psa1(42, self={"20": 1}): !result: [['abcArgsPSA1', 42], {'20': 1}]
psa2(42, self={"20": 1}): !result: [[42], {'20': 1}]
psa3(42, self={"20": 1}): !result: [['abcArgsPSA3', 42], {'20': 1}]
psa4(42, self={"20": 1}): !result: [[42], {'20': 1}]
a(self={"20": 1}): !result: []
pa1(self={"20": 1}): !result: ['abcArgsPA1']
pa2(self={"20": 1}): !result: []
pa3(self={"20": 1}): !result: ['abcArgsPA3']
pa4(self={"20": 1}): !result: []
sa(self={"20": 1}): !result: [[], {'20': 1}]
psa1(self={"20": 1}): !result: [['abcArgsPSA1'], {'20': 1}]
psa2(self={"20": 1}): !result: [[], {'20': 1}]
psa3(self={"20": 1}): !result: [['abcArgsPSA3'], {'20': 1}]
psa4(self={"20": 1}): !result: [[], {'20': 1}]
a.args: None
pa1.args: ['abcArgsPA1']
pa2.args: None
pa3.args: ['abcArgsPA3']
pa4.args: None
sa.args: None
psa1.args: ['abcArgsPSA1']
psa2.args: None
psa3.args: ['abcArgsPSA3']
psa4.args: None
a.self: None
pa1.self: None
pa2.self: None
pa3.self: {'abcSelfPA3': 'abcSelfPA3Val'}
pa4.self: {'abcSelfPA4': 'abcSelfPA4Val'}
sa.self: None
psa1.self: None
psa2.self: None
psa3.self: {'abcSelfPSA3': 'abcSelfPSA3Val'}
psa4.self: {'abcSelfPSA4': 'abcSelfPSA4Val'}
a.name: 'Args'
pa1.name: 'Args'
pa2.name: 'Args'
pa3.name: 'Args'
pa4.name: 'Args'
sa.name: 'SelfArgs'
psa1.name: 'SelfArgs'
psa2.name: 'SelfArgs'
psa3.name: 'SelfArgs'
psa4.name: 'SelfArgs'
a.auto_rebind: 1
pa1.auto_rebind: 1
pa2.auto_rebind: 1
pa3.auto_rebind: 0
pa4.auto_rebind: 0
sa.auto_rebind: 1
psa1.auto_rebind: 1
psa2.auto_rebind: 1
psa3.auto_rebind: 0
psa4.auto_rebind: 0
psa5.auto_rebind: 0
psa6.auto_rebind: 0
psa7.auto_rebind: 1
psa8.auto_rebind: 1
psa9.auto_rebind: 1
psaA.auto_rebind: 1
psaB.auto_rebind: 1
psaC.auto_rebind: 1
'
abcdef
Error detected while processing function RunTest[]..Test:
line :
abcdef
abcA
line :
abcB'
['a', 'dup_a']
['a', 'a']
['a', 'b', 'c', 'C']
[2, 2]
[2, 2]
1
1
function('Put')
testdir
test86.in
src
testdir/test86.in
testdir
test86.in
> Output
>> OutputSetattr
del sys.stdout.softspace:AttributeError:('cannot delete OutputObject attributes',)
>>> Testing NumberToLong using sys.stdout.softspace = %s
sys.stdout.softspace = []:TypeError:('expected int(), long() or something supporting coercing to long(), but got list',)
sys.stdout.softspace = None:TypeError:('expected int(), long() or something supporting coercing to long(), but got NoneType',)
sys.stdout.softspace = -1:ValueError:('number must be greater or equal to zero',)
<<< Finished
>>> Testing NumberToLong using sys.stderr.softspace = %s
sys.stderr.softspace = []:TypeError:('expected int(), long() or something supporting coercing to long(), but got list',)
sys.stderr.softspace = None:TypeError:('expected int(), long() or something supporting coercing to long(), but got NoneType',)
sys.stderr.softspace = -1:ValueError:('number must be greater or equal to zero',)
<<< Finished
assert sys.stdout.isatty()==False:NOT FAILED
assert sys.stdout.seekable()==False:NOT FAILED
sys.stdout.close():NOT FAILED
sys.stdout.flush():NOT FAILED
assert sys.stderr.isatty()==False:NOT FAILED
assert sys.stderr.seekable()==False:NOT FAILED
sys.stderr.close():NOT FAILED
sys.stderr.flush():NOT FAILED
sys.stdout.attr = None:AttributeError:('invalid attribute: attr',)
>> OutputWrite
assert sys.stdout.writable()==True:NOT FAILED
assert sys.stdout.readable()==False:NOT FAILED
assert sys.stderr.writable()==True:NOT FAILED
assert sys.stderr.readable()==False:NOT FAILED
assert sys.stdout.closed()==False:NOT FAILED
assert sys.stderr.closed()==False:NOT FAILED
assert sys.stdout.errors=="strict":NOT FAILED
assert sys.stderr.errors=="strict":NOT FAILED
assert sys.stdout.encoding==sys.stderr.encoding:NOT FAILED
sys.stdout.write(None):TypeError:('coercing to Unicode: need string or buffer, NoneType found',)
>> OutputWriteLines
sys.stdout.writelines(None):TypeError:("'NoneType' object is not iterable",)
sys.stdout.writelines([1]):TypeError:('coercing to Unicode: need string or buffer, int found',)
>>> Testing *Iter* using sys.stdout.writelines(%s)
sys.stdout.writelines(FailingIter()):NotImplementedError:('iter',)
sys.stdout.writelines(FailingIterNext()):NotImplementedError:('next',)
<<< Finished
> VimCommand
>>> Testing StringToChars using vim.command(%s)
vim.command(1):TypeError:('expected str() or unicode() instance, but got int',)
vim.command(u"\0"):TypeError:('expected string without null bytes',)
vim.command("\0"):TypeError:('expected string without null bytes',)
<<< Finished
vim.command("", 2):TypeError:('command() takes exactly one argument (2 given)',)
> VimToPython
> VimEval
>>> Testing StringToChars using vim.eval(%s)
vim.eval(1):TypeError:('expected str() or unicode() instance, but got int',)
vim.eval(u"\0"):TypeError:('expected string without null bytes',)
vim.eval("\0"):TypeError:('expected string without null bytes',)
<<< Finished
vim.eval("", FailingTrue()):TypeError:('function takes exactly 1 argument (2 given)',)
> VimEvalPy
>>> Testing StringToChars using vim.bindeval(%s)
vim.bindeval(1):TypeError:('expected str() or unicode() instance, but got int',)
vim.bindeval(u"\0"):TypeError:('expected string without null bytes',)
vim.bindeval("\0"):TypeError:('expected string without null bytes',)
<<< Finished
vim.eval("", 2):TypeError:('function takes exactly 1 argument (2 given)',)
> VimStrwidth
>>> Testing StringToChars using vim.strwidth(%s)
vim.strwidth(1):TypeError:('expected str() or unicode() instance, but got int',)
vim.strwidth(u"\0"):TypeError:('expected string without null bytes',)
vim.strwidth("\0"):TypeError:('expected string without null bytes',)
<<< Finished
> VimForeachRTP
vim.foreach_rtp(None):TypeError:("'NoneType' object is not callable",)
vim.foreach_rtp(NoArgsCall()):TypeError:('__call__() takes exactly 1 argument (2 given)',)
vim.foreach_rtp(FailingCall()):NotImplementedError:('call',)
vim.foreach_rtp(int, 2):TypeError:('foreach_rtp() takes exactly one argument (2 given)',)
> import
import xxx_no_such_module_xxx:ImportError:('No module named xxx_no_such_module_xxx',)
import failing_import:ImportError:()
import failing:NotImplementedError:()
> Options
>> OptionsItem
vim.options["abcQ"]:KeyError:('abcQ',)
vim.options[""]:ValueError:('empty keys are not allowed',)
>>> Testing StringToChars using vim.options[%s]
vim.options[1]:TypeError:('expected str() or unicode() instance, but got int',)
vim.options[u"\0"]:TypeError:('expected string without null bytes',)
vim.options["\0"]:TypeError:('expected string without null bytes',)
<<< Finished
>> OptionsContains
>>> Testing StringToChars using %s in vim.options
1 in vim.options:TypeError:('expected str() or unicode() instance, but got int',)
u"\0" in vim.options:TypeError:('expected string without null bytes',)
"\0" in vim.options:TypeError:('expected string without null bytes',)
<<< Finished
> Dictionary
>> DictionaryConstructor
vim.Dictionary("abcI"):ValueError:('expected sequence element of size 2, but got sequence of size 1',)
>> DictionarySetattr
del d.locked:AttributeError:('cannot delete vim.Dictionary attributes',)
d.locked = FailingTrue():NotImplementedError:('bool',)
vim.vvars.locked = False:TypeError:('cannot modify fixed dictionary',)
d.scope = True:AttributeError:('cannot set attribute scope',)
d.xxx = True:AttributeError:('cannot set attribute xxx',)
>> _DictionaryItem
d.get("a", 2, 3):TypeError:('function takes at most 2 arguments (3 given)',)
>>> Testing StringToChars using d.get(%s)
d.get(1):TypeError:('expected str() or unicode() instance, but got int',)
d.get(u"\0"):TypeError:('expected string without null bytes',)
d.get("\0"):TypeError:('expected string without null bytes',)
<<< Finished
d.pop("a"):KeyError:('a',)
dl.pop("a"):error:('dictionary is locked',)
>> DictionaryContains
"" in d:ValueError:('empty keys are not allowed',)
0 in d:TypeError:('expected str() or unicode() instance, but got int',)
>> DictionaryIterNext
for i in ned: ned["a"] = 1:RuntimeError:('hashtab changed during iteration',)
>> DictionaryAssItem
dl["b"] = 1:error:('dictionary is locked',)
>>> Testing StringToChars using d[%s] = 1
d[1] = 1:TypeError:('expected str() or unicode() instance, but got int',)
d[u"\0"] = 1:TypeError:('expected string without null bytes',)
d["\0"] = 1:TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing StringToChars using d["a"] = {%s : 1}
d["a"] = {1 : 1}:TypeError:('expected str() or unicode() instance, but got int',)
d["a"] = {u"\0" : 1}:TypeError:('expected string without null bytes',)
d["a"] = {"\0" : 1}:TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing StringToChars using d["a"] = {"abcF" : {%s : 1}}
d["a"] = {"abcF" : {1 : 1}}:TypeError:('expected str() or unicode() instance, but got int',)
d["a"] = {"abcF" : {u"\0" : 1}}:TypeError:('expected string without null bytes',)
d["a"] = {"abcF" : {"\0" : 1}}:TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing StringToChars using d["a"] = {"abcF" : Mapping({%s : 1})}
d["a"] = {"abcF" : Mapping({1 : 1})}:TypeError:('expected str() or unicode() instance, but got int',)
d["a"] = {"abcF" : Mapping({u"\0" : 1})}:TypeError:('expected string without null bytes',)
d["a"] = {"abcF" : Mapping({"\0" : 1})}:TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing *Iter* using d["a"] = {"abcF" : %s}
d["a"] = {"abcF" : FailingIter()}:TypeError:('unable to convert FailingIter to vim structure',)
d["a"] = {"abcF" : FailingIterNext()}:NotImplementedError:('next',)
<<< Finished
>>> Testing ConvertFromPyObject using d["a"] = {"abcF" : %s}
d["a"] = {"abcF" : None}:NOT FAILED
d["a"] = {"abcF" : {"": 1}}:ValueError:('empty keys are not allowed',)
d["a"] = {"abcF" : {u"": 1}}:ValueError:('empty keys are not allowed',)
d["a"] = {"abcF" : FailingMapping()}:NotImplementedError:('keys',)
d["a"] = {"abcF" : FailingMappingKey()}:NotImplementedError:('getitem:mappingkey',)
d["a"] = {"abcF" : FailingNumber()}:TypeError:('long() argument must be a string or a number',)
<<< Finished
>>> Testing StringToChars using d["a"] = Mapping({%s : 1})
d["a"] = Mapping({1 : 1}):TypeError:('expected str() or unicode() instance, but got int',)
d["a"] = Mapping({u"\0" : 1}):TypeError:('expected string without null bytes',)
d["a"] = Mapping({"\0" : 1}):TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing StringToChars using d["a"] = Mapping({"abcG" : {%s : 1}})
d["a"] = Mapping({"abcG" : {1 : 1}}):TypeError:('expected str() or unicode() instance, but got int',)
d["a"] = Mapping({"abcG" : {u"\0" : 1}}):TypeError:('expected string without null bytes',)
d["a"] = Mapping({"abcG" : {"\0" : 1}}):TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing StringToChars using d["a"] = Mapping({"abcG" : Mapping({%s : 1})})
d["a"] = Mapping({"abcG" : Mapping({1 : 1})}):TypeError:('expected str() or unicode() instance, but got int',)
d["a"] = Mapping({"abcG" : Mapping({u"\0" : 1})}):TypeError:('expected string without null bytes',)
d["a"] = Mapping({"abcG" : Mapping({"\0" : 1})}):TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing *Iter* using d["a"] = Mapping({"abcG" : %s})
d["a"] = Mapping({"abcG" : FailingIter()}):TypeError:('unable to convert FailingIter to vim structure',)
d["a"] = Mapping({"abcG" : FailingIterNext()}):NotImplementedError:('next',)
<<< Finished
>>> Testing ConvertFromPyObject using d["a"] = Mapping({"abcG" : %s})
d["a"] = Mapping({"abcG" : None}):NOT FAILED
d["a"] = Mapping({"abcG" : {"": 1}}):ValueError:('empty keys are not allowed',)
d["a"] = Mapping({"abcG" : {u"": 1}}):ValueError:('empty keys are not allowed',)
d["a"] = Mapping({"abcG" : FailingMapping()}):NotImplementedError:('keys',)
d["a"] = Mapping({"abcG" : FailingMappingKey()}):NotImplementedError:('getitem:mappingkey',)
d["a"] = Mapping({"abcG" : FailingNumber()}):TypeError:('long() argument must be a string or a number',)
<<< Finished
>>> Testing *Iter* using d["a"] = %s
d["a"] = FailingIter():TypeError:('unable to convert FailingIter to vim structure',)
d["a"] = FailingIterNext():NotImplementedError:('next',)
<<< Finished
>>> Testing ConvertFromPyObject using d["a"] = %s
d["a"] = None:NOT FAILED
d["a"] = {"": 1}:ValueError:('empty keys are not allowed',)
d["a"] = {u"": 1}:ValueError:('empty keys are not allowed',)
d["a"] = FailingMapping():NotImplementedError:('keys',)
d["a"] = FailingMappingKey():NotImplementedError:('getitem:mappingkey',)
d["a"] = FailingNumber():TypeError:('long() argument must be a string or a number',)
<<< Finished
>> DictionaryUpdate
>>> kwargs
>>> iter
d.update(FailingMapping()):NotImplementedError:('keys',)
d.update([FailingIterNext()]):NotImplementedError:('next',)
d.update([FailingIterNextN(1)]):NotImplementedError:('next N',)
>>> Testing *Iter* using d.update(%s)
d.update(FailingIter()):NotImplementedError:('iter',)
d.update(FailingIterNext()):NotImplementedError:('next',)
<<< Finished
>>> Testing StringToChars using d.update({%s : 1})
d.update({1 : 1}):TypeError:('expected str() or unicode() instance, but got int',)
d.update({u"\0" : 1}):TypeError:('expected string without null bytes',)
d.update({"\0" : 1}):TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing StringToChars using d.update({"abcF" : {%s : 1}})
d.update({"abcF" : {1 : 1}}):TypeError:('expected str() or unicode() instance, but got int',)
d.update({"abcF" : {u"\0" : 1}}):TypeError:('expected string without null bytes',)
d.update({"abcF" : {"\0" : 1}}):TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing StringToChars using d.update({"abcF" : Mapping({%s : 1})})
d.update({"abcF" : Mapping({1 : 1})}):TypeError:('expected str() or unicode() instance, but got int',)
d.update({"abcF" : Mapping({u"\0" : 1})}):TypeError:('expected string without null bytes',)
d.update({"abcF" : Mapping({"\0" : 1})}):TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing *Iter* using d.update({"abcF" : %s})
d.update({"abcF" : FailingIter()}):TypeError:('unable to convert FailingIter to vim structure',)
d.update({"abcF" : FailingIterNext()}):NotImplementedError:('next',)
<<< Finished
>>> Testing ConvertFromPyObject using d.update({"abcF" : %s})
d.update({"abcF" : None}):NOT FAILED
d.update({"abcF" : {"": 1}}):ValueError:('empty keys are not allowed',)
d.update({"abcF" : {u"": 1}}):ValueError:('empty keys are not allowed',)
d.update({"abcF" : FailingMapping()}):NotImplementedError:('keys',)
d.update({"abcF" : FailingMappingKey()}):NotImplementedError:('getitem:mappingkey',)
d.update({"abcF" : FailingNumber()}):TypeError:('long() argument must be a string or a number',)
<<< Finished
>>> Testing StringToChars using d.update(Mapping({%s : 1}))
d.update(Mapping({1 : 1})):TypeError:('expected str() or unicode() instance, but got int',)
d.update(Mapping({u"\0" : 1})):TypeError:('expected string without null bytes',)
d.update(Mapping({"\0" : 1})):TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing StringToChars using d.update(Mapping({"abcG" : {%s : 1}}))
d.update(Mapping({"abcG" : {1 : 1}})):TypeError:('expected str() or unicode() instance, but got int',)
d.update(Mapping({"abcG" : {u"\0" : 1}})):TypeError:('expected string without null bytes',)
d.update(Mapping({"abcG" : {"\0" : 1}})):TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing StringToChars using d.update(Mapping({"abcG" : Mapping({%s : 1})}))
d.update(Mapping({"abcG" : Mapping({1 : 1})})):TypeError:('expected str() or unicode() instance, but got int',)
d.update(Mapping({"abcG" : Mapping({u"\0" : 1})})):TypeError:('expected string without null bytes',)
d.update(Mapping({"abcG" : Mapping({"\0" : 1})})):TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing *Iter* using d.update(Mapping({"abcG" : %s}))
d.update(Mapping({"abcG" : FailingIter()})):TypeError:('unable to convert FailingIter to vim structure',)
d.update(Mapping({"abcG" : FailingIterNext()})):NotImplementedError:('next',)
<<< Finished
>>> Testing ConvertFromPyObject using d.update(Mapping({"abcG" : %s}))
d.update(Mapping({"abcG" : None})):NOT FAILED
d.update(Mapping({"abcG" : {"": 1}})):ValueError:('empty keys are not allowed',)
d.update(Mapping({"abcG" : {u"": 1}})):ValueError:('empty keys are not allowed',)
d.update(Mapping({"abcG" : FailingMapping()})):NotImplementedError:('keys',)
d.update(Mapping({"abcG" : FailingMappingKey()})):NotImplementedError:('getitem:mappingkey',)
d.update(Mapping({"abcG" : FailingNumber()})):TypeError:('long() argument must be a string or a number',)
<<< Finished
>>> Testing *Iter* using d.update(%s)
d.update(FailingIter()):NotImplementedError:('iter',)
d.update(FailingIterNext()):NotImplementedError:('next',)
<<< Finished
>>> Testing ConvertFromPyObject using d.update(%s)
d.update(None):TypeError:("'NoneType' object is not iterable",)
d.update({"": 1}):ValueError:('empty keys are not allowed',)
d.update({u"": 1}):ValueError:('empty keys are not allowed',)
d.update(FailingMapping()):NotImplementedError:('keys',)
d.update(FailingMappingKey()):NotImplementedError:('getitem:mappingkey',)
d.update(FailingNumber()):TypeError:("'FailingNumber' object is not iterable",)
<<< Finished
>>> Testing StringToChars using d.update(((%s, 0),))
d.update(((1, 0),)):TypeError:('expected str() or unicode() instance, but got int',)
d.update(((u"\0", 0),)):TypeError:('expected string without null bytes',)
d.update((("\0", 0),)):TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing StringToChars using d.update((("a", {%s : 1}),))
d.update((("a", {1 : 1}),)):TypeError:('expected str() or unicode() instance, but got int',)
d.update((("a", {u"\0" : 1}),)):TypeError:('expected string without null bytes',)
d.update((("a", {"\0" : 1}),)):TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing StringToChars using d.update((("a", {"abcF" : {%s : 1}}),))
d.update((("a", {"abcF" : {1 : 1}}),)):TypeError:('expected str() or unicode() instance, but got int',)
d.update((("a", {"abcF" : {u"\0" : 1}}),)):TypeError:('expected string without null bytes',)
d.update((("a", {"abcF" : {"\0" : 1}}),)):TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing StringToChars using d.update((("a", {"abcF" : Mapping({%s : 1})}),))
d.update((("a", {"abcF" : Mapping({1 : 1})}),)):TypeError:('expected str() or unicode() instance, but got int',)
d.update((("a", {"abcF" : Mapping({u"\0" : 1})}),)):TypeError:('expected string without null bytes',)
d.update((("a", {"abcF" : Mapping({"\0" : 1})}),)):TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing *Iter* using d.update((("a", {"abcF" : %s}),))
d.update((("a", {"abcF" : FailingIter()}),)):TypeError:('unable to convert FailingIter to vim structure',)
d.update((("a", {"abcF" : FailingIterNext()}),)):NotImplementedError:('next',)
<<< Finished
>>> Testing ConvertFromPyObject using d.update((("a", {"abcF" : %s}),))
d.update((("a", {"abcF" : None}),)):error:("failed to add key 'a' to dictionary",)
d.update((("a", {"abcF" : {"": 1}}),)):ValueError:('empty keys are not allowed',)
d.update((("a", {"abcF" : {u"": 1}}),)):ValueError:('empty keys are not allowed',)
d.update((("a", {"abcF" : FailingMapping()}),)):NotImplementedError:('keys',)
d.update((("a", {"abcF" : FailingMappingKey()}),)):NotImplementedError:('getitem:mappingkey',)
d.update((("a", {"abcF" : FailingNumber()}),)):TypeError:('long() argument must be a string or a number',)
<<< Finished
>>> Testing StringToChars using d.update((("a", Mapping({%s : 1})),))
d.update((("a", Mapping({1 : 1})),)):TypeError:('expected str() or unicode() instance, but got int',)
d.update((("a", Mapping({u"\0" : 1})),)):TypeError:('expected string without null bytes',)
d.update((("a", Mapping({"\0" : 1})),)):TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing StringToChars using d.update((("a", Mapping({"abcG" : {%s : 1}})),))
d.update((("a", Mapping({"abcG" : {1 : 1}})),)):TypeError:('expected str() or unicode() instance, but got int',)
d.update((("a", Mapping({"abcG" : {u"\0" : 1}})),)):TypeError:('expected string without null bytes',)
d.update((("a", Mapping({"abcG" : {"\0" : 1}})),)):TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing StringToChars using d.update((("a", Mapping({"abcG" : Mapping({%s : 1})})),))
d.update((("a", Mapping({"abcG" : Mapping({1 : 1})})),)):TypeError:('expected str() or unicode() instance, but got int',)
d.update((("a", Mapping({"abcG" : Mapping({u"\0" : 1})})),)):TypeError:('expected string without null bytes',)
d.update((("a", Mapping({"abcG" : Mapping({"\0" : 1})})),)):TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing *Iter* using d.update((("a", Mapping({"abcG" : %s})),))
d.update((("a", Mapping({"abcG" : FailingIter()})),)):TypeError:('unable to convert FailingIter to vim structure',)
d.update((("a", Mapping({"abcG" : FailingIterNext()})),)):NotImplementedError:('next',)
<<< Finished
>>> Testing ConvertFromPyObject using d.update((("a", Mapping({"abcG" : %s})),))
d.update((("a", Mapping({"abcG" : None})),)):error:("failed to add key 'a' to dictionary",)
d.update((("a", Mapping({"abcG" : {"": 1}})),)):ValueError:('empty keys are not allowed',)
d.update((("a", Mapping({"abcG" : {u"": 1}})),)):ValueError:('empty keys are not allowed',)
d.update((("a", Mapping({"abcG" : FailingMapping()})),)):NotImplementedError:('keys',)
d.update((("a", Mapping({"abcG" : FailingMappingKey()})),)):NotImplementedError:('getitem:mappingkey',)
d.update((("a", Mapping({"abcG" : FailingNumber()})),)):TypeError:('long() argument must be a string or a number',)
<<< Finished
>>> Testing *Iter* using d.update((("a", %s),))
d.update((("a", FailingIter()),)):TypeError:('unable to convert FailingIter to vim structure',)
d.update((("a", FailingIterNext()),)):NotImplementedError:('next',)
<<< Finished
>>> Testing ConvertFromPyObject using d.update((("a", %s),))
d.update((("a", None),)):error:("failed to add key 'a' to dictionary",)
d.update((("a", {"": 1}),)):ValueError:('empty keys are not allowed',)
d.update((("a", {u"": 1}),)):ValueError:('empty keys are not allowed',)
d.update((("a", FailingMapping()),)):NotImplementedError:('keys',)
d.update((("a", FailingMappingKey()),)):NotImplementedError:('getitem:mappingkey',)
d.update((("a", FailingNumber()),)):TypeError:('long() argument must be a string or a number',)
<<< Finished
>> DictionaryPopItem
d.popitem(1, 2):TypeError:('popitem() takes no arguments (2 given)',)
>> DictionaryHasKey
d.has_key():TypeError:('has_key() takes exactly one argument (0 given)',)
> List
>> ListConstructor
vim.List(1, 2):TypeError:('function takes at most 1 argument (2 given)',)
vim.List(a=1):TypeError:('list constructor does not accept keyword arguments',)
>>> Testing *Iter* using vim.List(%s)
vim.List(FailingIter()):NotImplementedError:('iter',)
vim.List(FailingIterNext()):NotImplementedError:('next',)
<<< Finished
>>> Testing StringToChars using vim.List([{%s : 1}])
vim.List([{1 : 1}]):TypeError:('expected str() or unicode() instance, but got int',)
vim.List([{u"\0" : 1}]):TypeError:('expected string without null bytes',)
vim.List([{"\0" : 1}]):TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing StringToChars using vim.List([{"abcF" : {%s : 1}}])
vim.List([{"abcF" : {1 : 1}}]):TypeError:('expected str() or unicode() instance, but got int',)
vim.List([{"abcF" : {u"\0" : 1}}]):TypeError:('expected string without null bytes',)
vim.List([{"abcF" : {"\0" : 1}}]):TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing StringToChars using vim.List([{"abcF" : Mapping({%s : 1})}])
vim.List([{"abcF" : Mapping({1 : 1})}]):TypeError:('expected str() or unicode() instance, but got int',)
vim.List([{"abcF" : Mapping({u"\0" : 1})}]):TypeError:('expected string without null bytes',)
vim.List([{"abcF" : Mapping({"\0" : 1})}]):TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing *Iter* using vim.List([{"abcF" : %s}])
vim.List([{"abcF" : FailingIter()}]):TypeError:('unable to convert FailingIter to vim structure',)
vim.List([{"abcF" : FailingIterNext()}]):NotImplementedError:('next',)
<<< Finished
>>> Testing ConvertFromPyObject using vim.List([{"abcF" : %s}])
vim.List([{"abcF" : None}]):NOT FAILED
vim.List([{"abcF" : {"": 1}}]):ValueError:('empty keys are not allowed',)
vim.List([{"abcF" : {u"": 1}}]):ValueError:('empty keys are not allowed',)
vim.List([{"abcF" : FailingMapping()}]):NotImplementedError:('keys',)
vim.List([{"abcF" : FailingMappingKey()}]):NotImplementedError:('getitem:mappingkey',)
vim.List([{"abcF" : FailingNumber()}]):TypeError:('long() argument must be a string or a number',)
<<< Finished
>>> Testing StringToChars using vim.List([Mapping({%s : 1})])
vim.List([Mapping({1 : 1})]):TypeError:('expected str() or unicode() instance, but got int',)
vim.List([Mapping({u"\0" : 1})]):TypeError:('expected string without null bytes',)
vim.List([Mapping({"\0" : 1})]):TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing StringToChars using vim.List([Mapping({"abcG" : {%s : 1}})])
vim.List([Mapping({"abcG" : {1 : 1}})]):TypeError:('expected str() or unicode() instance, but got int',)
vim.List([Mapping({"abcG" : {u"\0" : 1}})]):TypeError:('expected string without null bytes',)
vim.List([Mapping({"abcG" : {"\0" : 1}})]):TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing StringToChars using vim.List([Mapping({"abcG" : Mapping({%s : 1})})])
vim.List([Mapping({"abcG" : Mapping({1 : 1})})]):TypeError:('expected str() or unicode() instance, but got int',)
vim.List([Mapping({"abcG" : Mapping({u"\0" : 1})})]):TypeError:('expected string without null bytes',)
vim.List([Mapping({"abcG" : Mapping({"\0" : 1})})]):TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing *Iter* using vim.List([Mapping({"abcG" : %s})])
vim.List([Mapping({"abcG" : FailingIter()})]):TypeError:('unable to convert FailingIter to vim structure',)
vim.List([Mapping({"abcG" : FailingIterNext()})]):NotImplementedError:('next',)
<<< Finished
>>> Testing ConvertFromPyObject using vim.List([Mapping({"abcG" : %s})])
vim.List([Mapping({"abcG" : None})]):NOT FAILED
vim.List([Mapping({"abcG" : {"": 1}})]):ValueError:('empty keys are not allowed',)
vim.List([Mapping({"abcG" : {u"": 1}})]):ValueError:('empty keys are not allowed',)
vim.List([Mapping({"abcG" : FailingMapping()})]):NotImplementedError:('keys',)
vim.List([Mapping({"abcG" : FailingMappingKey()})]):NotImplementedError:('getitem:mappingkey',)
vim.List([Mapping({"abcG" : FailingNumber()})]):TypeError:('long() argument must be a string or a number',)
<<< Finished
>>> Testing *Iter* using vim.List([%s])
vim.List([FailingIter()]):TypeError:('unable to convert FailingIter to vim structure',)
vim.List([FailingIterNext()]):NotImplementedError:('next',)
<<< Finished
>>> Testing ConvertFromPyObject using vim.List([%s])
vim.List([None]):NOT FAILED
vim.List([{"": 1}]):ValueError:('empty keys are not allowed',)
vim.List([{u"": 1}]):ValueError:('empty keys are not allowed',)
vim.List([FailingMapping()]):NotImplementedError:('keys',)
vim.List([FailingMappingKey()]):NotImplementedError:('getitem:mappingkey',)
vim.List([FailingNumber()]):TypeError:('long() argument must be a string or a number',)
<<< Finished
>> ListItem
l[1000]:IndexError:('list index out of range',)
>> ListAssItem
ll[1] = 2:error:('list is locked',)
l[1000] = 3:IndexError:('list index out of range',)
>> ListAssSlice
ll[1:100] = "abcJ":error:('list is locked',)
>>> Testing *Iter* using l[:] = %s
l[:] = FailingIter():NotImplementedError:('iter',)
l[:] = FailingIterNext():NotImplementedError:('next',)
<<< Finished
nel[1:10:2]  = "abcK":ValueError:('attempt to assign sequence of size greater than 2 to extended slice',)
('a', 'b', 'c', 'O')
nel[1:10:2]  = "a":ValueError:('attempt to assign sequence of size 1 to extended slice of size 2',)
('a', 'b', 'c', 'O')
nel[1:1:-1]  = "a":ValueError:('attempt to assign sequence of size greater than 0 to extended slice',)
('a', 'b', 'c', 'O')
nel[:] = FailingIterNextN(2):NotImplementedError:('next N',)
('a', 'b', 'c', 'O')
>>> Testing StringToChars using l[:] = [{%s : 1}]
l[:] = [{1 : 1}]:TypeError:('expected str() or unicode() instance, but got int',)
l[:] = [{u"\0" : 1}]:TypeError:('expected string without null bytes',)
l[:] = [{"\0" : 1}]:TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing StringToChars using l[:] = [{"abcF" : {%s : 1}}]
l[:] = [{"abcF" : {1 : 1}}]:TypeError:('expected str() or unicode() instance, but got int',)
l[:] = [{"abcF" : {u"\0" : 1}}]:TypeError:('expected string without null bytes',)
l[:] = [{"abcF" : {"\0" : 1}}]:TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing StringToChars using l[:] = [{"abcF" : Mapping({%s : 1})}]
l[:] = [{"abcF" : Mapping({1 : 1})}]:TypeError:('expected str() or unicode() instance, but got int',)
l[:] = [{"abcF" : Mapping({u"\0" : 1})}]:TypeError:('expected string without null bytes',)
l[:] = [{"abcF" : Mapping({"\0" : 1})}]:TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing *Iter* using l[:] = [{"abcF" : %s}]
l[:] = [{"abcF" : FailingIter()}]:TypeError:('unable to convert FailingIter to vim structure',)
l[:] = [{"abcF" : FailingIterNext()}]:NotImplementedError:('next',)
<<< Finished
>>> Testing ConvertFromPyObject using l[:] = [{"abcF" : %s}]
l[:] = [{"abcF" : None}]:NOT FAILED
l[:] = [{"abcF" : {"": 1}}]:ValueError:('empty keys are not allowed',)
l[:] = [{"abcF" : {u"": 1}}]:ValueError:('empty keys are not allowed',)
l[:] = [{"abcF" : FailingMapping()}]:NotImplementedError:('keys',)
l[:] = [{"abcF" : FailingMappingKey()}]:NotImplementedError:('getitem:mappingkey',)
l[:] = [{"abcF" : FailingNumber()}]:TypeError:('long() argument must be a string or a number',)
<<< Finished
>>> Testing StringToChars using l[:] = [Mapping({%s : 1})]
l[:] = [Mapping({1 : 1})]:TypeError:('expected str() or unicode() instance, but got int',)
l[:] = [Mapping({u"\0" : 1})]:TypeError:('expected string without null bytes',)
l[:] = [Mapping({"\0" : 1})]:TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing StringToChars using l[:] = [Mapping({"abcG" : {%s : 1}})]
l[:] = [Mapping({"abcG" : {1 : 1}})]:TypeError:('expected str() or unicode() instance, but got int',)
l[:] = [Mapping({"abcG" : {u"\0" : 1}})]:TypeError:('expected string without null bytes',)
l[:] = [Mapping({"abcG" : {"\0" : 1}})]:TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing StringToChars using l[:] = [Mapping({"abcG" : Mapping({%s : 1})})]
l[:] = [Mapping({"abcG" : Mapping({1 : 1})})]:TypeError:('expected str() or unicode() instance, but got int',)
l[:] = [Mapping({"abcG" : Mapping({u"\0" : 1})})]:TypeError:('expected string without null bytes',)
l[:] = [Mapping({"abcG" : Mapping({"\0" : 1})})]:TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing *Iter* using l[:] = [Mapping({"abcG" : %s})]
l[:] = [Mapping({"abcG" : FailingIter()})]:TypeError:('unable to convert FailingIter to vim structure',)
l[:] = [Mapping({"abcG" : FailingIterNext()})]:NotImplementedError:('next',)
<<< Finished
>>> Testing ConvertFromPyObject using l[:] = [Mapping({"abcG" : %s})]
l[:] = [Mapping({"abcG" : None})]:NOT FAILED
l[:] = [Mapping({"abcG" : {"": 1}})]:ValueError:('empty keys are not allowed',)
l[:] = [Mapping({"abcG" : {u"": 1}})]:ValueError:('empty keys are not allowed',)
l[:] = [Mapping({"abcG" : FailingMapping()})]:NotImplementedError:('keys',)
l[:] = [Mapping({"abcG" : FailingMappingKey()})]:NotImplementedError:('getitem:mappingkey',)
l[:] = [Mapping({"abcG" : FailingNumber()})]:TypeError:('long() argument must be a string or a number',)
<<< Finished
>>> Testing *Iter* using l[:] = [%s]
l[:] = [FailingIter()]:TypeError:('unable to convert FailingIter to vim structure',)
l[:] = [FailingIterNext()]:NotImplementedError:('next',)
<<< Finished
>>> Testing ConvertFromPyObject using l[:] = [%s]
l[:] = [None]:NOT FAILED
l[:] = [{"": 1}]:ValueError:('empty keys are not allowed',)
l[:] = [{u"": 1}]:ValueError:('empty keys are not allowed',)
l[:] = [FailingMapping()]:NotImplementedError:('keys',)
l[:] = [FailingMappingKey()]:NotImplementedError:('getitem:mappingkey',)
l[:] = [FailingNumber()]:TypeError:('long() argument must be a string or a number',)
<<< Finished
>> ListConcatInPlace
>>> Testing *Iter* using l.extend(%s)
l.extend(FailingIter()):NotImplementedError:('iter',)
l.extend(FailingIterNext()):NotImplementedError:('next',)
<<< Finished
>>> Testing StringToChars using l.extend([{%s : 1}])
l.extend([{1 : 1}]):TypeError:('expected str() or unicode() instance, but got int',)
l.extend([{u"\0" : 1}]):TypeError:('expected string without null bytes',)
l.extend([{"\0" : 1}]):TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing StringToChars using l.extend([{"abcF" : {%s : 1}}])
l.extend([{"abcF" : {1 : 1}}]):TypeError:('expected str() or unicode() instance, but got int',)
l.extend([{"abcF" : {u"\0" : 1}}]):TypeError:('expected string without null bytes',)
l.extend([{"abcF" : {"\0" : 1}}]):TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing StringToChars using l.extend([{"abcF" : Mapping({%s : 1})}])
l.extend([{"abcF" : Mapping({1 : 1})}]):TypeError:('expected str() or unicode() instance, but got int',)
l.extend([{"abcF" : Mapping({u"\0" : 1})}]):TypeError:('expected string without null bytes',)
l.extend([{"abcF" : Mapping({"\0" : 1})}]):TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing *Iter* using l.extend([{"abcF" : %s}])
l.extend([{"abcF" : FailingIter()}]):TypeError:('unable to convert FailingIter to vim structure',)
l.extend([{"abcF" : FailingIterNext()}]):NotImplementedError:('next',)
<<< Finished
>>> Testing ConvertFromPyObject using l.extend([{"abcF" : %s}])
l.extend([{"abcF" : None}]):NOT FAILED
l.extend([{"abcF" : {"": 1}}]):ValueError:('empty keys are not allowed',)
l.extend([{"abcF" : {u"": 1}}]):ValueError:('empty keys are not allowed',)
l.extend([{"abcF" : FailingMapping()}]):NotImplementedError:('keys',)
l.extend([{"abcF" : FailingMappingKey()}]):NotImplementedError:('getitem:mappingkey',)
l.extend([{"abcF" : FailingNumber()}]):TypeError:('long() argument must be a string or a number',)
<<< Finished
>>> Testing StringToChars using l.extend([Mapping({%s : 1})])
l.extend([Mapping({1 : 1})]):TypeError:('expected str() or unicode() instance, but got int',)
l.extend([Mapping({u"\0" : 1})]):TypeError:('expected string without null bytes',)
l.extend([Mapping({"\0" : 1})]):TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing StringToChars using l.extend([Mapping({"abcG" : {%s : 1}})])
l.extend([Mapping({"abcG" : {1 : 1}})]):TypeError:('expected str() or unicode() instance, but got int',)
l.extend([Mapping({"abcG" : {u"\0" : 1}})]):TypeError:('expected string without null bytes',)
l.extend([Mapping({"abcG" : {"\0" : 1}})]):TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing StringToChars using l.extend([Mapping({"abcG" : Mapping({%s : 1})})])
l.extend([Mapping({"abcG" : Mapping({1 : 1})})]):TypeError:('expected str() or unicode() instance, but got int',)
l.extend([Mapping({"abcG" : Mapping({u"\0" : 1})})]):TypeError:('expected string without null bytes',)
l.extend([Mapping({"abcG" : Mapping({"\0" : 1})})]):TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing *Iter* using l.extend([Mapping({"abcG" : %s})])
l.extend([Mapping({"abcG" : FailingIter()})]):TypeError:('unable to convert FailingIter to vim structure',)
l.extend([Mapping({"abcG" : FailingIterNext()})]):NotImplementedError:('next',)
<<< Finished
>>> Testing ConvertFromPyObject using l.extend([Mapping({"abcG" : %s})])
l.extend([Mapping({"abcG" : None})]):NOT FAILED
l.extend([Mapping({"abcG" : {"": 1}})]):ValueError:('empty keys are not allowed',)
l.extend([Mapping({"abcG" : {u"": 1}})]):ValueError:('empty keys are not allowed',)
l.extend([Mapping({"abcG" : FailingMapping()})]):NotImplementedError:('keys',)
l.extend([Mapping({"abcG" : FailingMappingKey()})]):NotImplementedError:('getitem:mappingkey',)
l.extend([Mapping({"abcG" : FailingNumber()})]):TypeError:('long() argument must be a string or a number',)
<<< Finished
>>> Testing *Iter* using l.extend([%s])
l.extend([FailingIter()]):TypeError:('unable to convert FailingIter to vim structure',)
l.extend([FailingIterNext()]):NotImplementedError:('next',)
<<< Finished
>>> Testing ConvertFromPyObject using l.extend([%s])
l.extend([None]):NOT FAILED
l.extend([{"": 1}]):ValueError:('empty keys are not allowed',)
l.extend([{u"": 1}]):ValueError:('empty keys are not allowed',)
l.extend([FailingMapping()]):NotImplementedError:('keys',)
l.extend([FailingMappingKey()]):NotImplementedError:('getitem:mappingkey',)
l.extend([FailingNumber()]):TypeError:('long() argument must be a string or a number',)
<<< Finished
>> ListSetattr
del l.locked:AttributeError:('cannot delete vim.List attributes',)
l.locked = FailingTrue():NotImplementedError:('bool',)
l.xxx = True:AttributeError:('cannot set attribute xxx',)
> Function
>> FunctionConstructor
>>> FunctionConstructor
vim.Function("123"):ValueError:('unnamed function 123 does not exist',)
vim.Function("xxx_non_existent_function_xxx"):ValueError:('function xxx_non_existent_function_xxx does not exist',)
vim.Function("xxx#non#existent#function#xxx"):NOT FAILED
vim.Function("xxx_non_existent_function_xxx2", args=[]):ValueError:('function xxx_non_existent_function_xxx2 does not exist',)
vim.Function("xxx_non_existent_function_xxx3", self={}):ValueError:('function xxx_non_existent_function_xxx3 does not exist',)
vim.Function("xxx_non_existent_function_xxx4", args=[], self={}):ValueError:('function xxx_non_existent_function_xxx4 does not exist',)
>>> FunctionNew
vim.Function("tr", self="abcFuncSelf"):TypeError:('unable to convert str to vim dictionary',)
vim.Function("tr", args=427423):TypeError:('unable to convert int to vim list',)
vim.Function("tr", self="abcFuncSelf2", args="abcFuncArgs2"):TypeError:('unable to convert str to vim dictionary',)
vim.Function(self="abcFuncSelf2", args="abcFuncArgs2"):TypeError:('unable to convert str to vim dictionary',)
vim.Function("tr", "", self="abcFuncSelf2", args="abcFuncArgs2"):TypeError:('unable to convert str to vim dictionary',)
vim.Function("tr", ""):TypeError:('function takes exactly 1 argument (2 given)',)
>> FunctionCall
>>> Testing StringToChars using f({%s : 1})
f({1 : 1}):TypeError:('expected str() or unicode() instance, but got int',)
f({u"\0" : 1}):TypeError:('expected string without null bytes',)
f({"\0" : 1}):TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing StringToChars using f({"abcF" : {%s : 1}})
f({"abcF" : {1 : 1}}):TypeError:('expected str() or unicode() instance, but got int',)
f({"abcF" : {u"\0" : 1}}):TypeError:('expected string without null bytes',)
f({"abcF" : {"\0" : 1}}):TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing StringToChars using f({"abcF" : Mapping({%s : 1})})
f({"abcF" : Mapping({1 : 1})}):TypeError:('expected str() or unicode() instance, but got int',)
f({"abcF" : Mapping({u"\0" : 1})}):TypeError:('expected string without null bytes',)
f({"abcF" : Mapping({"\0" : 1})}):TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing *Iter* using f({"abcF" : %s})
f({"abcF" : FailingIter()}):TypeError:('unable to convert FailingIter to vim structure',)
f({"abcF" : FailingIterNext()}):NotImplementedError:('next',)
<<< Finished
>>> Testing ConvertFromPyObject using f({"abcF" : %s})
f({"abcF" : None}):NOT FAILED
f({"abcF" : {"": 1}}):ValueError:('empty keys are not allowed',)
f({"abcF" : {u"": 1}}):ValueError:('empty keys are not allowed',)
f({"abcF" : FailingMapping()}):NotImplementedError:('keys',)
f({"abcF" : FailingMappingKey()}):NotImplementedError:('getitem:mappingkey',)
f({"abcF" : FailingNumber()}):TypeError:('long() argument must be a string or a number',)
<<< Finished
>>> Testing StringToChars using f(Mapping({%s : 1}))
f(Mapping({1 : 1})):TypeError:('expected str() or unicode() instance, but got int',)
f(Mapping({u"\0" : 1})):TypeError:('expected string without null bytes',)
f(Mapping({"\0" : 1})):TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing StringToChars using f(Mapping({"abcG" : {%s : 1}}))
f(Mapping({"abcG" : {1 : 1}})):TypeError:('expected str() or unicode() instance, but got int',)
f(Mapping({"abcG" : {u"\0" : 1}})):TypeError:('expected string without null bytes',)
f(Mapping({"abcG" : {"\0" : 1}})):TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing StringToChars using f(Mapping({"abcG" : Mapping({%s : 1})}))
f(Mapping({"abcG" : Mapping({1 : 1})})):TypeError:('expected str() or unicode() instance, but got int',)
f(Mapping({"abcG" : Mapping({u"\0" : 1})})):TypeError:('expected string without null bytes',)
f(Mapping({"abcG" : Mapping({"\0" : 1})})):TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing *Iter* using f(Mapping({"abcG" : %s}))
f(Mapping({"abcG" : FailingIter()})):TypeError:('unable to convert FailingIter to vim structure',)
f(Mapping({"abcG" : FailingIterNext()})):NotImplementedError:('next',)
<<< Finished
>>> Testing ConvertFromPyObject using f(Mapping({"abcG" : %s}))
f(Mapping({"abcG" : None})):NOT FAILED
f(Mapping({"abcG" : {"": 1}})):ValueError:('empty keys are not allowed',)
f(Mapping({"abcG" : {u"": 1}})):ValueError:('empty keys are not allowed',)
f(Mapping({"abcG" : FailingMapping()})):NotImplementedError:('keys',)
f(Mapping({"abcG" : FailingMappingKey()})):NotImplementedError:('getitem:mappingkey',)
f(Mapping({"abcG" : FailingNumber()})):TypeError:('long() argument must be a string or a number',)
<<< Finished
>>> Testing *Iter* using f(%s)
f(FailingIter()):TypeError:('unable to convert FailingIter to vim structure',)
f(FailingIterNext()):NotImplementedError:('next',)
<<< Finished
>>> Testing ConvertFromPyObject using f(%s)
f(None):NOT FAILED
f({"": 1}):ValueError:('empty keys are not allowed',)
f({u"": 1}):ValueError:('empty keys are not allowed',)
f(FailingMapping()):NotImplementedError:('keys',)
f(FailingMappingKey()):NotImplementedError:('getitem:mappingkey',)
f(FailingNumber()):TypeError:('long() argument must be a string or a number',)
<<< Finished
>>> Testing StringToChars using fd(self={%s : 1})
fd(self={1 : 1}):TypeError:('expected str() or unicode() instance, but got int',)
fd(self={u"\0" : 1}):TypeError:('expected string without null bytes',)
fd(self={"\0" : 1}):TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing StringToChars using fd(self={"abcF" : {%s : 1}})
fd(self={"abcF" : {1 : 1}}):TypeError:('expected str() or unicode() instance, but got int',)
fd(self={"abcF" : {u"\0" : 1}}):TypeError:('expected string without null bytes',)
fd(self={"abcF" : {"\0" : 1}}):TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing StringToChars using fd(self={"abcF" : Mapping({%s : 1})})
fd(self={"abcF" : Mapping({1 : 1})}):TypeError:('expected str() or unicode() instance, but got int',)
fd(self={"abcF" : Mapping({u"\0" : 1})}):TypeError:('expected string without null bytes',)
fd(self={"abcF" : Mapping({"\0" : 1})}):TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing *Iter* using fd(self={"abcF" : %s})
fd(self={"abcF" : FailingIter()}):TypeError:('unable to convert FailingIter to vim structure',)
fd(self={"abcF" : FailingIterNext()}):NotImplementedError:('next',)
<<< Finished
>>> Testing ConvertFromPyObject using fd(self={"abcF" : %s})
fd(self={"abcF" : None}):NOT FAILED
fd(self={"abcF" : {"": 1}}):ValueError:('empty keys are not allowed',)
fd(self={"abcF" : {u"": 1}}):ValueError:('empty keys are not allowed',)
fd(self={"abcF" : FailingMapping()}):NotImplementedError:('keys',)
fd(self={"abcF" : FailingMappingKey()}):NotImplementedError:('getitem:mappingkey',)
fd(self={"abcF" : FailingNumber()}):TypeError:('long() argument must be a string or a number',)
<<< Finished
>>> Testing StringToChars using fd(self=Mapping({%s : 1}))
fd(self=Mapping({1 : 1})):TypeError:('expected str() or unicode() instance, but got int',)
fd(self=Mapping({u"\0" : 1})):TypeError:('expected string without null bytes',)
fd(self=Mapping({"\0" : 1})):TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing StringToChars using fd(self=Mapping({"abcG" : {%s : 1}}))
fd(self=Mapping({"abcG" : {1 : 1}})):TypeError:('expected str() or unicode() instance, but got int',)
fd(self=Mapping({"abcG" : {u"\0" : 1}})):TypeError:('expected string without null bytes',)
fd(self=Mapping({"abcG" : {"\0" : 1}})):TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing StringToChars using fd(self=Mapping({"abcG" : Mapping({%s : 1})}))
fd(self=Mapping({"abcG" : Mapping({1 : 1})})):TypeError:('expected str() or unicode() instance, but got int',)
fd(self=Mapping({"abcG" : Mapping({u"\0" : 1})})):TypeError:('expected string without null bytes',)
fd(self=Mapping({"abcG" : Mapping({"\0" : 1})})):TypeError:('expected string without null bytes',)
<<< Finished
>>> Testing *Iter* using fd(self=Mapping({"abcG" : %s}))
fd(self=Mapping({"abcG" : FailingIter()})):TypeError:('unable to convert FailingIter to vim structure',)
fd(self=Mapping({"abcG" : FailingIterNext()})):NotImplementedError:('next',)
<<< Finished
>>> Testing ConvertFromPyObject using fd(self=Mapping({"abcG" : %s}))
fd(self=Mapping({"abcG" : None})):NOT FAILED
fd(self=Mapping({"abcG" : {"": 1}})):ValueError:('empty keys are not allowed',)
fd(self=Mapping({"abcG" : {u"": 1}})):ValueError:('empty keys are not allowed',)
fd(self=Mapping({"abcG" : FailingMapping()})):NotImplementedError:('keys',)
fd(self=Mapping({"abcG" : FailingMappingKey()})):NotImplementedError:('getitem:mappingkey',)
fd(self=Mapping({"abcG" : FailingNumber()})):TypeError:('long() argument must be a string or a number',)
<<< Finished
>>> Testing *Iter* using fd(self=%s)
fd(self=FailingIter()):TypeError:('unable to convert FailingIter to vim dictionary',)
fd(self=FailingIterNext()):TypeError:('unable to convert FailingIterNext to vim dictionary',)
<<< Finished
>>> Testing ConvertFromPyObject using fd(self=%s)
fd(self=None):TypeError:('unable to convert NoneType to vim dictionary',)
fd(self={"": 1}):ValueError:('empty keys are not allowed',)
fd(self={u"": 1}):ValueError:('empty keys are not allowed',)
fd(self=FailingMapping()):NotImplementedError:('keys',)
fd(self=FailingMappingKey()):NotImplementedError:('getitem:mappingkey',)
fd(self=FailingNumber()):TypeError:('unable to convert FailingNumber to vim dictionary',)
<<< Finished
>>> Testing ConvertFromPyMapping using fd(self=%s)
fd(self=[]):TypeError:('unable to convert list to vim dictionary',)
<<< Finished
> TabPage
>> TabPageAttr
vim.current.tabpage.xxx:AttributeError:('xxx',)
> TabList
>> TabListItem
vim.tabpages[1000]:IndexError:('no such tab page',)
> Window
>> WindowAttr
vim.current.window.xxx:AttributeError:('xxx',)
>> WindowSetattr
vim.current.window.buffer = 0:TypeError:('readonly attribute: buffer',)
vim.current.window.cursor = (100000000, 100000000):error:('cursor position outside buffer',)
vim.current.window.cursor = True:TypeError:('argument must be 2-item sequence, not bool',)
>>> Testing NumberToLong using vim.current.window.height = %s
vim.current.window.height = []:TypeError:('expected int(), long() or something supporting coercing to long(), but got list',)
vim.current.window.height = None:TypeError:('expected int(), long() or something supporting coercing to long(), but got NoneType',)
vim.current.window.height = -1:ValueError:('number must be greater or equal to zero',)
<<< Finished
>>> Testing NumberToLong using vim.current.window.width = %s
vim.current.window.width = []:TypeError:('expected int(), long() or something supporting coercing to long(), but got list',)
vim.current.window.width = None:TypeError:('expected int(), long() or something supporting coercing to long(), but got NoneType',)
vim.current.window.width = -1:ValueError:('number must be greater or equal to zero',)
<<< Finished
vim.current.window.xxxxxx = True:AttributeError:('xxxxxx',)
> WinList
>> WinListItem
vim.windows[1000]:IndexError:('no such window',)
> Buffer
>> StringToLine (indirect)
vim.current.buffer[0] = u"\na":error:('string cannot contain newlines',)
vim.current.buffer[0] = "\na":error:('string cannot contain newlines',)
>> SetBufferLine (indirect)
vim.current.buffer[0] = True:TypeError:('bad argument type for built-in operation',)
>> SetBufferLineList (indirect)
vim.current.buffer[:] = True:TypeError:('bad argument type for built-in operation',)
vim.current.buffer[:] = ["\na", "bc"]:error:('string cannot contain newlines',)
>> InsertBufferLines (indirect)
vim.current.buffer.append(None):TypeError:('bad argument type for built-in operation',)
vim.current.buffer.append(["\na", "bc"]):error:('string cannot contain newlines',)
vim.current.buffer.append("\nbc"):error:('string cannot contain newlines',)
>> RBItem
vim.current.buffer[100000000]:IndexError:('line number out of range',)
>> RBAsItem
vim.current.buffer[100000000] = "":IndexError:('line number out of range',)
>> BufferAttr
vim.current.buffer.xxx:AttributeError:('xxx',)
>> BufferSetattr
vim.current.buffer.name = True:TypeError:('expected str() or unicode() instance, but got bool',)
vim.current.buffer.xxx = True:AttributeError:('xxx',)
>> BufferMark
vim.current.buffer.mark(0):TypeError:('expected str() or unicode() instance, but got int',)
vim.current.buffer.mark("abcM"):ValueError:('mark name must be a single character',)
vim.current.buffer.mark("!"):error:('invalid mark name',)
>> BufferRange
vim.current.buffer.range(1, 2, 3):TypeError:('function takes exactly 2 arguments (3 given)',)
> BufMap
>> BufMapItem
vim.buffers[100000000]:KeyError:(100000000,)
>>> Testing NumberToLong using vim.buffers[%s]
vim.buffers[[]]:TypeError:('expected int(), long() or something supporting coercing to long(), but got list',)
vim.buffers[None]:TypeError:('expected int(), long() or something supporting coercing to long(), but got NoneType',)
vim.buffers[-1]:ValueError:('number must be greater than zero',)
vim.buffers[0]:ValueError:('number must be greater than zero',)
<<< Finished
> Current
>> CurrentGetattr
vim.current.xxx:AttributeError:('xxx',)
>> CurrentSetattr
vim.current.line = True:TypeError:('bad argument type for built-in operation',)
vim.current.buffer = True:TypeError:('expected vim.Buffer object, but got bool',)
vim.current.window = True:TypeError:('expected vim.Window object, but got bool',)
vim.current.tabpage = True:TypeError:('expected vim.TabPage object, but got bool',)
vim.current.xxx = True:AttributeError:('xxx',)
['/testdir']
'/testdir'
2,xx
before
after
pythonx/topmodule/__init__.py
pythonx/topmodule/submodule/__init__.py
pythonx/topmodule/submodule/subsubmodule/subsubsubmodule.py
vim.command("throw 'abcN'"):error:('abcN',)
Exe("throw 'def'"):error:('def',)
vim.eval("Exe('throw ''ghi''')"):error:('ghi',)
vim.eval("Exe('echoerr ''jkl''')"):error:('Vim(echoerr):jkl',)
vim.eval("Exe('xxx_non_existent_command_xxx')"):error:('Vim:E492: Not an editor command: xxx_non_existent_command_xxx',)
vim.eval("xxx_unknown_function_xxx()"):error:('Vim:E117: Unknown function: xxx_unknown_function_xxx',)
vim.bindeval("Exe('xxx_non_existent_command_xxx')"):error:('Vim:E492: Not an editor command: xxx_non_existent_command_xxx',)
Caught KeyboardInterrupt
Running :put
No exception

