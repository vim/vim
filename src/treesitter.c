/* vi:set ts=8 sts=4 sw=4 noet:
 *
 * VIM - Vi IMproved	by Bram Moolenaar
 *
 * Do ":help uganda"  in Vim to read copying and usage conditions.
 * Do ":help credits" in Vim to see a list of people who contributed.
 * See README.txt for an overview of the Vim source code.
 */

/*
 * treesitter.c: Treesitter integration logic
 */

#include "vim.h"

#ifdef FEAT_TREESITTER

#include <tree_sitter/api.h>

#ifdef MSWIN
# define load_dll vimLoadLib
# define symbol_from_dll GetProcAddress
# define close_dll FreeLibrary
# define load_dll_error GetWin32Error
#else
# include <dlfcn.h>
# define HANDLE void*
# define load_dll(n) dlopen((n), RTLD_LAZY)
# define symbol_from_dll dlsym
# define close_dll dlclose
# define load_dll_error dlerror
#endif

// A TSLanguage is an opaque object that defines how to parse a particular
// programming language. The code for each TSLanguage is generated by
// Tree-sitter. Many languages are already available in separate git repositories
// within the Tree-sitter GitHub organization and the Tree-sitter grammars GitHub
// organization. See the next section for how to create new languages.
// 
// A TSParser is a stateful object that can be assigned a TSLanguage and used to
// produce a TSTree based on some source code.
// 
// A TSTree represents the syntax tree of an entire source code file. It contains
// TSNode instances that indicate the structure of the source code. It can also
// be edited and used to produce a new TSTree in the event that the source code
// changes.
// 
// A TSNode represents a single node in the syntax tree. It tracks its start and
// end positions in the source code, as well as its relation to other nodes like
// its parent, siblings and children.

// This is not exposed in vimscript. It is held internally in a hash table to be
// used multiple times.
typedef struct
{
    HANDLE		dll_handle;
    const TSLanguage	*tl_lang;
    char_u		name[1]; // Actually longer
} vts_language_T;

#define VTS_LANG_OFF (offsetof(vts_language_T, name))
#define HI2LANG(hi) ((vts_language_T *)(hi)->hi_key - VTS_LANG_OFF)


// Table of loaded TSLanguage objects. Each key the language name.
static hashtab_T languages;

    int
init_treesitter(void)
{
    hash_init(&languages);

    return OK;
}

/*
 * Return the language parser from the given shared object at "path", with the
 * symbol suffix as "symbol". Return NULL on failure.
 */
    static const TSLanguage *
load_language(char *path, char *symbol, HANDLE *dll)
{
    HANDLE	    h = load_dll(path);
    TSLanguage	    *lang;
    TSLanguage	    *(*parser)(void);
    char	    symbol_buf[255];

    if (h == NULL)
    {
	semsg(_(e_could_not_load_library_str_str), path, load_dll_error());
	return NULL;
    }

    vim_snprintf(symbol_buf, sizeof(symbol_buf), "tree_sitter_%s", symbol);

    if ((parser = symbol_from_dll(h, symbol_buf)) == NULL)
    {
	semsg(_(e_could_not_load_library_function_str), symbol_buf);
	close_dll(h);
	return NULL;
    }

    if ((lang = parser()) == NULL)
    {
	semsg(_(e_treesitter_get_lang_error), path);
	close_dll(h);
	return NULL;
    }

    *dll = h;

    return lang;
}

/*
 * Handler function for ts_load_lang()
 */
    void
vts_load_language(char_u *name, char_u *path, char_u *symbol_name)
{
    hashitem_T		*hi;
    HANDLE		h;
    const TSLanguage	*lang_obj =
	load_language((char *)path, (char *)symbol_name, &h);

    if (lang_obj == NULL)
	return;

    hi = hash_find(&languages, name);

    if (HASHITEM_EMPTY(hi))
    {
	hash_T		hash = hash_hash(name);
	vts_language_T	*obj =
	    alloc(VTS_LANG_OFF + STRLEN(name) + 1);

	if (obj == NULL)
	    return;

	STRCPY(obj->name, name);
	obj->tl_lang = lang_obj;
	obj->dll_handle = h;

	hash_add_item(&languages, hi, obj->name, hash);
    }
    else
    {
	// Replace assigned TSLanguage object with new one. This does not affect
	// any objects that were created using this language, everything is
	// refcounted.
	vts_language_T	*lang = HI2LANG(hi);

	ts_language_delete(lang->tl_lang);
	lang->tl_lang = lang_obj;
    }
}

/*
 * Allocate a new object representing a TSParser. Returns NULL on failure.
 */
    vts_parser_T *
vts_parser_new(char_u *language)
{
    vts_parser_T    *new;
    hashitem_T	    *hi;
    vts_language_T  *lang;
    TSParser	    *parser;

    // Lookup language object and set parser to it.
    hi = hash_find(&languages, language);

    if (HASHITEM_EMPTY(hi))
    {
	semsg(_(e_treesitter_lang_not_loaded), language);
	return NULL;
    }
    else
	lang = HI2LANG(hi);

    parser = ts_parser_new();

    if (parser == NULL)
	// No documentation on how the function handles errors, but still check
	// for them.
	return NULL;

    new = ALLOC_ONE(vts_parser_T);

    if (new == NULL)
    {
	ts_parser_delete(parser);
	return NULL;
    }

    ts_parser_set_language(parser, lang->tl_lang);
    ga_init2(&new->tp_children, sizeof(vts_parser_T), 2);
    new->tp_parser = parser;
    new->tp_tree = NULL;

    return new;
}

    void
vts_parser_free(vts_parser_T *self)
{
    ts_parser_delete(self->tp_parser);

    for (int i = 0; i < self->tp_children.ga_len; i++)
    {
	vts_parser_T *child = ((vts_parser_T **)self->tp_children.ga_data)[i];

	vts_parser_free(child);
    }
    ga_clear(&self->tp_children);

    vim_free(self);
}

#endif // FEAT_TREESITTER
