/* vi:set ts=8 sts=4 sw=4 noet:
 *
 * VIM - Vi IMproved	by Bram Moolenaar
 *
 * Do ":help uganda"  in Vim to read copying and usage conditions.
 * Do ":help credits" in Vim to see a list of people who contributed.
 * See README.txt for an overview of the Vim source code.
 */

/*
 * treesitter.c: Treesitter integration logic
 */

#include "vim.h"

#ifdef FEAT_TREESITTER

#include <tree_sitter/api.h>

#ifdef MSWIN
# define load_dll vimLoadLib
# define symbol_from_dll GetProcAddress
# define close_dll FreeLibrary
# define load_dll_error GetWin32Error
#else
# include <dlfcn.h>
# define HANDLE void*
# define load_dll(n) dlopen((n), RTLD_LAZY)
# define symbol_from_dll dlsym
# define close_dll dlclose
# define load_dll_error dlerror
#endif

// A TSLanguage is an opaque object that defines how to parse a particular
// programming language. The code for each TSLanguage is generated by
// Tree-sitter. Many languages are already available in separate git repositories
// within the Tree-sitter GitHub organization and the Tree-sitter grammars GitHub
// organization. See the next section for how to create new languages.
// 
// A TSParser is a stateful object that can be assigned a TSLanguage and used to
// produce a TSTree based on some source code.
// 
// A TSTree represents the syntax tree of an entire source code file. It contains
// TSNode instances that indicate the structure of the source code. It can also
// be edited and used to produce a new TSTree in the event that the source code
// changes.
// 
// A TSNode represents a single node in the syntax tree. It tracks its start and
// end positions in the source code, as well as its relation to other nodes like
// its parent, siblings and children.

typedef struct
{
    const TSLanguage *obj;
    char_u name[1]; // actually longer
} vts_lang_T;

#define TSLOFFSET (offsetof(vts_lang_T, name))
#define HI2TSL(hi)   ((vts_lang_T *)(hi)->hi_key)

typedef struct
{
    TSTree *obj;
    TSNode *root;
} vts_tree_T;

typedef struct 
{
    TSNode *root;
} vts_node_T;

// Table of loaded TSLanguage object. Each key the language name.
static hashtab_T loaded_langs;

    int
init_treesitter(void)
{
    hash_init(&loaded_langs);

    return OK;
}

/*
 * Return the language parser from the given shared object at "path", with the
 * symbol suffix as "symbol". Return NULL on failure.
 */
    static const TSLanguage *
load_language(char *path, char *symbol)
{
    HANDLE	    h = load_dll(path);
    TSLanguage	    *lang;
    TSLanguage	    *(*parser)(void);
    char	    symbol_buf[255];

    if (h == NULL)
    {
	semsg(_(e_could_not_load_library_str_str), path, load_dll_error());
	return NULL;
    }

    vim_snprintf(symbol_buf, sizeof(symbol_buf), "tree_sitter_%s", symbol);

    if ((parser = symbol_from_dll(h, symbol_buf)) == NULL)
    {
	semsg(_(e_could_not_load_library_function_str), symbol_buf);
	close_dll(h);
	return NULL;
    }

    if ((lang = parser()) == NULL)
    {
	semsg(_(e_treesitter_get_lang_error), path);
	close_dll(h);
	return NULL;
    }

    return lang;
}

    void
treesitter_load_language(char_u *name, char_u *path, char_u *symbol_name)
{
    hashitem_T		*hi;
    const TSLanguage	*lang_obj = load_language((char *)path, (char *)symbol_name);

    if (lang_obj == NULL)
	return;

    hi = hash_find(&loaded_langs, name);

    if (HASHITEM_EMPTY(hi))
    {
	hash_T h = hash_hash(name);
	vts_lang_T *obj = alloc(TSLOFFSET + STRLEN(name) + 1);

	if (obj == NULL)
	    return;
	STRCPY(obj->name, name);
	obj->obj = lang_obj;

	hash_add_item(&loaded_langs, hi, obj->name, h);
    }
    else
    {
	// Replace assigned TSLanguage object with new one
	vts_lang_T *lang = HI2TSL(hi);

	ts_language_delete(lang->obj);
	lang->obj = lang_obj;
    }
}

#endif // FEAT_TREESITTER
